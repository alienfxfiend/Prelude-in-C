=============================
Introduction to Pointers
=============================
Pointers

Every variable is a memory location, which has its address defined.
That address can be accessed using the ampersand (&) operator (also called the address-of operator), which denotes an address in memory.

For example:
#include <iostream>
using namespace std;

int main()
{
    int score = 5;
    cout << &score << endl;

    return 0;
}
This outputs the memory address, which stores the variable score.

Pointers

A pointer is a variable, with the address of another variable as its value.
In C++, pointers help make certain tasks easier to perform. Other tasks, such as dynamic memory allocation, cannot be performed without using pointers.

All pointers share the same data type - a long hexadecimal number that represents a memory address.

The only difference between pointers of different data types is the data type of the variable that the pointer points to.

Pointers

A pointer is a variable, and like any other variable, it must be declared before you can work with it.
The asterisk sign is used to declare a pointer (the same asterisk that you use for multiplication), however, in this statement the asterisk is being used to designate a variable as a pointer.
Following are valid pointer declarations:
int *ip;  // pointer to an integer
double *dp;   // pointer to a double
float *fp;  // pointer to a float
char *ch;  // pointer to a character
CPP
Just like with variables, we give the pointers a name and define the type, to which the pointer points to.
The asterisk sign can be placed next to the data type, or the variable name, or in the middle.

Using Pointers

Here, we assign the address of a variable to the pointer.
#include <iostream>
using namespace std;

int main()
{
    int score = 5;
    int *scorePtr;
    scorePtr = &score;

    cout << scorePtr << endl;

    return 0;
}
The code above declares a pointer to an integer called scorePtr, and assigns to it the memory location of the score variable using the ampersand (address-of) operator.
Now, scorePtr's value is the memory location of score.

=============================
More on Pointers
=============================
Pointer Operations

There are two operators for pointers:
Address-of operator (&): returns the memory address of its operand.
Contents-of (or dereference) operator (*): returns the value of the variable located at the address specified by its operand.

For example:
#include <iostream>
using namespace std;

int main()
{
    int var = 50;
    int  *p;
    p = &var;

    cout << var << endl;
    // Outputs 50 (the value of var)

    cout << p << endl;
    // Outputs 0x29fee8 (var's memory location)

    cout << *p << endl;
    /* Outputs 50 (the value of the variable
     stored in the pointer p) */

    return 0;
}
The asterisk (*) is used in declaring a pointer for the simple purpose of indicating that it is a pointer (The asterisk is part of its type compound specifier). Don't confuse this with the dereference operator, which is used to obtain the value located at the specified address. They are simply two different things represented with the same sign.

Dereferencing


The dereference operator (*) is basically an alias for the variable the pointer points to.
For example:
int x = 5;
int *p = &x;

x = x + 4;
x = *p + 4;
*p = *p + 4;
CPP

All three of the preceding statements are equivalent, and return the same result. We can access the variable by dereferencing the variable's pointer.
As p is pointing to the variable x, dereferencing the pointer (*p) is representing exactly the same as the variable x.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

					TABLE OF CONTENTS:
::Basic Concepts::
1.1 What is C#?
2.1 Variables
3.1 Your First C# Program
4.1 Printing Text
5.1 Getting User Input
6.1 Comments
7.1 The var Keyword
8.1 Constants
9.1 Arithmetic Operators
10.1 Assignment & Increment Operators

::Conditionals and Loops::
13.1 The if-else Statement
14.1 The switch Statement
15.1 The while Loop
16.1 The for Loop
17.1 The do-while Loop
18.1 break and continue
19.1 Logical Operators
20.1 The Conditional Operator
21.1 Basic Calculator

::Methods::
24.1 Introduction to Methods
25.1 Method Parameters
26.1 Multiple Parameters
27.1 Optional & Named Arguments
28.1 Passing Arguments
29.1 Method Overloading
30.1 Recursion
31.1 Making a Pyramid

::Classes & Objects::
34.1 Classes & Objects
35.1 Value & Reference Types
36.1 Class Example
37.1 Encapsulation
38.1 Constructors
39.1 Properties

::Arrays and Strings::
42.1 Arrays
43.1 Using Arrays in Loops
44.1 Multidimensional Arrays
45.1 Jagged Arrays
46.1 Array Properties & Methods
47.1 Working with Strings

::More on Classes::
50.1 Destructors
51.1 Static Members
52.1 Static Classes
53.1 this & readonly
54.1 Indexers
55.1 Operator Overloading

::Inheritance & Polymorphism::
58.1 Inheritance
59.1 Protected Members
60.1 Derived Class Constructor & Destructor
61.1 Polymorphism
62.1 Abstract Classes
63.1 Interfaces
64.1 Nested Classes
65.1 Namespaces

::Structs, Enums, Exceptions & Files::
68.1 Structs
69.1 Enums
70.1 Exception Handling
71.1 Working with Files

::Generics::
74.1 Generic Methods
75.1 Generic Classes
76.1 Collections
77.1 Lists and BitArray
78.1 Stack & Queue
79.1 Dictionary & HashSet

Check for Try it yourself before Basic Concepts -> Printing Text. Delegates + -=Typecasting=- convert one datatype to another. -=Delegate=- function pointer; delegates contains the reference to several methods and call them when needed. So, you create numbers of methods as you need and attach it to delegates. At runtime, an event gets fired and delegates dynamically call the function and show the result. -=Callback Function=- call to another function await another function to finish & alert calling. -=Nested For Loop=- outer loop creates rectangle, inner loop fills it. -=index++ (postfix (increment afterwards))=- https://www.cprogramming.com/tutorial/function-pointers.html

=============================
=============================
C# Basics
=============================
=============================

=============================
1.1 What is C#?
=============================
Welcome to C#

C# is an elegant object-oriented language that enables developers to build a variety of secure and robust applications that run on the .NET Framework.
You can use C# to create Windows applications, Web services, mobile applications, client-server applications, database applications, and much, much more.

The .NET Framework


The .NET Framework consists of the Common Language Runtime (CLR) and the .NET Framework class library.
The CLR is the foundation of the .NET Framework. It manages code at execution time, providing core services such as memory management, code accuracy, and many other aspects of your code.
The class library is a collection of classes, interfaces, and value types that enable you to accomplish a range of common programming tasks, such as data collection, file access, and working with text.
C# programs use the .NET Framework class library extensively to do common tasks and provide various functionalities.
These concepts might seem complex, but for now just remember that applications written in C# use the .NET Framework and its components.

=============================
2.1 Variables
=============================

Programs typically use data to perform tasks.
Creating a variable reserves a memory location, or a space in memory, for storing values. It is called variable because the information stored in that location can be changed when the program is running.
To use a variable, it must first be declared by specifying the name and data type.
A variable name, also called an identifier, can contain letters, numbers and the underscore character (_) and must start with a letter or underscore.
Although the name of a variable can be any set of letters and numbers, the best identifier is descriptive of the data it will contain. This is very important in order to create clear, understandable and readable code!
For example, firstName and lastName are good descriptive variable names, while abc and xyz are not.

Variable Types


A data type defines the information that can be stored in a variable, the size of needed memory and the operations that can be performed with the variable.
For example, to store an integer value (a whole number) in a variable, use the int keyword:
int myAge;
CS
The code above declares a variable named myAge of type integer.
A line of code that completes an action is called a statement. Each statement in C# must end with a semicolon.
You can assign the value of a variable when you declare it:
int myAge = 18;
CS
or later in your code:
int myAge;
myAge = 18;
CS
Remember that you need to declare the variable before using it.

Built-in Data Types


There are a number of built-in data types in C#. The most common are:
int - integer.
float - floating point number.
double - double-precision version of float.
char - a single character.
bool - Boolean that can have only one of two values: True or False.
string - a sequence of characters.
The statements below use C# data types:
int x = 42;
double pi = 3.14;
char y = 'Z';
bool isOnline = true;
string firstName = "David";
CS
Note that char values are assigned using single quotes and string values require double quotes.
You will learn how to perform different operations with variables in the upcoming lessons!

=============================
3.1 Your First C# program
=============================

You can run, save, and share your C# codes on our Code Playground, without installing any additional software.
Reference this lesson if you need to install the software on your computer.
To create a C# program, you need to install an integrated development environment (IDE) with coding and debugging tools.
We will be using Visual Studio Community Edition, which is available to download for free.
After installing it, choose the default configuration.
Next, click File->New->Project and then choose Console Application as shown below:contentImageEnter a name for your Project and click OK.
Console application uses a text-only interface. We chose this type of application to focus on learning the fundamentals of C#.

Your First C# Program


Visual Studio will automatically generate some code for your project:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace SoloLearn
{
   class Program
   {
      static void Main(string[] args)
      {
      }
   }
}
CS
You will learn what each of the statements does in the upcoming lessons.
For now, remember that every C# console application must contain a method (a function) named Main. Main is the starting point of every application, i.e. the point where our program starts execution from.
We will learn about classes, methods, arguments, and namespaces in the upcoming lessons.

Your First C# Program

To run your program, press Ctrl+F5. You will see the following screen:contentImageThis is a console window. As we did not have any statements in our Main method, the program just produces a general message. Pressing any key will close the console.
Congratulations, you just created your first C# program.

=============================
4.1 Printing Text
=============================

Displaying Output

Most applications require some input from the user and give output as a result.
To display text to the console window you use the Console.Write or Console.WriteLine methods. The difference between these two is that Console.WriteLine is followed by a line terminator, which moves the cursor to the next line after the text output.
The program below will display Hello World! to the console window:
Note the parentheses after the WriteLine method. This is the way to pass data, or arguments, to methods. In our case WriteLine is the method and we pass "Hello World!" to it as an argument. String arguments must be enclosed in quotation marks.

Displaying Output


We can display variable values to the console window:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 89;
            Console.WriteLine(x);
        }
    }
}

To display a formatted string, use the following syntax:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 10;
            double y = 20;
            Console.WriteLine("x = {0}; y = {1}", x, y);
        }
    }
}

As you can see, the value of x replaced {0} and the value of y replaced {1}.
You can have as many variable placeholders as you need. (i.e.: {3}, {4}, etc.).
icon
Your First Program
C# is cool! Let everyone know about it!

=============================
5.1 Getting User Input
=============================

User Input


You can also prompt the user to enter data and then use the Console.ReadLine method to assign the input to a string variable.
The following example asks the user for a name and then displays a message that includes the input:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string yourName;
            Console.WriteLine("What is your name?");
            yourName = Console.ReadLine();
 
            Console.WriteLine("Hello {0}", yourName);
        }
    }
}

The Console.ReadLine method waits for user input and then assigns it to the variable. The next statement displays a formatted string containing Hello with the user input. For example, if you enter David, the output will be Hello David.
Note the empty parentheses in the ReadLine method. This means that it does not take any arguments.

User Input


The Console.ReadLine() method returns a string value.
If you are expecting another type of value (such as int or double), the entered data must be converted to that type.
This can be done using the Convert.ToXXX methods, where XXX is the .NET name of the type that we want to convert to. For example, methods include Convert.ToDouble and Convert.ToBoolean.
For integer conversion, there are three alternatives available based on the bit size of the integer: Convert.ToInt16, Convert.ToInt32 and Convert.ToInt64. The default int type in C# is 32-bit.
Let’s create a program that takes an integer as input and displays it in a message:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = Convert.ToInt32(Console.ReadLine());
            Console.WriteLine("You are {0} years old", age);
        }
    }
}

If, in the program above, a non-integer value is entered (for example, letters), the Convert will fail and cause an error.

=============================
6.1 Comments
=============================

Comments are explanatory statements that you can include in a program to benefit the reader of your code.
The compiler ignores everything that appears in the comment, so none of that information affects the result.

A comment beginning with two slashes (//) is called a single-line comment. The slashes tell the compiler to ignore everything that follows, until the end of the line.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            // Prints Hello
            Console.WriteLine("Hello");
        }
    }
}

When you run this code, Hello will be displayed to the screen. The // Prints Hello line is a comment and will not appear as output.

Multi-Line Comments


Comments that require multiple lines begin with /* and end with */ at the end of the comment block.
You can place them on the same line or insert one or more lines between them.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            /* Some long 
                comment text     
            */
            int x = 42;
            Console.WriteLine(x);
        }
    }
}

Adding comments to your code is good programming practice. It facilitates a clear understanding of the code for you and for others who read it.

=============================
7.1 The var Keyword
=============================

A variable can be explicitly declared with its type before it is used.
Alternatively, C# provides a handy function to enable the compiler to determine the type of the variable automatically based on the expression it is assigned to.
The var keyword is used for those scenarios:
var num = 15;
CS
The code above makes the compiler determine the type of the variable. Since the value assigned to the variable is an integer, the variable will be declared as an integer automatically.

The var Keyword


Variables declared using the var keyword are called implicitly typed variables.
Implicitly typed variables must be initialized with a value.
For example, the following program will cause an error:
var num;
num = 42;
CS
Although it is easy and convenient to declare variables using the var keyword, overuse can harm the readability of your code. Best practice is to explicitly declare variables.

=============================
8.1 Constants
=============================

Constants store a value that cannot be changed from their initial assignment.
To declare a constant, use the const modifier.
For example:
const double PI = 3.14; 
CS
The value of const PI cannot be changed during program execution.
For example, an assignment statement later in the program will cause an error:
const double PI = 3.14;
PI = 8; //error
CS
Constants must be initialized with a value when declared.

=============================
9.1 Arithmetic Operators
=============================

An operator is a symbol that performs mathematical or logical manipulations.

Arithmetic Operators

C# supports the following arithmetic operators:
Operator	Symbol		Form
Addition		+		x+y
Subtraction	-		x-y
Multiplication	*		x*y
Division		/		x/y
Modulus	%		x%y

Division

The division operator (/) divides the first operand by the second. If the operands are both integers, any remainder is dropped in order to return an integer value.
Example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 10 / 4;
            Console.WriteLine(x);
        }
    }
}

Division by 0 is undefined and will crash your program.

Modulus

The modulus operator (%) is informally known as the remainder operator because it returns the remainder of an integer division.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 25 % 7;
            Console.WriteLine(x);
        }
    }
}

Operator Precedence

Operator precedence determines the grouping of terms in an expression, which affects how an expression is evaluated. Certain operators take higher precedence over others; for example, the multiplication operator has higher precedence than the addition operator.
For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 4+3*2;
            Console.WriteLine(x);
        }
    }
}

The program evaluates 3*2 first, and then adds the result to 4.
As in mathematics, using parentheses alters operator precedence.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = (4 + 3) *2;
            Console.WriteLine(x);
        }
    }
}

The operations within parentheses are performed first. If there are parenthetical expressions nested within one another, the expression within the innermost parentheses is evaluated first.
If none of the expressions are in parentheses, multiplicative (multiplication, division, modulus) operators will be evaluated before additive (addition, subtraction) operators. Operators of equal precedence are evaluated from left to right.

=============================
10.1 Assignment & Increment Operators
=============================

The = assignment operator assigns the value on the right side of the operator to the variable on the left side.

C# also provides compound assignment operators that perform an operation and an assignment in one statement.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 42;
            x += 2; // equivalent to x = x + 2
            Console.WriteLine(x);

            x -= 6; // equivalent to x = x - 6
            Console.WriteLine(x);
        }
    }
}

Assignment Operators


The same shorthand syntax applies to the multiplication, division, and modulus operators.
x *= 8; // equivalent to x = x * 8
x /= 5; // equivalent to x = x / 5
x %= 2; // equivalent to x = x % 2
CS
The same shorthand syntax applies to the multiplication, division, and modulus operators.

Increment Operator


The increment operator is used to increase an integer's value by one, and is a commonly used C# operator.
x++; //equivalent to x = x + 1
CS
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 10;
            x++;
            Console.WriteLine(x);
        }
    }
}
The increment operator is used to increase an integer's value by one.

Prefix & Postfix Forms


The increment operator has two forms, prefix and postfix
++x; //prefix
x++; //postfix
CS
Prefix increments the value, and then proceeds with the expression.
Postfix evaluates the expression and then performs the incrementing.

Prefix example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 3;
            int y = ++x;
            Console.WriteLine(x+" "+y);
        }
    }
}
Postfix example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 3;
            int y = x++;
            Console.WriteLine(x+" "+y);
        }
    }
}
The prefix example increments the value of x, and then assigns it to y.
The postfix example assigns the value of x to y, and then increments x.

Decrement Operator


The decrement operator (--) works in much the same way as the increment operator, but instead of increasing the value, it decreases it by one.
--x; // prefix
x--; // postfix
CS
The decrement operator (--) works in much the same way as the increment operator.

=============================
=============================
Conditionals and Loops
=============================
=============================

=============================
13.1 The if-else Statement
=============================

The if statement is a conditional statement that executes a block of code when a condition is true.
The general form of the if statement is:
if (condition)
{
    // Execute this code when condition is true
}
CS
The condition can be any expression that returns true or false.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 8;
            int y = 3;
            
            if (x > y)
            { 
                Console.WriteLine("x is greater than y");
            }
        }
    }
}
The code above will evaluate the condition x > y. If it is true, the code inside the if block will execute.
When only one line of code is in the if block, the curly braces can be omitted.
For example:
if (x > y)
Console.WriteLine("x is greater than y");

Relational Operators

Operator	Description	Example
>=	Greater than or equal to	7>=4 True
<=	Less than or equal to	7<=4 False
==	Equal to			7==4 False
!=	Not equal to		7!=4 True


Use relational operators to evaluate conditions. In addition to the less than (<) and greater than (>) operators, the following operators are available:contentImage Example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int a=7, b=7;
            if (a == b) {
                Console.WriteLine("Equal");
            }
        }
    }
}

The else Clause

An optional else clause can be specified to execute a block of code when the condition in the if statement evaluates to false.
Syntax:
if (condition) 
{
   //statements
}
else 
{
   //statements
}
CS
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int mark = 85;
            
            if (mark < 50) 
            {
                Console.WriteLine("You failed.");
            }
            else
            {
                Console.WriteLine("You passed.");
            }
        }
    }
}

Nested if Statements


You can also include, or nest, if statements within another if statement.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int mark = 100;
            
            if (mark >= 50) {
                Console.WriteLine("You passed.");
                if (mark == 100) {
                    Console.WriteLine("Perfect!");
                }
            }
            else {
                Console.WriteLine("You failed.");
            }
        }
    }
}
You can nest an unlimited number of if-else statements.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = 17;
            if (age > 14) {
                if(age > 18) {
                    Console.WriteLine("Adult");
                }
                else {
                    Console.WriteLine("Teenager");
                }
            }
            else {
                if (age > 0) {
                    Console.WriteLine("Child");
                }
                else {
                    Console.WriteLine("Something's wrong");
                }
            }
        }
    }
}
Remember that all else clauses must have corresponding if statements.

The if-else if Statement


The if-else if statement can be used to decide among three or more actions.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 33;
            
            if (x == 8) {
                Console.WriteLine("Value of x is 8");
            }
            else if (x == 18) {
                Console.WriteLine("Value of x is 18");
            }
            else if (x == 33) {
                Console.WriteLine("Value of x is 33");
            }
            else {
                Console.WriteLine("No match");
            }
        }
    }
}
Remember, that an if can have zero or more else if's and they must come before the last else, which is optional.
Once an else if succeeds, none of the remaining else if's or else clause will be tested.

=============================
14.1 The switch Statement
=============================

The switch statement provides a more elegant way to test a variable for equality against a list of values.
Each value is called a case, and the variable being switched on is checked for each switch case.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int num = 3;
            switch (num)
            {
                case 1:
                    Console.WriteLine("one");
                    break;
                case 2:
                    Console.WriteLine("two");
                    break;
                case 3:
                    Console.WriteLine("three");
                    break;
            }
        }
    }
}
Each case represents a value to be checked, followed by a colon, and the statements to get executed if that case is matched.
A switch statement can include any number of cases. However, no two case labels may contain the same constant value.
The break; statement that ends each case will be covered shortly.

The default Case


In a switch statement, the optional default case is executed when none of the previous cases match.
Example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = 88;
            switch (age) {
                case 16:
                    Console.WriteLine("Too young");
                    break;
                case 42:
                    Console.WriteLine("Adult");
                    break;
                case 70:
                    Console.WriteLine("Senior");
                    break;
                default:
                    Console.WriteLine("The default case");
                    break;
            }
        }
    }
}
The default code executes when none of the cases matches the switch expression.

The break Statement


The role of the break statement is to terminate the switch statement.
Without it, execution continues past the matching case statements and falls through to the next case statements, even when the case labels don’t match the switch variable.
This behavior is called fallthrough and modern C# compilers will not compile such code. All case and default code must end with a break statement.
The break statement can also be used to break out of a loop. You will learn about loops in the coming lessons.

=============================
15.1 The while Loop
=============================

A while loop repeatedly executes a block of code as long as a given condition is true.
For example, the following code displays the numbers 1 through 5:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int num = 1;
            while(num < 6) 
            {
                Console.WriteLine(num);
                num++;
            }
        }
    }
}
The example above declares a variable equal to 1 (int num = 1). The while loop checks the condition (num < 6) and, if true, executes the statements in its body, which increment the value of num by one, before checking the loop condition again.

After the 5th iteration, num equals 6, the condition evaluates to false, and the loop stops running.
The loop body is the block of statements within curly braces.

The while Loop

The compound arithmetic operators can be used to further control the number of times a loop runs.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int num = 1;
            while(num < 6) 
            {
                Console.WriteLine(num);
                num+=2;
            }
        }
    }
}
Without a statement that eventually evaluates the loop condition to false, the loop will continue indefinitely.

The while Loop


We can shorten the previous example, by incrementing the value of num right in the condition:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int num = 0;
            while(++num < 6) 
                Console.WriteLine(num);
        }
    }
}
What do you think, is there a difference between while(num++ < 6) and while(++num < 6)?
Yes! The loop while(++num < 6) will execute 5 times, because pre-increment increases the value of x before checking the num < 6 condition, while post-increment will check the condition before increasing the value of num, making while(num++ < 6) execute 6 times.

=============================
16.1 The for Loop
=============================

A for loop executes a set of statements a specific number of times, and has the syntax:
for ( init; condition; increment ) {
  statement(s);
}
CS
A counter is declared once in init.
Next, the condition evaluates the value of the counter and the body of the loop is executed if the condition is true.
After loop execution, the increment statement updates the counter, also called the loop control variable.
The condition is again evaluated, and the loop body repeats, only stopping when the condition becomes false.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int x = 10; x < 15; x++)
            {
                Console.WriteLine("Value of x: {0}", x);
            }
        }
    }
}
Note the semicolons in the syntax.


The for Loop


Compound arithmetic operators can be used to further control loop iterations.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int x = 0; x < 10; x+=3)
            {
                Console.WriteLine(x);
            }
        }
    }
}
You can also decrement the counter:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int x = 10; x > 0; x-=2)
            {
                Console.WriteLine(x);
            }
        }
    }
}

The for Loop


The init and increment statements may be left out, if not needed, but remember that the semicolons are mandatory.
For example, the init can be left out:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 10;
            for ( ; x > 0; x -= 3)
            {
                Console.WriteLine(x);
            }
        }
    }
}
You can have the increment statement in the for loop body:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 10;
            for ( ; x > 0 ; )
            {
                Console.WriteLine(x);
                x -= 3;
            }
        }
    }
}
for (; ;) {} is an infinite loop.

=============================
17.1 The do-while Loop
=============================

A do-while loop is similar to a while loop, except that a do-while loop is guaranteed to execute at least one time.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 0;
            do {
                Console.WriteLine(a);
                a++;
            } while(a < 5);
        }
    }
}
Note the semicolon after the while statement.

do-while vs. while

If the condition of the do-while loop evaluates to false, the statements in the do will still run once:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 42;
            do {
                Console.WriteLine(x);
                x++;
            } while(x < 10);
        }
    }
}
The do-while loop executes the statements at least once, and then tests the condition.
The while loop executes the statement only after testing condition.

=============================
18.1 break and continue
=============================

We saw the use of break in the switch statement.
Another use of break is in loops: When the break statement is encountered inside a loop, the loop is immediately terminated and the program execution moves on to the next statement following the loop body.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int num = 0;
            while (num < 20)
            {
                if (num == 5)
                    break;

                Console.WriteLine(num);
                num++;
            }
        }
    }
}
If you are using nested loops (i.e., one loop inside another loop), the break statement will stop the execution of the innermost loop and start executing the next line of code after the block.

continue

The continue statement is similar to the break statement, but instead of terminating the loop entirely, it skips the current iteration of the loop and continues with the next iteration.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int i = 0; i < 10; i++) {
                if (i == 5)
                    continue;

                Console.WriteLine(i);
            }
        }
    }
}
As you can see, number 5 is not printed, as the continue statement skips the remaining statements of that iteration of the loop.

=============================
19.1 Logical Operators
=============================

Logical operators are used to join multiple expressions and return true or false.
Operator	Name of Operator	Form
&&		AND Operator		y && y
||		OR Operator		x || y
!		NOT Operator		! x

The AND operator (&&) works the following way:
Left Operand		Right Operand		Result
false			false			false
false			true			false
true			false			false
true			true			true

For example, if you wish to display text to the screen only if age is greater than 18 AND money is greater than 100:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = 42;
            double money = 540;
            if(age > 18 && money > 100) {
                Console.WriteLine("Welcome");
            }
        }
    }
}
The AND operator was used to combine the two expressions.
With the AND operator, both operands must be true for the entire expression to be true.

AND

You can join more than two conditions:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = 42;
            int grade = 75;
            if(age > 16 && age < 80 && grade > 50) 
                Console.WriteLine("Hey there");
        }
    }
}
The entire expression evaluates to true only if all of the conditions are true.

The OR Operator


The OR operator (||) returns true if any one of its operands is true.
Left Operand		Right Operand		Result
false			false			false
false			true			true
true			false			true
true			true			true

For Example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = 18;
            int score = 85;
            if (age > 20 || score > 50) {
                Console.WriteLine("Welcome");
            }
        }
    }
}
You can join any number of logical OR statements you want.
In addition, multiple OR and AND statements may be joined together.

Logical NOT


The logical NOT (!) operator works with just a single operand, reversing its logical state. Thus, if a condition is true, the NOT operator makes it false, and vice versa.
Right Operand		Result
true			false
false			true

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = 8;
            if ( !(age > 16) ) {
                Console.Write("Your age is less than 16");
            }
        }
    }
}

=============================
20.1 The Conditional ? : Operator
=============================

Consider the following example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = 42;
            string msg;
            if(age >= 18)
                msg = "Welcome";
            else
                msg = "Sorry";

            Console.WriteLine(msg);
        }
    }
}
The code above checks the value of the age variable and displays the corresponding message to the screen.
This can be done in a more elegant and shorter way by using the ?: operator, which has the following form:
Exp1 ? Exp2 : Exp3;
CS
The ?: operator works the following way: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire expression. If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression.
So, the example above can be replaced by the following:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = 42;
            string msg;
            msg = (age >= 18) ? "Welcome" : "Sorry";
            Console.WriteLine(msg);
        }
    }
}

=============================
21.1 Basic Calculator
=============================

Now let's create a simple project that repeatedly asks the user to enter two values and then displays their sum, until the user enters exit.
We start with a do-while loop that asks the user for input and calculates the sum:
do {
  Console.Write("x = ");
  int x = Convert.ToInt32(Console.ReadLine());

  Console.Write("y = ");
  int y = Convert.ToInt32(Console.ReadLine());

  int sum = x+y;
  Console.WriteLine("Result: {0}", sum);
}
while(true);
CS
This code will ask for user input infinitely. Now we need to handle the "exit".
If the user enters a non-integer value, the program will crash from a conversion error. We will learn how to handle errors like that in the coming modules.

Basic Calculator


If the user enters "exit" as the value of x, the program should quit the loop. To do this, we can use a break statement:
Console.Write("x = ");
string str = Console.ReadLine();
if (str == "exit")
  break;

int x = Convert.ToInt32(str);
CS
Here we compare the input with the value "exit" and break the loop.
So the whole program looks like:
 do {
  Console.Write("x = ");
  string str = Console.ReadLine();
  if (str == "exit")
    break;

  int x = Convert.ToInt32(str);

  Console.Write("y = ");
  int y = Convert.ToInt32(Console.ReadLine());

  int sum = x + y;
  Console.WriteLine("Result: {0}", sum);
}
while (true);
CS
If the user enters "exit" as the value of x, the program should quit the loop.

=============================
=============================
Methods
=============================
=============================

=============================
24.1 Introduction to Methods
=============================
What is a Method?


A method is a group of statements that perform a particular task.
In addition to the C# built-in methods, you may also define your own.

Methods have many advantages, including:
- Reusable code.
- Easy to test.
- Modifications to a method do not affect the calling program.
- One method can accept many different inputs.
Every valid C# program has at least one method, the Main method.

Declaring Methods


To use a method, you need to declare the method and then call it.
Each method declaration includes:
- the return type
- the method name
- an optional list of parameters.
<return type> name(type1 par1, type2 par2, … , typeN parN)
{
    List of statements
}
CS
For example, the following method has an int parameter and returns the number squared:
int Sqr(int x)
{
  int result = x*x;
  return result;
}
CS
The return type of a method is declared before its name. In the example above, the return type is int, which indicates that the method returns an integer value. When a method returns a value, it must include a return statement. Methods that return a value are often used in assignment statements.
Occasionally, a method performs the desired operations without returning a value. Such methods have a return type void. In this case, the method cannot be called as part of an assignment statement.
void is a basic data type that defines a valueless state.

Calling Methods


Parameters are optional; that is, you can have a method with no parameters.
As an example, let's define a method that does not return a value, and just prints a line of text to the screen.
static void SayHi()
{
  Console.WriteLine("Hello");
}
CS
Our method, entitled SayHi, returns void, and has no parameters.
To execute a method, you simply call the method by using the name and any required arguments in a statement.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void sayHi()
        {
            Console.WriteLine("Hello");
        }
        static void Main(string[] args)
        {
            sayHi();
        }
    }
}
The static keyword will be discussed later; it is used to make methods accessible in Main.

Calling Methods

You can call the same method multiple times:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void SayHi()
        {
            Console.WriteLine("Hello");
        }
        static void Main(string[] args)
        {
            SayHi();
            SayHi();
            SayHi();
        }
    }
}

=============================
25.1 Method Parameters
=============================

Method declarations can define a list of parameters to work with.
Parameters are variables that accept the values passed into the method when called.
For example:
void Print(int x) 
{
  Console.WriteLine(x);
}
CS
This defines a method that takes one integer parameter and displays its value.
Parameters behave within the method similarly to other local variables. They are created upon entering the method and are destroyed upon exiting the method.

Parameters

Now you can call the method in Main and pass in the value for its parameters (also called arguments):
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Print(int x) 
        {
            Console.WriteLine(x);
        }
        static void Main(string[] args)
        {
            Print(42);
        }
    }
}
The value 42 is passed to the method as an argument and is assigned to the formal parameter x.

Parameters

You can pass different arguments to the same method as long as they are of the expected type.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Func(int x)
        {
            Console.WriteLine(x*2);
        }
        static void Main(string[] args)
        {
            Func(5);
  
            Func(12);

            Func(42);
        }
    }
}

=============================
26.1 Multiple Parameters
=============================

You can have as many parameters as needed for a method by separating them with commas in the definition.
Let's create a simple method that returns the sum of two parameters:
int Sum(int x, int y)
{
   return x+y;
}
CS
The Sum method takes two integers and returns their sum. This is why the return type of the method is int. Data type and name should be defined for each parameter.
Methods return values using the return statement.

Multiple Parameters


A method call with multiple parameters must separate arguments with commas.
For example, a call to Sum requires two arguments:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static int Sum(int x, int y)
        {
            return x+y;
        }
        static void Main(string[] args)
        {
            Console.WriteLine(Sum(8, 6));
        }
    }
}
In the call above, the return value was displayed to the console window. Alternatively, we can assign the return value to a variable, as in the code below:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static int Sum(int x, int y)
        {
            return x+y;
        }
        static void Main(string[] args)
        {
            int res = Sum(11, 42);
            Console.WriteLine(res);
        }
    }
}
You can add as many parameters to a single method as you want. If you have multiple parameters, remember to separate them with commas, both when declaring them and when calling the method.

=============================
27.1 Optional and Named Arguments
=============================


When defining a method, you can specify a default value for optional parameters. Note that optional parameters must be defined after required parameters. If corresponding arguments are missing when the method is called, the method uses the default values.
To do this, assign values to the parameters in the method definition, as shown in this example.
static int Pow(int x, int y=2)
{
  int result = 1;
  for (int i = 0; i < y; i++)
  {
    result *= x;
  }
 
  return result;
}
CS
The Pow method assigns a default value of 2 to the y parameter. If we call the method without passing the value for the y parameter, the default value will be used.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static int Pow(int x, int y=2)
        {
            int result = 1;
            for (int i = 0; i < y; i++)
            {
                result *= x;
            }
            return result;
        }
        static void Main(string[] args)
        {
            Console.WriteLine(Pow(6));

            Console.WriteLine(Pow(3, 4));
        }
    }
}
As you can see, default parameter values can be used for calling the same method in different situations without requiring arguments for every parameter.
Just remember, that you must have the parameters with default values at the end of the parameter list when defining the method.

Named Arguments


Named arguments free you from the need to remember the order of the parameters in a method call. Each argument can be specified by the matching parameter name.
For example, the following method calculates the area of a rectangle by its height and width:
static int Area(int h, int w)
{
  return h * w;
}
CS
When calling the method, you can use the parameter names to provide the arguments in any order you like:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static int Area(int h, int w)
        {
            return h * w;
        }
        static void Main(string[] args)
        {
            int res = Area(w: 5, h: 8);
            Console.WriteLine(res);
        }
    }
}
Named arguments use the name of the parameter followed by a colon and the value.

=============================
28.1 Passing Arguments
=============================

There are three ways to pass arguments to a method when the method is called: By value, By reference, and as Output.

By value copies the argument's value into the method's formal parameter. Here, we can make changes to the parameter within the method without having any effect on the argument.
By default, C# uses call by value to pass arguments.
The following example demonstrates by value:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Sqr(int x)
        {
            x = x * x;
        }
        static void Main(string[] args)
        {
            int a = 3;
            Sqr(a);
            
            Console.WriteLine(a);
        }
    }
}
In this case, x is the parameter of the Sqr method and a is the actual argument passed into the method.
As you can see, the Sqr method does not change the original value of the variable, as it is passed by value, meaning that it operates on the value, not the actual variable.

Passing by Reference


Pass by reference copies an argument's memory address into the formal parameter. Inside the method, the address is used to access the actual argument used in the call. This means that changes made to the parameter affect the argument.
To pass the value by reference, the ref keyword is used in both the call and the method definition:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Sqr(ref int x)
        {
            x = x * x;
        }
        static void Main(string[] args)
        {
            int a = 3;
            Sqr(ref a);
            
            Console.WriteLine(a);
        }
    }
}
The ref keyword passes the memory address to the method parameter, which allows the method to operate on the actual variable.
The ref keyword is used both when defining the method and when calling it.

Passing by Output


Output parameters are similar to reference parameters, except that they transfer data out of the method rather than accept data in. They are defined using the out keyword.
The variable supplied for the output parameter need not be initialized since that value will not be used. Output parameters are particularly useful when you need to return multiple values from a method.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void GetValues(out int x, out int y)
        {
            x = 5;
            y = 42;
        }
        static void Main(string[] args)
        {
            int a, b;
            GetValues(out a, out b);
            Console.WriteLine(a+" "+b);
        }
    }
}
Unlike the previous reference type example, where the value 3 was referred to the method, which changed its value to 9, output parameters get their value from the method (5 and 42 in the above example).
Similar to the ref keyword, the out keyword is used both when defining the method and when calling it.

=============================
29.1 Method Overloading
=============================

Overloading


Method overloading is when multiple methods have the same name, but different parameters.
For example, you might have a Print method that outputs its parameter to the console window:
void Print(int a)
{
  Console.WriteLine("Value: "+a);
}
CS
The + operator is used to concatenate values. In this case, the value of a is joined to the text "Value: ".
This method accepts an integer argument only.
Overloading it will make it available for other types, such as double
void Print(double a)
{
  Console.WriteLine("Value: "+a);
}
CS
Now, the same Print method name will work for both integers and doubles.

Overloading


When overloading methods, the definitions of the methods must differ from each other by the types and/or number of parameters.
When there are overloaded methods, the method called is based on the arguments. An integer argument will call the method implementation that accepts an integer parameter. A double argument will call the implementation that accepts a double parameter. Multiple arguments will call the implementation that accepts the same number of arguments.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Print(int a) {
            Console.WriteLine("Value: " + a);
        }
        static void Print(double a) {
            Console.WriteLine("Value: " + a);
        }
        static void Print(string label, double a) {
            Console.WriteLine(label + a);
        }
        static void Main(string[] args)
        {
            Print(11);
            Print(4.13);
            Print("Average: ", 7.57);
        }
    }
}
You cannot overload method declarations that differ only by return type.
The following declaration results in an error.
int PrintName(int a) { }
float PrintName(int b) { }
double PrintName(int c) { }

=============================
30.1 Recursion
=============================
Recursion


A recursive method is a method that calls itself.
One of the classic tasks that can be solved easily by recursion is calculating the factorial of a number.
In mathematics, the term factorial refers to the product of all positive integers that are less than or equal to a specific non-negative integer (n). The factorial of n is denoted as n!
For example:
4! = 4 * 3 * 2 * 1 = 24
A recursive method is a method that calls itself.

Recursion


As you can see, a factorial can be thought of as repeatedly calculating num * num-1 until you reach 1.
Based on this solution, let's define our method:
static int Fact(int num) {
  if (num == 1) {
    return 1;
  }
  return num * Fact(num - 1);
}
CS
In the Fact recursive method, the if statement defines the exit condition, a base case that requires no recursion. In this case, when num equals one, the solution is simply to return 1 (the factorial of one is one).
The recursive call is placed after the exit condition and returns num multiplied by the factorial of n-1.
For example, if you call the Fact method with the argument 4, it will execute as follows:
return 4*Fact(3), which is 4*3*Fact(2), which is 4*3*2*Fact(1), which is 4*3*2*1.

Now we can call our Fact method from Main:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static int Fact(int num) {
            if (num == 1) {
                return 1;
            }
            return num * Fact(num - 1);
        }
        static void Main(string[] args)
        {
            Console.WriteLine(Fact(6));
        }
    }
}
The factorial method calls itself, and then continues to do so, until the argument equals 1. The exit condition prevents the method from calling itself indefinitely.

=============================
31.1 Making a Pyramid
=============================
Making a Pyramid


Now, let's create a method that will display a pyramid of any height to the console window using star (*) symbols.
Based on this description, a parameter will be defined to reflect the number of rows for the pyramid.

So, let's start by declaring the method:
static void DrawPyramid(int n)
{
   //some code will go here
}
CS
DrawPyramid does not need to return a value and takes an integer parameter n.
In programming, the step by step logic required for the solution to a problem is called an algorithm. The algorithm for MakePyramid is:
1. The first row should contain one star at the top center of the pyramid. The center is calculated based on the number of rows in the pyramid.
2. Each row after the first should contain an odd number of stars (1, 3, 5, etc.), until the number of rows is reached.

Based on the algorithm, the code will use for loops to display spaces and stars for each row:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
  class Program
  {
    static void DrawPyramid(int n)
    {
      for (int i=1; i<=n; i++)
      {
        for (int j=i; j<=n; j++)
        {
          Console.Write("  ");
        }
        for (int k=1; k<=2*i-1; k++)
        {
          Console.Write("*"+" ");
        }
        Console.WriteLine();
      }
    }
    static void Main(string[] args)
    {
      DrawPyramid(5);
    }
  }
}
The first for loop that iterates through each row of the pyramid contains two for loops.
The first inner loop displays the spaces needed before the first star symbol. The second inner loop displays the required number of stars for each row, which is calculated based on the formula (2*i-1) where i is the current row.
The final Console.WriteLine(); statement moves the cursor to the next row.
Now, if we call the DrawPyramid method, it will display a pyramid having the number of rows we pass to the method.

=============================
=============================
Classes & Objects
=============================
=============================

=============================
34.1 Classes & Objects
=============================

As we have seen in the previous modules, built-in data types are used to store a single value in a declared variable. For example, int x stores an integer value in a variable named x.
In object-oriented programming, a class is a data type that defines a set of variables and methods for a declared object.
For example, if you were to create a program that manages bank accounts, a BankAccount class could be used to declare an object that would have all the properties and methods needed for managing an individual bank account, such as a balance variable and Deposit and Withdrawal methods.

A class is like a blueprint. It defines the data and behavior for a type. A class definition starts with the keyword class followed by the class name. The class body contains the data and actions enclosed by curly braces.
class BankAccount
{
  //variables, methods, etc.
}
CS
The class defines a data type for objects, but it is not an object itself. An object is a concrete entity based on a class, and is sometimes referred to as an instance of a class.

Objects


Just as a built-in data type is used to declare multiple variables, a class can be used to declare multiple objects. As an analogy, in preparation for a new building, the architect designs a blueprint, which is used as a basis for actually building the structure. That same blueprint can be used to create multiple buildings.
Programming works in the same fashion. We define (design) a class that is the blueprint for creating objects.
In programming, the term type is used to refer to a class name: We're creating an object of a particular type.

Once we've written the class, we can create objects based on that class. Creating an object is called instantiation.
An object is called an instance of a class.

Objects


Each object has its own characteristics. Just as a person is distinguished by name, age, and gender, an object has its own set of values that differentiate it from another object of the same type.
The characteristics of an object are called properties.
Values of these properties describe the current state of an object. For example, a Person (an object of the class Person) can be 30 years old, male, and named Antonio.

Objects aren't always representative of just physical characteristics.
For example, a programming object can represent a date, a time, and a bank account. A bank account is not tangible; you can't see it or touch it, but it's still a well-defined object because it has its own properties.
Let's move on and see how to create your own custom classes and objects!

=============================
35.1 Value & Reference Types
=============================

C# has two ways of storing data: by reference and by value.
The built-in data types, such as int and double, are used to declare variables that are value types. Their value is stored in memory in a location called the stack.
For example, the declaration and assignment statement int x = 10; can be thought of as:contentImage
		Stack
		========
x -------------> 10	========
The value of the variable x is now stored on the stack.

Reference Types


Reference types are used for storing objects. For example, when you create an object of a class, it is stored as a reference type.
Reference types are stored in a part of the memory called the heap.
When you instantiate an object, the data for that object is stored on the heap, while its heap memory address is stored on the stack.
That is why it is called a reference type - it contains a reference (the memory address) to the actual object on the heap.
		Stack		Heap
		========	========
x -------------> 10	========	========
p1 --> 0x042b8	========  ---->	======== Person Object
As you can see, the p1 object of type Person on the stack stores the memory address of the heap where the actual object is stored.
Stack is used for static memory allocation, which includes all your value types, like x.
Heap is used for dynamic memory allocation, which includes custom objects, that might need additional memory during the runtime of your program.

=============================
36.1 Class Example
=============================
Example of a Class

Let’s create a Person class:
class Person
{
  int age;
  string name;
  public void SayHi()
  {
    Console.WriteLine("Hi");
  }
}
CS
The code above declares a class named Person, which has age and name fields as well as a SayHi method that displays a greeting to the screen.
You can include an access modifier for fields and methods (also called members) of a class. Access modifiers are keywords used to specify the accessibility of a member.
A member that has been defined public can be accessed from outside the class, as long as it's anywhere within the scope of the class object. That is why our SayHi method is declared public, as we are going to call it from outside of the class.
You can also designate class members as private or protected. This will be discussed in greater detail later in the course. If no access modifier is defined, the member is private by default.

Example of a Class


Now that we have our Person class defined, we can instantiate an object of that type in Main.
The new operator instantiates an object and returns a reference to its location:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person {
            int age;
            string name;
            public void SayHi() {
                Console.WriteLine("Hi");
            }
        }
        static void Main(string[] args)
        {
            Person p1 = new Person();
            p1.SayHi();
        }
    }
}
The code above declares a Person object named p1 and then calls its public SayHi() method.
Notice the dot operator (.) that is used to access and call the method of the object.

Example of a Class


You can access all public members of a class using the dot operator.
Besides calling a method, you can use the dot operator to make an assignment when valid.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Dog
        {
            public string name;
            public int age;
        }
        static void Main(string[] args)
        {
            Dog bob = new Dog();
            bob.name = "Bobby";
            bob.age = 3;
            
            Console.WriteLine(bob.age);
        }
    }
}

=============================
37.1 Encapsulation
=============================

Encapsulation


Part of the meaning of the word encapsulation is the idea of "surrounding" an entity, not just to keep what's inside together, but also to protect it.
In programming, encapsulation means more than simply combining members together within a class; it also means restricting access to the inner workings of that class.
Encapsulation is implemented by using access modifiers. An access modifier defines the scope and visibility of a class member.
Encapsulation is also called information hiding.

Encapsulation

C# supports the following access modifiers: public, private, protected, internal, protected internal.
As seen in the previous examples, the public access modifier makes the member accessible from the outside of the class.
The private access modifier makes members accessible only from within the class and hides them from the outside.
protected will be discussed later in the course.

Encapsulation


To show encapsulation in action, let’s consider the following example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class BankAccount {
        private double balance=0;
        public void Deposit(double n) {
            balance += n;
        }
        public void Withdraw(double n) {
            balance -= n;
        }
        public double GetBalance() {
            return balance;
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            BankAccount b = new BankAccount();
            b.Deposit(199);
            b.Withdraw(42);
            Console.WriteLine(b.GetBalance());
        }
    }
}
We used encapsulation to hide the balance member from the outside code. Then we provided restricted access to it using public methods. The class data can be read through the GetBalance method and modified only through the Deposit and Withdraw methods.
You cannot directly change the balance variable. You can only view its value using the public method. This helps maintain data integrity.
We could add different verification and checking mechanisms to the methods to provide additional security and prevent errors.
In summary, the benefits of encapsulation are:
- Control the way data is accessed or modified.
- Code is more flexible and easy to change with new requirements.
- Change one part of code without affecting other parts of code.

=============================
38.1 Constructors
=============================
Constructors


A class constructor is a special member method of a class that is executed whenever a new object of that class is created.
A constructor has exactly the same name as its class, is public, and does not have any return type.
For example:
class Person
{
  private int age;
  public Person()
  {
    Console.WriteLine("Hi there");
  }
}
CS
Now, upon the creation of an object of type Person, the constructor is automatically called.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person
        {
            private int age;
            public Person()
            {
                Console.WriteLine("Hi there");
            }
        }
        static void Main(string[] args)
        {
            Person p = new Person();
        }
    }
}
This can be useful in a number of situations. For example, when creating an object of type BankAccount, you could send an email notification to the owner.
The same functionality could be achieved using a separate public method. The advantage of the constructor is that it is called automatically.

Constructors


Constructors can be very useful for setting initial values for certain member variables.
A default constructor has no parameters. However, when needed, parameters can be added to a constructor. This makes it possible to assign an initial value to an object when it's created, as shown in the following example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person
        {
            private int age;
            private string name;
            public Person(string nm)
            {
                name = nm;
            }
            public string getName()
            {
                return name;
            }
        }
        static void Main(string[] args)
        {
            Person p = new Person("David");
            Console.WriteLine(p.getName());
        }
    }
}
Now, when the object is created, we can pass a parameter that will be assigned to the name variable.
Constructors can be overloaded like any method by using different numbers of parameters.

=============================
39.1 Properties
=============================

Properties


As we have seen in the previous lessons, it is a good practice to encapsulate members of a class and provide access to them only through public methods.
A property is a member that provides a flexible mechanism to read, write, or compute the value of a private field. Properties can be used as if they are public data members, but they actually include special methods called accessors.
The accessor of a property contains the executable statements that help in getting (reading or computing) or setting (writing) a corresponding field. Accessor declarations can include a get accessor, a set accessor, or both.
For example:
class Person
{
  private string name; //field

  public string Name //property
  {
    get { return name; }
    set { name = value; }
  }
}
CS
The Person class has a Name property that has both the set and the get accessors.
The set accessor is used to assign a value to the name variable; get is used to return its value.
value is a special keyword, which represents the value we assign to a property using the set accessor.
The name of the property can be anything you want, but coding conventions dictate properties have the same name as the private field with a capital letter.

Properties

Once the property is defined, we can use it to assign and read the private member:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person
        {
            private string name;
            public string Name
            {
                get { return name; }
                set { name = value; }
            }
        }
        static void Main(string[] args)
        {
            Person p = new Person();
            p.Name = "Bob";
            Console.WriteLine(p.Name);
        }
    }
}
The property is accessed by its name, just like any other public member of the class.

=============================
=============================
Arrays and Strings
=============================
=============================

=============================
42.1 Arrays
=============================

C# provides numerous built-in classes to store and manipulate data.
One example of such a class is the Array class.
An array is a data structure that is used to store a collection of data. You can think of it as a collection of variables of the same type.
For example, consider a situation where you need to store 100 numbers. Rather than declare 100 different variables, you can just declare an array that stores 100 elements.
To declare an array, specify its element types with square brackets:
int[ ] myArray;
CS
This statement declares an array of integers.
Since arrays are objects, we need to instantiate them with the new keyword:
int[ ] myArray = new int[5]; 
CS
This instantiates an array named myArray that holds 5 integers.
Note the square brackets used to define the number of elements the array should hold.

Arrays

After creating the array, you can assign values to individual elements by using the index number:
int[ ] myArray = new int[5];
myArray[0] = 23;
CS
This will assign the value 23 to the first element of the array.
Arrays in C# are zero-indexed meaning the first member has index 0, the second has index 1, and so on.

Arrays


We can provide initial values to the array when it is declared by using curly brackets:
string[ ] names = new string[3] {"John", "Mary", "Jessica"};
double[ ] prices = new double[4] {3.6, 9.8, 6.4, 5.9};
CS
We can omit the size declaration when the number of elements are provided in the curly braces:
string[ ] names = new string[ ] {"John", "Mary", "Jessica"};
double[ ] prices = new double[ ] {3.6, 9.8, 6.4, 5.9};
CS
We can even omit the new operator. The following statements are identical to the ones above:
string[ ] names = {"John", "Mary", "Jessica"};
double[ ] prices = {3.6, 9.8, 6.4, 5.9};
CS
Array values should be provided in a comma separated list enclosed in {curly braces}.

Arrays


As mentioned, each element of an array has an index number.
For example, consider the following array:
int[ ] b = {11, 45, 62, 70, 88};
	11	45	62	70	88
	[0]	[1]	[2]	[3]	[4]
CS
The elements of b have the following indexes:contentImageTo access individual array elements, place the element's index number in square brackets following the array name.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] b = {11, 45, 62, 70, 88};

            Console.WriteLine(b[2]);
            Console.WriteLine(b[3]);
        }
    }
}
Remember that the first element has index 0.

=============================
43.1 Using Arrays in Loops
=============================

Arrays & Loops


It's occasionally necessary to iterate through the elements of an array, making element assignments based on certain calculations. This can be easily done using loops.
For example, you can declare an array of 10 integers and assign each element an even value with the following loop:
int[ ] a = new int[10];
for (int k = 0; k < 10; k++) {
  a[k] = k*2;
}
CS
We can also use a loop to read the values of an array.
For example, we can display the contents of the array we just created:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] a = new int[10];
            for (int k = 0; k < 10; k++) {
                a[k] = k*2;
            }
            for (int k = 0; k < 10; k++) {
                Console.WriteLine(a[k]);
            }
        }
    }
}
This will display the values of the elements of the array.
The variable k is used to access each array element.
The last index in the array is 9, so the for loop condition is k<10.

The foreach Loop


The foreach loop provides a shorter and easier way of accessing array elements.
The previous example of accessing the elements could be written using a foreach loop:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] a = new int[10];
            for (int k = 0; k < 10; k++) {
                a[k] = k*2;
            }
            foreach (int k in a) {
                Console.WriteLine(k);
            }
        }
    }
}
The foreach loop iterates through the array a and assigns the value of the current element to the variable k at each iteration of the loop. So, at the first iteration, k=a[0], at the second, k=a[1], etc.
The data type of the variable in the foreach loop should match the type of the array elements.
Often the keyword var is used as the type of the variable, as in: foreach (var k in a). The compiler determines the appropriate type for var.

Arrays


The following code uses a foreach loop to calculate the sum of all the elements of an array:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] arr = {11, 35, 62, 555, 989};
            int sum = 0; 
            
            foreach (int x in arr) {
                sum += x;
            }
            Console.WriteLine(sum);
        }
    }
}
To review, we declared an array and a variable sum that will hold the sum of the elements.
Next, we utilized a foreach loop to iterate through each element of the array, adding the corresponding element's value to the sum variable.
The Array class provides some useful methods that will be discussed in the coming lessons.

=============================
44.1 Multidimensional Arrays
=============================


An array can have multiple dimensions. A multidimensional array is declared as follows:
type[, , … ,] arrayName = new type[size1, size2, …, sizeN];
CS
For example, let's define a two-dimensional 3x4 integer array:
int[ , ] x = new int[3,4];
CS
Visualize this array as a table composed of 3 rows and 4 columns:
	Column1		Column2	Column3	Column4
Row1	x[0][0]		x[0][1]		x[0][2]		x[0][3]
Row2	x[1][0]		x[1][1]		x[1][2]		x[1][3]
Row3	x[2][0]		x[2][1]		x[2][2]		x[2][3]
Array indexing starts from 0.

Multidimensional Arrays


We can initialize multidimensional arrays in the same way as single-dimensional arrays.
For example:
int[ , ] someNums = { {2, 3}, {5, 6}, {4, 6} }; 
CS
This will create an array with three rows and two columns. Nested curly brackets are used to define values for each row.
To access an element of the array, provide both indexes. For example someNums[2, 0] will return the value 4, as it accesses the first column of the third row.
Let's create a program that will display the values of the array in the form of a table.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ , ] someNums = { {2, 3}, {5, 6}, {4, 6} }; 
            for (int k = 0; k < 3; k++) {
                for (int j = 0; j < 2; j++) {
                    Console.Write(someNums[k, j]+" ");
                }
                Console.WriteLine();
            }
        }
    }
}
We have used two nested for loops, one to iterate through the rows and one through the columns.
The Console.WriteLine(); statement moves the output to a new line after one row is printed.
Arrays can have any number of dimensions, but keep in mind that arrays with more than three dimensions are harder to manage.

=============================
45.1 Jagged Arrays
=============================
Jagged Arrays


A jagged array is an array whose elements are arrays. So it is basically an array of arrays.
The following is a declaration of a single-dimensional array that has three elements, each of which is a single-dimensional array of integers:
int[ ][ ] jaggedArr = new int[3][ ];
CS
Each dimension is an array, so you can also initialize the array upon declaration like this:
int[ ][ ] jaggedArr = new int[ ][ ] 
{
  new int[ ] {1,8,2,7,9},
  new int[ ] {2,4,6},
  new int[ ] {33,42}
};
CS
You can access individual array elements as shown in the example below:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ][ ] jaggedArr = new int[ ][ ] 
            {
                new int[ ] {1,8,2,7,9},
                new int[ ] {2,4,6},
                new int[ ] {33,42}
            };
            int x = jaggedArr[2][1];
            Console.WriteLine(x);
        }
    }
}
This accesses the second element of the third array.
A jagged array is an array-of-arrays, so an int[ ][ ] is an array of int[ ], each of which can be of different lengths and occupy their own block in memory.
A multidimensional array (int[,]) is a single block of memory (essentially a matrix). It always has the same amount of columns for every row.

=============================
46.1 Array Properties & Methods
=============================

Arrays Properties


The Array class in C# provides various properties and methods to work with arrays.
For example, the Length and Rank properties return the number of elements and the number of dimensions of the array, respectively. You can access them using the dot syntax, just like any class members:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] arr = {2, 4, 7};
            
            Console.WriteLine(arr.Length); 
            
            Console.WriteLine(arr.Rank); 
        }
    }
}
The Length property can be useful in for loops where you need to specify the number of times the loop should run.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] arr = {2, 4, 7};
            for(int k=0; k<arr.Length; k++) {
                Console.WriteLine(arr[k]);
            }
        }
    }
}

Array Methods


There are a number of methods available for arrays.
Max returns the largest value.
Min returns the smallest value.
Sum returns the sum of all elements.

For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] arr = { 2, 4, 7, 1};
            Console.WriteLine(arr.Max());
            Console.WriteLine(arr.Min());
            Console.WriteLine(arr.Sum());
        }
    }
}
C# also provides a static Array class with additional methods. You will learn about those in the next module.

=============================
47.1 Working with Strings
=============================

Strings


It’s common to think of strings as arrays of characters. In reality, strings in C# are objects.
When you declare a string variable, you basically instantiate an object of type String.
String objects support a number of useful properties and methods:
Length returns the length of the string.
IndexOf(value) returns the index of the first occurrence of the value within the string.
Insert(index, value) inserts the value into the string starting from the specified index.
Remove(index) removes all characters in the string from the specified index.
Replace(oldValue, newValue) replaces the specified value in the string.
Substring(index, length) returns a substring of the specified length, starting from the specified index. If length is not specified, the operation continues to the end of the string.
Contains(value) returns true if the string contains the specified value.

The examples below demonstrate each of the String members:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string a = "some text";
            Console.WriteLine(a.Length);
            //Outputs 9

            Console.WriteLine(a.IndexOf('t'));
            //Outputs 5

             a = a.Insert(0, "This is ");
            Console.WriteLine(a);
            //Outputs "This is some text"

            a = a.Replace("This is", "I am");
            Console.WriteLine(a);
            //Outputs "I am some text"

            if(a.Contains("some"))
                Console.WriteLine("found");
            //Outputs "found"

            a = a.Remove(4);
            Console.WriteLine(a);
            //Outputs "I am"

            a = a.Substring(2);
            Console.WriteLine(a);
            //Outputs "am"
        }
    }
}
You can also access characters of a string by its index, just like accessing elements of an array:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string a = "some text";
            Console.WriteLine(a[2]);
        }
    }
}
Indexes in strings are similar to arrays, they start from 0.

Working with Strings


Let's create a program that will take a string, replace all occurrences of the word "dog" with "cat" and output the first sentence only.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string text = "This is some text about a dog. The word dog appears in this text a number of times. This is the end.";
            text = text.Replace("dog", "cat");
            text = text.Substring(0, text.IndexOf(".")+1);
            
            Console.WriteLine(text);
        }
    }
}
The code above replaces all occurrences of "dog" with "cat". After that it takes a substring of the original string starting from the first index until the first occurrence of a period character.
We add one to the index of the period to include the period in the substring.
C# provides a solid collection of tools and methods to work and manipulate strings. You could, for example, find the number of times a specific word appears in a book with ease, using those methods.

=============================
=============================
More on Classes
=============================
=============================

=============================
50.1 Destructors
=============================

Destructors


As constructors are used when a class is instantiated, destructors are automatically invoked when an object is destroyed or deleted.
Destructors have the following attributes:
- A class can only have one destructor.
- Destructors cannot be called. They are invoked automatically.
- A destructor does not take modifiers or have parameters.
- The name of a destructor is exactly the same as the class prefixed with a tilde (~).
For Example:
class Dog
{
  ~Dog() 
  {
    // code statements
  }
}
CS
Destructors can be very useful for releasing resources before coming out of the program. This can include closing files, releasing memory, and so on.

Destructors


Let’s include WriteLine statements in the destructor and constructor of our class and see how the program behaves when an object of that class is created and when the program ends:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Dog
        {
            public Dog() {
                Console.WriteLine("Constructor");
            }
            ~Dog() {
                Console.WriteLine("Destructor");
            }
        }
        static void Main(string[] args)
        {
            Dog d = new Dog();
        }
    }
}
When the program runs, it first creates the object, which calls the constructor. The object is deleted at the end of the program and the destructor is invoked when the program's execution is complete.
This can be useful, for example, if your class is working with storage or files. The constructor would initialize and open the files. Then, when the program ends, the destructor would close the files.

=============================
51.1 Static Members
=============================

Static


Now it's time to discuss the static keyword.
You first noticed it in the Main method's declaration:
static void Main(string[] args)
CS
Class members (variables, properties, methods) can also be declared as static. This makes those members belong to the class itself, instead of belonging to individual objects. No matter how many objects of the class are created, there is only one copy of the static member.
For example:
class Cat {
  public static int count=0;
  public Cat() {
    count++;
  }
}
CS
In this case, we declared a public member variable count, which is static. The constructor of the class increments the count variable by one.
No matter how many Cat objects are instantiated, there is always only one count variable that belongs to the Cat class because it was declared static.

Static


Because of their global nature, static members can be accessed directly using the class name without an object.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Cat {
            public static int count=0;
            public Cat() {
                count++;
            }
        }
        static void Main(string[] args)
        {
            Cat c1 = new Cat();
            Cat c2 = new Cat();
            Console.WriteLine(Cat.count);
        }
    }
}
As you can see, we can access the static variable using the class name: Cat.count.
The count variable is shared between all Cat objects. For this class, each time an object is created, the static value is incremented. The program above demonstrates this when 2 is displayed after creating two objects of that class.
You must access static members using the class name. If you try to access them via an object of that class, you will generate an error.

Static Methods


The same concept applies to static methods.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Dog
        {
            public static void Bark() {
                Console.WriteLine("Woof");
            }
        }
        static void Main(string[] args)
        {
            Dog.Bark();
        }
    }
}
Static methods can access only static members.
The Main method is static, as it is the starting point of any program. Therefore any method called directly from Main had to be static.

Static


Constant members are static by definition.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class MathClass {
            public const int ONE = 1;
        }
        static void Main(string[] args)
        {
            Console.Write(MathClass.ONE);
        }
    }
}
As you can see, we access the property ONE using the name of the class, just like a static member. This is because all const members are static by default.

Static Constructors

Constructors can be declared static to initialize static members of the class.
The static constructor is automatically called once when we access a static member of the class.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class SomeClass {
            public static int X { get; set; }
            public static int Y { get; set; }
            
            static SomeClass() {
                X = 10;
                Y = 20;
            }
        }
        static void Main(string[] args)
        {
            Console.WriteLine(SomeClass.X);
        }
    }
}
The constructor will get called once when we try to access SomeClass.X or SomeClass.Y.

=============================
52.1 Static Classes
=============================

Static Classes


An entire class can be declared as static.
A static class can contain only static members.
You cannot instantiate an object of a static class, as only one instance of the static class can exist in a program.
Static classes are useful for combining logical properties and methods. A good example of this is the Math class.
It contains various useful properties and methods for mathematical operations.
For example, the Pow method raises a number to a power:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(Math.Pow(2, 3));
        }
    }
}
You access all members of the Math class using the class name, without declaring an object.
Tap next to learn about the available methods of the Math class.

Static Classes


There are a number of useful static methods and properties available in C#:

Math

Math.PI the constant PI.
Math.E represents the natural logarithmic base e.
Math.Max() returns the larger of its two arguments.
Math.Min() returns the smaller of its two arguments.
Math.Abs() returns the absolute value of its argument.
Math.Sin() returns the sine of the specified angle.
Math.Cos() returns the cosine of the specified angle.
Math.Pow() returns a specified number raised to the specified power.
Math.Round() rounds the decimal number to its nearest integral value.
Math.Sqrt() returns the square root of a specified number.

Array

The Array class includes some static methods for manipulating arrays:
int[] arr = {1, 2, 3, 4};

Array.Reverse(arr);
//arr = {4, 3, 2, 1}

Array.Sort(arr);
//arr = {1, 2, 3, 4}
CS
String
string s1 = "some text";
string s2 = "another text";

String.Concat(s1, s2); // combines the two strings

String.Equals(s1, s2); // returns false
CS
DateTime

The DateTime structure allows you to work with dates.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(DateTime.Now);
            Console.WriteLine(DateTime.Today);
            
            Console.WriteLine(DateTime.DaysInMonth(2016, 2));
        }
    }
}
The Console class is also an example of a static class. We use its static WriteLine() method to output to the screen, or the static ReadLine() method to get user input.
The Convert class used to convert value types is also a static class.

=============================
53.1 this & readonly
=============================

The this Keyword


The this keyword is used inside the class and refers to the current instance of the class, meaning it refers to the current object.
One of the common uses of this is to distinguish class members from other data, such as local or formal parameters of a method, as shown in the following example:
class Person {
  private string name;
  public Person(string name) {
    this.name = name;
  }
}
CS
Here, this.name represents the member of the class, whereas name represents the parameter of the constructor.
Another common use of this is for passing the current instance to a method as parameter: ShowPersonInfo(this);

The readonly Modifier


The readonly modifier prevents a member of a class from being modified after construction. It means that the field declared as readonly can be modified only when you declare it or from within a constructor.
For example:
class Person {
  private readonly string name = "John"; 
  public Person(string name) {
    this.name = name; 
  }
}
CS
If we try to modify the name field anywhere else, we will get an error.
There are three major differences between readonly and const fields.
First, a constant field must be initialized when it is declared, whereas a readonly field can be declared without initialization, as in:
readonly string name; // OK
const double PI; // Error
CS
Second, a readonly field value can be changed in a constructor, but a constant value cannot.
Third, the readonly field can be assigned a value that is a result of a calculation, but constants cannot, as in:
readonly double a = Math.Sin(60); // OK
const double b = Math.Sin(60); // Error! 
CS
The readonly modifier prevents a member of a class from being modified after construction.

=============================
54.1 Indexers
=============================

Indexers


An indexer allows objects to be indexed like an array.
As discussed earlier, a string variable is actually an object of the String class. Further, the String class is actually an array of Char objects. In this way, the string class implements an indexer so we can access any character (Char object) by its index:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string str = "Hello World";
            char x = str[4];
            Console.WriteLine(x);
        }
    }
}
Arrays use integer indexes, but indexers can use any type of index, such as strings, characters, etc.

Indexers


Declaration of an indexer is to some extent similar to a property. The difference is that indexer accessors require an index.
Like a property, you use get and set accessors for defining an indexer. However, where properties return or set a specific data member, indexers return or set a particular value from the object instance.
Indexers are defined with the this keyword.
For example:
class Clients {
  private string[] names = new string[10];

  public string this[int index] {
    get {
      return names[index];
    }
    set {
      names[index] = value;
    }
  }
}
CS
As you can see, the indexer definition includes the this keyword and an index, which is used to get and set the appropriate value.
Now, when we declare an object of class Clients, we use an index to refer to specific objects like the elements of an array:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Clients {
            private string[] names = new string[10];
            public string this[int index] {
                get {
                    return names[index];
                }
                set {
                    names[index] = value;
                }
            }
        }
        static void Main(string[] args)
        {
            Clients c = new Clients();
            c[0] = "Dave";
            c[1] = "Bob";
            
            Console.WriteLine(c[1]);
        }
    }
}
You typically use an indexer if the class represents a list, collection, or array of objects.

=============================
55.1 Operator Overloading
=============================

Operator Overloading


Most operators in C# can be overloaded, meaning they can be redefined for custom actions.
For example, you can redefine the action of the plus (+) operator in a custom class.
Consider the Box class that has Height and Width properties:
class Box {
  public int Height {get; set;}
  public int Width {get; set;}
  public Box(int h, int w) {
    Height = h;
    Width = w;
  }
}
static void Main(string[] args) {
  Box b1 = new Box(14, 3);
  Box b2 = new Box(5, 7);
}
CS
We would like to add these two Box objects, which would result in a new, bigger Box.
So, basically, we would like the following code to work:
 Box b3 = b1 + b2;
CS
The Height and Width properties of object b3 should be equal to the sum of the corresponding properties of the b1 and b2 objects.
This is achieved through operator overloading. Tap next to learn more!

Operator Overloading


Overloaded operators are methods with special names, where the keyword operator is followed by the symbol for the operator being defined.
Similar to any other method, an overloaded operator has a return type and a parameter list.
For example, for our Box class, we overload the + operator:
public static Box operator+ (Box a, Box b) {
  int h = a.Height + b.Height;
  int w = a.Width + b.Width;
  Box res = new Box(h, w);
  return res;
}
CS
The method above defines an overloaded operator + with two Box object parameters and returning a new Box object whose Height and Width properties equal the sum of its parameter's corresponding properties.
Additionally, the overloaded operator must be static.
Putting it all together:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Box {
            public int Height { get; set; }
            public int Width { get; set; }
            public Box(int h, int w) {
                Height = h;
                Width = w;
            }
            public static Box operator+(Box a, Box b) {
                int h = a.Height + b.Height;
                int w = a.Width + b.Width;
                Box res = new Box(h, w);
                return res;
            }
        }
        static void Main(string[] args)
        {
            Box b1 = new Box(14, 3);
            Box b2 = new Box(5, 7);
            Box b3 = b1 + b2;
            
            Console.WriteLine(b3.Height);
            Console.WriteLine(b3.Width);
        }
    }
}
All arithmetic and comparison operators can be overloaded. For instance, you could define greater than and less than operators for the boxes that would compare the Boxes and return a boolean result. Just keep in mind that when overloading the greater than operator, the less than operator should also be defined.

=============================
=============================
Inheritance & Polymorphism
=============================
=============================

=============================
58.1 Inheritance
=============================

Inheritance allows us to define a class based on another class. This makes creating and maintaining an application easy.
The class whose properties are inherited by another class is called the Base class. The class which inherits the properties is called the Derived class.
For example, base class Animal can be used to derive Cat and Dog classes.
The derived class inherits all the features from the base class, and can have its own additional features.contentImage
Base Class::		Derived Class::
|| Base class		Base class features
|| features		================
			Derived class features
Inheritance allows us to define a class based on another class.

Inheritance


Let's define our base class Animal:
class Animal {
  public int Legs {get; set;}
  public int Age {get; set;}
}
CS
Now we can derive class Dog from it:
class Dog : Animal {
  public Dog() {
    Legs = 4;
  }
  public void Bark() {
    Console.Write("Woof");
  }
}
CS
Note the syntax for a derived class. A colon and the name of the base class follow the name of the derived class.
All public members of Animal become public members of Dog. That is why we can access the Legs member in the Dog constructor.
Now we can instantiate an object of type Dog and access the inherited members as well as call its own Bark method.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Animal {
            public int Legs {get; set;}
            public int Age {get; set;}
        }
        class Dog : Animal {
            public Dog() {
                Legs = 4;
            }
            public void Bark() {
                Console.Write("Woof");
            }
        }
        static void Main(string[] args)
        {
            Dog d = new Dog();
            Console.WriteLine(d.Legs);
            
            d.Bark();
        }
    }
}
A base class can have multiple derived classes. For example, a Cat class can inherit from Animal.
Inheritance allows the derived class to reuse the code in the base class without having to rewrite it. And the derived class can be customized by adding more members. In this manner, the derived class extends the functionality of the base class.

Inheritance


A derived class inherits all the members of the base class, including its methods.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person {
            public void Speak() {
                Console.WriteLine("Hi there");
            }
        }
        class Student : Person {
            int number;
        }
        static void Main(string[] args)
        {
            Student s = new Student();
            s.Speak();
        }
    }
}
We created a Student object and called the Speak method, which was declared in the base class Person.
C# does not support multiple inheritance, so you cannot inherit from multiple classes.
However, you can use interfaces to implement multiple inheritance. You will learn more about interfaces in the coming lessons.

=============================
59.1 Protected Members
=============================

protected


Up to this point, we have worked exclusively with public and private access modifiers.
Public members may be accessed from anywhere outside of the class, while access to private members is limited to their class.
The protected access modifier is very similar to private with one difference; it can be accessed in the derived classes. So, a protected member is accessible only from derived classes.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person {
            protected int Age {get; set;}
            protected string Name {get; set;}
        }
        class Student : Person {
            public Student(string nm) {
                Name = nm;
            }
            public void Speak() {
                Console.Write("Name: "+Name);
            }
        }
        static void Main(string[] args)
        {
            Student s = new Student("David");
            s.Speak();
        }
    }
}
As you can see, we can access and modify the Name property of the base class from the derived class.
But, if we try to access it from outside code, we will get an error:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person {
            protected int Age {get; set;}
            protected string Name {get; set;}
        }
        class Student : Person {
            public Student(string nm) {
                Name = nm;
            }
            public void Speak() {
                Console.Write("Name: "+Name);
            }
        }
        static void Main(string[] args)
        {
            Student s = new Student("David");
            s.Name = "Bob"; 
        }
    }
}

sealed


A class can prevent other classes from inheriting it, or any of its members, by using the sealed modifier.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        sealed class Animal {
            //some code
        }
        class Dog : Animal { } //Error
        
        static void Main(string[] args)
        {
            
        }
    }
}
In this case, we cannot derive the Dog class from the Animal class because Animal is sealed.
The sealed keyword provides a level of protection to your class so that other classes cannot inherit from it.

=============================
60.1 Derived Class Constructor & Destructor
=============================

Inheritance


Constructors are called when objects of a class are created. With inheritance, the base class constructor and destructor are not inherited, so you should define constructors for the derived classes.
However, the base class constructor and destructor are being invoked automatically when an object of the derived class is created or deleted.
Consider the following example:
class Animal {
  public Animal() {
    Console.WriteLine("Animal created");
  }
  ~Animal() {
    Console.WriteLine("Animal deleted");
  }
}
class Dog: Animal {
  public Dog() {
    Console.WriteLine("Dog created");
  }
  ~Dog() {
    Console.WriteLine("Dog deleted");
  }
}
CS
We have defined the Animal class with a constructor and destructor and a derived Dog class with its own constructor and destructor.
So what will happen when we create an object of the derived class? Tap next to find out!

Inheritance


Let's create a Dog object:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Animal {
            public Animal() {
                Console.WriteLine("Animal created");
            }
            ~Animal() {
                Console.WriteLine("Animal deleted");
            }
        }
        class Dog: Animal {
            public Dog() {
                Console.WriteLine("Dog created");
            }
            ~Dog() {
                Console.WriteLine("Dog deleted");
            }
        }
        static void Main(string[] args)
        {
            Dog d = new Dog();
        }
    }
}
Note that the base class constructor is called first and the derived class constructor is called next.
When the object is destroyed, the derived class destructor is invoked and then the base class destructor is invoked.
You can think of it as the following: The derived class needs its base class in order to work, which is why the base class constructor is called first.

=============================
61.1 Polymorphism
=============================

Polymorphism


The word polymorphism means "having many forms".
Typically, polymorphism occurs when there is a hierarchy of classes and they are related through inheritance from a common base class.
Polymorphism means that a call to a member method will cause a different implementation to be executed depending on the type of object that invokes the method.
Simply, polymorphism means that a single method can have a number of different implementations.

Polymorphism


Consider having a program that allows users to draw different shapes. Each shape is drawn differently, and you do not know which shape the user will choose.
Here, polymorphism can be leveraged to invoke the appropriate Draw method of any derived class by overriding the same method in the base class. Such methods must be declared using the virtual keyword in the base class.
For example:
class Shape {
  public virtual void Draw() {
    Console.Write("Base Draw");
  }
}
CS
The virtual keyword allows methods to be overridden in derived classes.
Virtual methods enable you to work with groups of related objects in a uniform way.

Polymorphism


Now, we can derive different shape classes that define their own Draw methods using the override keyword:
class Circle : Shape {
  public override void Draw() {
    // draw a circle...
    Console.WriteLine("Circle Draw");
  }
}
class Rectangle : Shape {
  public override void Draw() {
    // draw a rectangle...
    Console.WriteLine("Rect Draw");
  }
}
CS
The virtual Draw method in the Shape base class can be overridden in the derived classes. In this case, Circle and Rectangle have their own Draw methods.
Now, we can create separate Shape objects for each derived type and then call their Draw methods:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Shape {
            public virtual void Draw() {
                Console.Write("Base Draw");
            }
        }
        class Circle : Shape {
            public override void Draw() {
                // draw a circle...
                Console.WriteLine("Circle Draw");
            }
        }
        class Rectangle : Shape {
            public override void Draw() {
                // draw a rectangle...
                Console.WriteLine("Rect Draw");
            }
        }
        static void Main(string[] args)
        {
            Shape c = new Circle();
            c.Draw();

            Shape r = new Rectangle();
            r.Draw();
        }
    }
}
As you can see, each object invoked its own Draw method, thanks to polymorphism.

Polymorphism


To summarize, polymorphism is a way to call the same method for different objects and generate different results based on the object type. This behavior is achieved through virtual methods in the base class.
To implement this, we create objects of the base type, but instantiate them as the derived type:
Shape c = new Circle();
CS
Shape is the base class. Circle is the derived class.
So why use polymorphism? We could just instantiate each object of its type and call its method, as in:
Circle c = new Circle();
c.Draw();
CS
The polymorphic approach allows us to treat each object the same way. As all objects are of type Shape, it is easier to maintain and work with them. You could, for example, have a list (or array) of objects of that type and work with them dynamically, without knowing the actual derived type of each object.
Polymorphism can be useful in many cases. For example, we could create a game where we would have different Player types with each Player having a separate behavior for the Attack method.
In this case, Attack would be a virtual method of the base class Player and each derived class would override it.

=============================
62.1 Abstract Classes
=============================
Abstract Classes


As described in the previous example, polymorphism is used when you have different derived classes with the same method, which has different implementations in each class. This behavior is achieved through virtual methods that are overridden in the derived classes.
In some situations there is no meaningful need for the virtual method to have a separate definition in the base class.
These methods are defined using the abstract keyword and specify that the derived classes must define that method on their own.
You cannot create objects of a class containing an abstract method, which is why the class itself should be abstract.
We could use an abstract method in the Shape class:
abstract class Shape {
   public abstract void Draw();
}
CS
As you can see, the Draw method is abstract and thus has no body. You do not even need the curly brackets; just end the statement with a semicolon.
The Shape class itself must be declared abstract because it contains an abstract method. Abstract method declarations are only permitted in abstract classes.
Remember, abstract method declarations are only permitted in abstract classes. Members marked as abstract, or included in an abstract class, must be implemented by classes that derive from the abstract class. An abstract class can have multiple abstract members.

Abstract Classes


An abstract class is intended to be a base class of other classes. It acts like a template for its derived classes.
Now, having the abstract class, we can derive the other classes and define their own Draw() methods:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        abstract class Shape {
            public abstract void Draw();
        }
        class Circle : Shape {
            public override void Draw() {
                Console.WriteLine("Circle Draw");
            }
        }
        class Rectangle : Shape {
            public override void Draw() {
                Console.WriteLine("Rect Draw");
            }
        }
        static void Main(string[] args)
        {
            Shape c = new Circle();
            c.Draw();
        }
    }
}
Abstract classes have the following features:
- An abstract class cannot be instantiated.
- An abstract class may contain abstract methods and accessors.
- A non-abstract class derived from an abstract class must include actual implementations of all inherited abstract methods and accessors.
It is not possible to modify an abstract class with the sealed modifier because the two modifiers have opposite meanings. The sealed modifier prevents a class from being inherited and the abstract modifier requires a class to be inherited.

=============================
63.1 Interfaces
=============================

An interface is a completely abstract class, which contains only abstract members.
It is declared using the interface keyword:
public interface IShape
{
  void Draw();
}
CS
All members of the interface are by default abstract, so no need to use the abstract keyword.

Interfaces can have public (by default), private and protected members.
It is common to use the capital letter I as the starting letter for an interface name.
Interfaces can contain properties, methods, etc. but cannot contain fields (variables).

Interfaces


When a class implements an interface, it must also implement, or define, all of its methods.
The term implementing an interface is used (opposed to the term "inheriting from") to describe the process of creating a class based on an interface. The interface simply describes what a class should do. The class implementing the interface must define how to accomplish the behaviors.
The syntax to implement an interface is the same as that to derive a class:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        public interface IShape {
            void Draw();
        }
        class Circle : IShape {
            public void Draw() {
                Console.WriteLine("Circle Draw");
            }
        }
        static void Main(string[] args)
        {
            IShape c = new Circle();
            c.Draw();
        }
    }
}
Note, that the override keyword is not needed when you implement an interface.
But why use interfaces rather than abstract classes?
A class can inherit from just one base class, but it can implement multiple interfaces!
Therefore, by using interfaces you can include behavior from multiple sources in a class.
To implement multiple interfaces, use a comma separated list of interfaces when creating the class: class A: IShape, IAnimal, etc.

Default Implementation


Default implementation in interfaces allows to write an implementation of any method. This is useful when there is a need to provide a single implementation for common functionality.

Let's suppose we need to add new common functionality to our already existing interface, which is implemented by many classes. Without default implementation (before C# 8), this operation would create errors, because the method we have added isn't implemented in the classes, and we would need to implement the same operation one by one in each class. Default implementation in interface solves this problem.

For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        public interface IShape {
            void Draw();
            void Finish(){
                Console.WriteLine("Done!");
            }
        }
        class Circle : IShape {
            public void Draw() {
                Console.WriteLine("Circle Draw");
            }
        }
        static void Main(string[] args)
        {
            IShape c = new Circle();
            c.Draw();
            c.Finish();
        }
    }
}
We added the Finish() method with default implementation to our IShape interface and called it without implementing it inside the Circle class.
Methods with default implementation can be freely overridden inside the class which implements that interface.

=============================
64.1 Nested Classes
=============================

C# supports nested classes: a class that is a member of another class.
For example:
class Car {
  string name;
  public Car(string nm) {
    name = nm;
    Motor m = new Motor();
  }
  public class Motor {
    // some code
  }
}
CS
The Motor class is nested in the Car class and can be used similar to other members of the class.
A nested class acts as a member of the class, so it can have the same access modifiers as other members (public, private, protected).
Just as in real life, objects can contain other objects. For example, a car, which has its own attributes (color, brand, etc.) contains a motor, which as a separate object, has its own attributes (volume, horsepower, etc.). Here, the Car class can have a nested Motor class as one of its members.

=============================
65.1 Namespaces
=============================
Namespaces

When you create a blank project, it has the following structure:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn {
  class Program {
    static void Main(string[] args) {
    }
  }
}
CS
Note, that our whole program is inside a namespace. So, what are namespaces?
Namespaces declare a scope that contains a set of related objects. You can use a namespace to organize code elements. You can define your own namespaces and use them in your program.
The using keyword states that the program is using a given namespace.
For example, we are using the System namespace in our programs, which is where the class Console is defined:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hi");
        }
    }
}
Without the using statement, we would have to specify the namespace wherever it is used:
namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            System.Console.WriteLine("Hi");
        }
    }
}
The .NET Framework uses namespaces to organize its many classes. System is one example of a .NET Framework namespace.
Declaring your own namespaces can help you group your class and method names in larger programming projects.

=============================
=============================
Structs, Enums, Exceptions & Files
=============================
=============================

=============================
68.1 Structs
=============================
Structs

A struct type is a value type that is typically used to encapsulate small groups of related variables, such as the coordinates of a rectangle or the characteristics of an item in an inventory. The following example shows a simple struct declaration:
struct Book {
  public string title;  
  public double price;
  public string author;
}
CS
Structs share most of the same syntax as classes, but are more limited than classes.
Unlike classes, structs can be instantiated without using a new operator.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        struct Book {
            public string title;  
            public double price;
            public string author;
        }
        static void Main(string[] args)
        {
            Book b;
            b.title = "Test";
            b.price = 5.99;
            b.author = "David";
            
            Console.WriteLine(b.title);
        }
    }
}
Structs do not support inheritance and cannot contain virtual methods.

=============================
69.1 Enums
=============================
Enums

The enum keyword is used to declare an enumeration: a type that consists of a set of named constants called the enumerator list.
By default, the first enumerator has the value 0, and the value of each successive enumerator is increased by 1.
For example, in the following enumeration, Sun is 0, Mon is 1, Tue is 2, and so on:
enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat}; 
CS
You can also assign your own enumerator values:
enum Days {Sun, Mon, Tue=4, Wed, Thu, Fri, Sat}; 
CS
In the example above, the enumeration will start from 0, then Mon is 1, Tue is 4, Wed is 5, and so on. The value of the next item in an Enum is one increment of the previous value.
Note that the values are comma separated.
You can refer to the values in the Enum with the dot syntax.
In order to assign Enum values to int variables, you have to specify the type in parentheses:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat }; 
        static void Main(string[] args)
        {
            int x = (int)Days.Tue;
            Console.WriteLine(x);
        }
    }
}
Basically, Enums define variables that represent members of a fixed set.
Some sample Enum uses include month names, days of the week, cards in a deck, etc.

Enums


Enums are often used with switch statements.
For example:
 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        enum TrafficLights { Green, Red, Yellow };
        static void Main(string[] args)
        {
            TrafficLights x = TrafficLights.Red;
            switch (x) {
                case TrafficLights.Green:
                    Console.WriteLine("Go!");
                    break;
                case TrafficLights.Red:
                    Console.WriteLine("Stop!");
                    break;
                case TrafficLights.Yellow:
                    Console.WriteLine("Caution!");
                    break;
            }
        }
    }
}

=============================
70.1 Exception Handling
=============================

An exception is a problem that occurs during program execution. Exceptions cause abnormal termination of the program.
An exception can occur for many different reasons. Some examples:
- A user has entered invalid data.
- A file that needs to be opened cannot be found.
- A network connection has been lost in the middle of communications.
- Insufficient memory and other issues related to physical resources.

For example, the following code will produce an exception when run because we request an index which does not exist:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] arr = new int[] { 4, 5, 8 };
            Console.Write(arr[8]);
        }
    }
}
As you can see, exceptions are caused by user error, programmer error, or physical resource issues. However, a well-written program should handle all possible exceptions.

Handling Exceptions


C# provides a flexible mechanism called the try-catch statement to handle exceptions so that a program won't crash when an error occurs.
The try and catch blocks are used similar to:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            try {
                int[] arr = new int[] { 4, 5, 8 };
                Console.Write(arr[8]);
            }
            catch(Exception e) {
                Console.WriteLine("An error occurred");
            }
        }
    }
}
The code that might generate an exception is placed in the try block. If an exception occurs, the catch blocks is executed without stopping the program.
The type of exception you want to catch appears in parentheses following the keyword catch.
We use the general Exception type to handle all kinds of exceptions. We can also use the exception object e to access the exception details, such as the original error message (e.Message):
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            try {
                int[] arr = new int[] { 4, 5, 8 };
                Console.Write(arr[8]);
            }
            catch(Exception e) {
                Console.WriteLine(e.Message);
            }
        }
    }
}
You can also catch and handle different exceptions separately. Tap next to learn more!

Handling Multiple Exceptions


A single try block can contain multiple catch blocks that handle different exceptions separately.
Exception handling is particularly useful when dealing with user input.
For example, for a program that requests user input of two numbers and then outputs their quotient, be sure that you handle division by zero, in case your user enters 0 as the second number.
int x, y;
try {
  x = Convert.ToInt32(Console.Read());
  y = Convert.ToInt32(Console.Read());
  Console.WriteLine(x / y);
}
catch (DivideByZeroException e) {
  Console.WriteLine("Cannot divide by 0");
}
catch(Exception e) {
  Console.WriteLine("An error occurred");
}
CS
The above code handles the DivideByZeroException separately. The last catch handles all the other exceptions that might occur. If multiple exceptions are handled, the Exception type must be defined last.
Now, if the user enters 0 for the second number, "Cannot divide by 0" will be displayed.
If, for example, the user enters non-integer values, "An error occurred" will be displayed.
The following exception types are some of the most commonly used: FileNotFoundException, FormatException, IndexOutOfRangeException, InvalidOperationException, OutOfMemoryException.

finally


An optional finally block can be used after the catch blocks. The finally block is used to execute a given set of statements, whether an exception is thrown or not.
For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int result=0;
            int num1 = 8;
            int num2 = 4;
            try {
                result = num1 / num2;
            }
            catch (DivideByZeroException e) {
                Console.WriteLine("Error");
            }
            finally {
                Console.WriteLine(result);
            }
        }
    }
}
The finally block can be used, for example, when you work with files or other resources. These should be closed or released in the finally block, whether an exception is raised or not.

=============================
71.1 Working with Files
=============================

Writing to Files


The System.IO namespace has various classes that are used for performing numerous operations with files, such as creating and deleting files, reading from or writing to a file, closing a file, and more.
The File class is one of them.
For example:
string str = "Some text";
File.WriteAllText("test.txt", str);
CS
The WriteAllText() method creates a file with the specified path and writes the content to it. If the file already exists, it is overwritten.
The code above creates a file test.txt and writes the contents of the str string into it.
To use the File class you need to use the System.IO namespace: using System.IO;

Reading from Files


You can read the content of a file using the ReadAllText method of the File class:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string str = "Some text";
            File.WriteAllText("test.txt", str);
            
            string txt = File.ReadAllText("test.txt");
            Console.WriteLine(txt); 
        }
    }
}
This will output the content of the test.txt file.
The following methods are available in the File class:
AppendAllText() - appends text to the end of the file.
Create() - creates a file in the specified location.
Delete() - deletes the specified file.
Exists() - determines whether the specified file exists.
Copy() - copies a file to a new location.
Move() - moves a specified file to a new location
All methods automatically close the file after performing the operation.

=============================
=============================
Generics
=============================
=============================

=============================
74.1 Generic Methods
=============================

Generics allow the reuse of code across different types.
For example, let's declare a method that swaps the values of its two parameters:
static void Swap(ref int a, ref int b) {
  int temp = a;
  a = b;
  b = temp;
}
CS
Our Swap method will work only for integer parameters. If we want to use it for other types, for example, doubles or strings, we have to overload it for all the types we want to use it with. Besides a lot of code repetition, it becomes harder to manage the code because changes in one method mean changes to all of the overloaded methods.
Generics provide a flexible mechanism to define a generic type.
static void Swap<T>(ref T a, ref T b) {
  T temp = a;
  a = b;
  b = temp;
}
CS
In the code above, T is the name of our generic type. We can name it anything we want, but T is a commonly used name. Our Swap method now takes two parameters of type T. We also use the T type for our temp variable that is used to swap the values.
Note the brackets in the syntax <T>, which are used to define a generic type.

Generic Methods


Now, we can use our Swap method with different types, as in:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Swap<T>(ref T a, ref T b) {
            T temp = a;
            a = b;
            b = temp;
        }
        static void Main(string[] args)
        {
            int a = 4, b = 9;
            Swap<int>(ref a, ref b);
            Console.WriteLine(a+" "+b);
            
            string x = "Hello";
            string y = "World";
            Swap<string>(ref x, ref y);
            Console.WriteLine(x+" "+y);
        }
    }
}
When calling a generic method, we need to specify the type it will work with by using brackets. So, when Swap<int> is called, the T type is replaced by int. For Swap<string>, T is replaced by string.
If you omit specifying the type when calling a generic method, the compiler will use the type based on the arguments passed to the method.
Multiple generic parameters can be used with a single method.
For example: Func<T, U> takes two different generic types.

=============================
75.1 Generic C;asses
=============================

Generic Classes


Generic types can also be used with classes.
The most common use for generic classes is with collections of items, where operations such as adding and removing items from the collection are performed in basically the same way regardless of the type of data being stored. One type of collection is called a stack. Items are "pushed", or added to the collection, and "popped", or removed from the collection. A stack is sometimes called a Last In First Out (LIFO) data structure.
For example:
class Stack<T> {
  int index=0;
  T[] innerArray = new T[100];
  public void Push(T item) {
    innerArray[index++] = item; 
  }
  public T Pop() {
    return innerArray[--index]; 
  }
  public T Get(int k) { return innerArray[k]; }
}
CS
The generic class stores elements in an array. As you can see, the generic type T is used as the type of the array, the parameter type for the Push method, and the return type for the Pop and Get methods.
Now we can create objects of our generic class:
Stack<int> intStack = new Stack<int>();
Stack<string> strStack = new Stack<string>();
Stack<Person> PersonStack = new Stack<Person>();
CS
We can also use the generic class with custom types, such as the custom defined Person type.
In a generic class we do not need to define the generic type for its methods, because the generic type is already defined on the class level.

Generic Classes


Generic class methods are called the same as for any other object:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Stack<T> {
            int index=0;
            T[] innerArray = new T[100];
            public void Push(T item) {
                innerArray[index++] = item; 
            }
            public T Pop() {
                return innerArray[--index]; 
            }
            public T Get(int k) { return innerArray[k]; }
        }
        static void Main(string[] args)
        {
            Stack<int> intStack = new Stack<int>();
            intStack.Push(3);
            intStack.Push(6);
            intStack.Push(7);
            
            Console.WriteLine(intStack.Get(1));
        }
    }
}

=============================
76.1 Collections
=============================
C# Collections


A collection is used to group related objects. Unlike an array, it is dynamic and can also group objects. A collection can grow and shrink to accommodate any number of objects. Collection classes are organized into namespaces and contain built in methods for processing elements within the collection.

A collection organizes related data in a computer so that it can be used efficiently.
Different kinds of collections are suited to different kinds of applications, and some are highly specialized to specific tasks. For example, Dictionaries are used to represent connections on social websites (such as Twitter, Facebook), queues can be used to create task schedulers, HashSets are used in searching algorithms, etc.

A collection typically includes methods to add, remove, and count objects. The for statement and the foreach statement are used to iterate through collections. Since a collection is a class you must first declare an instance of the class before you can add elements to that collection.
For example:
List<int> li = new List<int>(); 
CS
Collections provide a more flexible way to work with groups of objects. Unlike arrays, the group of objects you work with can grow and shrink dynamically as the needs of the application change.

Generic Collections


Generic collections are the preferred type to use as long as every element in the collection is of the same data type. Only desired data types can be added to a generic collection and this is enforced by using strong typing which reduces the possibility of errors.
The .NET Framework provides a number of generic collection classes, useful for storing and manipulating data.
The System.Collections.Generic namespace includes the following generic collections:
- List<T>
- Dictionary<TKey, TValue>
- SortedList<TKey, TValue>
- Stack<T>
- Queue<T>
- Hashset<T>

To access a generic collection in your code, you will need to include the statement: using Systems.Collections.Generic;

Non-Generic Collections

Non-generic collections can store items that are of type Object. Since an Object data type can refer to any data type, you run the risk of unexpected outcomes. Non-generic collections may also be slower to access as well as execute.
The System.Collections namespace includes the following non-generic collections:
- ArrayList
- SortedList
- Stack
- Queue
- Hashtable
- BitArray
Because non-generic collections are error prone and less performant, it is recommended to always use generic collections from the System.Collections.Generic namespace if available and to avoid using legacy collections from the System.Collections namespace.

=============================
77.1 Lists and BitArray
=============================
List<T>


A list is similar to an array, but the elements in a list can be inserted and removed dynamically.
The C# generic collection List<T> class requires all elements be of the same type T.

List<T> properties and methods include:
Count A property that gets the number of elements contained in the list.
Item[int i] Gets or sets the element in the list at the index i. Item is the indexer and is not required when accessing an element. You only need to use the brackets [] and the index value inside the brackets.
Add(T t) Adds an element t to the end of the list.
RemoveAt(int index) Removes the element at the specified position (index) from the list.
Sort() Sorts elements in the list.

Now let's try List<T>:
using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
		    List<int> li = new List<int>();
            li.Add(59);
            li.Add(72);
            li.Add(95);
            li.Add(5);
            li.Add(9);
            li.RemoveAt(1); // remove 72
            
            Console.Write("\nList: ");
            for (int x = 0; x < li.Count; x++)
                Console.Write(li[x] + " "); // 59  95  5  9
            li.Sort();
            Console.Write("\nSorted: ");
            for (int x = 0; x < li.Count; x++)
                Console.Write(li[x] + " "); // 5  9  59  95
		}
	}
}

Additional List<T> properties and methods are listed below. Try them out by adding them to the List<T> example code above.

Capacity - A property that gets the number of elements the list can hold before needing to be resized.

Clear() - Removes all the elements from the list.

TrimExcess() - Sets the capacity to the actual number of elements in the list. This is useful when trying to reduce memory overhead.

AddRange(IEnumerable coll) - Adds the elements of collection coll with elements of the same type as List<T> to the end of the list. IEnumerable is the collections interface that supports simple iteration over the collection.

Insert(int i, T t) - Inserts an element t at a specific index i in the list.

InsertRange(int i, IEnumerable coll) - Inserts the elements of a collection coll at a specified index i in the list. IEnumerable is the collections interface that supports simple iteration over the collection.

Remove(T t) - Removes the first occurrence of the object t from the list.

RemoveRange(int i, int count) - Removes a specified number of elements count from the list starting at a specified index i.

Contains(T t) - Returns true if the specified element t is present in the list.

IndexOf(T t) - Returns the index of the first occurrence of the element t in the list.

Reverse() - Reverses the order of the elements in the list.

ToArray() - Copies the elements of the list into a new array.

SortedList<K, V>


A sorted list is a collection of key/value pairs that are sorted by key. A key can be used to access its corresponding value in the sorted list.

The C# generic collection SortedList<K, V> class requires all element key/value pairs to be of the same type K, V. Duplicate keys are not permitted, which ensures that every key/value pair is unique.

SortedList<K, V> properties include:
Count - Gets the number of key/value pairs contained in the sorted list.
Item[K key] - Gets or sets the value associated the specified key contained in the sorted list. Item is the indexer and is not required when accessing an element. You only need to use the brackets [] and the key, value.
Keys - Gets a sorted and indexed collection containing only the keys in the sorted list.

SortedList<K, V> methods include:
Add(K key, V value) - Adds an element with a specific key, value pair into the sorted list.
Remove(K key) - Removes the element with the specific key, value pair associated with the specified key from the sorted list.

Now let's try SortedList<K, V>:
using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
		    SortedList<string, int> sl = new SortedList<string, int>();

		    sl.Add("Solo", 59);
		    sl.Add("A", 95);
		    sl.Add("Learn", 72);
		    sl.Remove("A");
            
		    Console.WriteLine("Sorted List: ");
		    foreach (string s in sl.Keys)
		        Console.WriteLine(s + ": " + sl[s]);  // Learn: 72  Solo: 59
		    Console.WriteLine("\nCount: " + sl.Count);  // 2
		}
	}
}

Here are additional SortedList<K, V> properties and methods:
Values - Gets a sorted and indexed collection of the values in the sorted list.
Clear() - Removes all the elements from the sorted list.
ContainsKey(K key) - Returns true when the specified key is present in the sorted list.
ContainsValue(V value) - Returns true when a specified value is present in the sorted list.
IndexOfKey(K key) - Returns the index of the specified key within the sorted list.
IndexOfValue(V value) - Returns the index of the specified value within the sorted list.

BitArray


A bit array is a collection of bits. The value of a bit can be either 0 (off/false) or 1 (on/true).
Bit arrays compactly store bits. Most commonly, they are used to represent a simple group of boolean flags or an ordered sequence of boolean values.

BitArray properties include:
Count - Gets the number of bits in the bit array.
IsReadOnly - Gets a value indicating if the bit array is read only or not.

BitArray methods include:
Get(int i) - Gets the value of the bit at a specified position i in the bit array.
Set(int i, bool value) - Sets the bit at a specified position i to a specified value in the bit array.
SetAll(bool value) - Sets all the bits to a specified value in the bit array.
And(BitArray ba) - Performs the bitwise AND operation on the elements of the bit array object with a specified bit array ba.
Or(BitArray ba) - Performs the bitwise OR operation on the elements of the bit array and the specified bit array ba.
Not() - Inverts the bit values of the bit array.
Xor(BitArray ba) - Performs the bitwise XOR operation on the elements of the current bit array object and the elements in the specified bit array ba.

This example demonstrates some properties and methods of the BitArray class:
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
 {
    class Program
    {
        // Printing BitArray
        public static void PrintBarr(string name, BitArray ba)
        {
            Console.Write(name + " : ");
            for (int x = 0; x < ba.Length; x++)
                Console.Write(ba.Get(x) + " ");
            Console.WriteLine();
        }
        
        public static void Main(string[] args)
        {
            BitArray ba1 = new BitArray(4);
            BitArray ba2 = new BitArray(4);
            
            ba1.SetAll(true);
            ba2.SetAll(false);
            
            ba1.Set(2, false);
            ba2.Set(3, true);
            
            PrintBarr("ba1", ba1);
            PrintBarr("ba2", ba2);
            Console.WriteLine();
            
            PrintBarr("ba1 AND ba2", ba1.And(ba2));
            PrintBarr("    NOT ba2", ba2.Not());
        }
    }
}
For example, BitArrays can be used in image processing to store the individual bits of a gray-scale image.

=============================
78.1 Stack & Queue
=============================

Stack<T>


A stack is a Last In, First Out (LIFO) collection of elements where the last element that goes into the stack will be the first element that comes out.

Inserting an element onto a stack is called pushing. Deleting an element from a stack is called popping. Pushing and popping can be performed only at the top of the stack.
Stacks can be used to create undo-redo functionalities, parsing expressions (infix to postfix/prefix conversion), and much more.
The C# generic collection Stack<T> class requires all elements to be of the same type T.

Stack<T> properties include:
Count - Returns the number of elements in the stack.

Stack<T> methods include:
Peek() - Returns the element at the top of the stack without removing it.
Pop() - Returns the element at the top of the stack and removes it from the stack.
Push(T t) - Inserts an element t at the top of the stack.

Now let's try Stack<T>:
using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
		    Stack<int> s = new Stack<int>();
            
		    s.Push(59);
		    s.Push(72);
		    s.Push(65);

		    Console.Write("Stack: ");
		    foreach (int i in s)
		        Console.Write(i + " ");  // 65  72  59
		    Console.Write("\nCount: " + s.Count);  // 3
            
		    Console.Write("\nTop: " + s.Peek());  // 65
		    Console.Write("\nPop: " + s.Pop());  // 65
            
		    Console.Write("\nStack: ");
		    foreach (int i in s)
		        Console.Write(i + " ");  // 72  59
		    Console.Write("\nCount: " + s.Count);  // 2
		}
	}
}

Here are additional Stack<T> methods:
Clear() - Removes all the elements from the stack.
Contains(T t) - Returns true when the element t is present in the stack.
ToArray() - Copies the stack into a new array.

Queue<T>


A queue is a First In, First Out (FIFO) collection of elements where the first element that goes into a queue is also the first element that comes out.

Inserting an element into a queue is referred to as Enqueue. Deleting an element from a queue is referred to as Dequeue.
Queues are used whenever we need to manage objects in order starting with the first one in.
Scenarios include printing documents on a printer, call center systems answering people on hold people, and so on.
The C# generic collection Queue<T> class requires that all elements be of the same type T.

Queue<T> properties include:
Count - Gets the number of elements in the queue.

And methods include:
Dequeue() - Returns the object at the beginning of the queue and also removes it.
Enqueue(T t) - Adds the object t to the end of the queue.

Now let's try Queue<T>:
using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
            Queue<int> q = new Queue<int>();
            
            q.Enqueue(5);
            q.Enqueue(10);
            q.Enqueue(15);
            Console.Write("Queue: ");
            foreach (int i in q)
                Console.Write(i + " ");  // 5  10  15
            Console.Write("\nCount: " + q.Count);  // 3
            
            Console.Write("\nDequeue: " + q.Dequeue()); // 5
            
            Console.Write("\nQueue: ");
            foreach (int i in q)
                Console.Write(i + " ");  // 10  15
            Console.Write("\nCount: " + q.Count);  // 2
		}
	}
}

Here are additional Queue<T> methods:
Clear() - Removes all objects from the queue.
Contains(T t) - Returns true when the element t is present in the queue.
Peek() - Returns the object at the beginning of the queue without removing it.
ToArray() - Copies the queue into a new array.

=============================
79.1 Dictionary & HashSet
=============================

Dictionary<U, V>


A dictionary is a collection of unique key/value pairs where a key is used to access the corresponding value. Dictionaries are used in database indexing, cache implementations, and so on.

The C# generic collection Dictionary<K, V> class requires all key/value pairs be of the same type K, V. Duplicate keys are not permitted to ensure that every key/value pair is unique.

Dictionary<K, V> properties include:
Count - Gets the number of key/value pairs contained in the dictionary.
Item[K key] - Gets the value associated with the specified key in the dictionary. Item is the indexer and is not required when accessing an element. You only need to use the brackets [] and key value.
Keys - Gets an indexed collection containing only the keys contained in the dictionary.

Dictionary<K, V> methods include:
Add(K key, V value) - Adds the key, value pair to the dictionary.
Remove(K key) - Removes the key/value pair related to the specified key from the dictionary.

Now let's try Dictionary<K, V>:
using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
		    Dictionary<string, int> d = new Dictionary<string, int>();
            d.Add("Uno", 1);
            d.Add("One", 1);
            d.Add("Dos", 2);
            d.Add("Deux", 2);
            d.Remove("One");  // Remove key-value pair One, 1
            d.Remove("Dos");  // Remove key-value pair Dos, 2
            
            Console.WriteLine("Dictionary: ");
            foreach (string s in d.Keys)
                Console.WriteLine(s + ": " + d[s]);  // Uno: 1  Deux: 2
            Console.WriteLine("\nCount: {0}", d.Count); // 2 
		}
	}
}

In the above example, the dictionary d uses strings as it's keys and integers as the values.

Here are the additional Dictionary<K, V> properties and methods:
Values - Gets an indexed collection containing only the values in the dictionary.
Clear() - Removes all the key/value pairs from the dictionary.
ContainsKey(K key) - Returns true if the specified key is present in the dictionary.
ContainsValue(V value) - Returns true if the specified value is present in the dictionary.

HashSet<T>


A hash set is a set of unique values where duplicates are not allowed.

C# includes the HashSet<T> class in the generic collections namespace. All HashSet<T> elements are required to be of the same type T.
Hash sets are different from other collections because they are simply a set of values. They do not have index positions and elements cannot be ordered.
The HashSet<T> class provides high-performance set operations. HashSets allow fast lookup, addition, and removal of items, and can be used to implement either dynamic sets of items or lookup tables that allow finding an item by its key (e.g., finding the phone number of a person by the last name).
HashSet<T> properties include:
Count Returns the number of values in the hash set.

And methods include:
Add(T t) Adds a value (t) to the hash set.
IsSubsetOf(ICollection c) Returns true if the hash set is a subset of the specified collection (c).

Now let's try HashSet<T>:
using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
            HashSet<int> hs = new HashSet<int>();
            
            hs.Add(5);
            hs.Add(10);
            hs.Add(15);
            hs.Add(20);
            Console.Write("\nHashSet: ");
            foreach (int i in hs)
                Console.Write(i + " ");  // 5  10  15  20  *elements may be in any order
            Console.Write("\nCount: " + hs.Count);  // 4
            
            HashSet<int> hs2 = new HashSet<int>();
            hs2.Add(15);
            hs2.Add(20);
            Console.Write("\n{15, 20} is a subset of {5, 10, 15, 20}: " + hs2.IsSubsetOf(hs)); // True 
		}
	}
}

Here are additional HashSet<T> methods:
Remove(T t) Removes the value (t) from the hash set.
Clear() Removes all the elements form the hash set.
Contains(T t) Returns true when a value (t) is present in the hash set.
ToString() Creates a string from the hash set.
IsSupersetOf(ICollection c) Returns true if the hash set is a superset of the specified collection.
UnionWith(ICollection c) Applies set union operation on the hash set and the specified collection (c).
IntersectWith(ICollection c) Applies set intersection operation on the hash set and the specified collection (c).
ExceptWith(ICollection c) Applies set difference operation on the hash set and the specified collection (c).

					THE END.

=============================
Dynamic Memory
=============================
Static & Dynamic Memory


To be successful as a C++ programmer, it's essential to have a good understanding of how dynamic memory works.
In a C++ program, memory is divided into two parts:
The stack: All of your local variables take up memory from the stack.
The heap: Unused program memory that can be used when the program runs to dynamically allocate the memory.

Many times, you are not aware in advance how much memory you will need to store particular information in a defined variable and the size of required memory can be determined at run time.
You can allocate memory at run time within the heap for the variable of a given type using the new operator, which returns the address of the space allocated.
new int;
CPP
This allocates the memory size necessary for storing an integer on the heap, and returns that address.

Dynamic Memory


The allocated address can be stored in a pointer, which can then be dereferenced to access the variable.
Example:
int *p = new int;
*p = 5;
CPP
We have dynamically allocated memory for an integer, and assigned it a value of 5.
The pointer p is stored in the stack as a local variable, and holds the heap's allocated address as its value. The value of 5 is stored at that address in the heap.

Dynamic Memory


For local variables on the stack, managing memory is carried out automatically.
On the heap, it's necessary to manually handle the dynamically allocated memory, and use the delete operator to free up the memory when it's no longer needed.
delete pointer;
CPP
This statement releases the memory pointed to by pointer.

For example:
#include <iostream>
using namespace std;

int main()
{
    int *p = new int; // request memory
    *p = 5; // store value

    cout << *p << endl; // use value

    delete p; // free up the memory

    return 0;
}
Forgetting to free up memory that has been allocated with the new keyword will result in memory leaks, because that memory will stay allocated until the program shuts down.

Dangling Pointers


The delete operator frees up the memory allocated for the variable, but does not delete the pointer itself, as the pointer is stored on the stack.

Pointers that are left pointing to non-existent memory locations are called dangling pointers.
For example:
#include <iostream>
using namespace std;

int main()
{
    int *p = new int; // request memory
    *p = 5; // store value

    delete p; // free up the memory
    // now p is a dangling pointer

    p = new int; // reuse for a new address

    return 0;
}
The NULL pointer is a constant with a value of zero that is defined in several of the standard libraries, including iostream.
It's a good practice to assign NULL to a pointer variable when you declare it, in case you do not have exact address to be assigned. A pointer assigned NULL is called a null pointer. For example: int *ptr = NULL;

Dynamic Memory


Dynamic memory can also be allocated for arrays.
For example:
#include <iostream>
using namespace std;

int main()
{
    int *p = NULL; // Pointer initialized with null
    p = new int[20]; // Request memory
    delete [] p; // Delete array pointed to by p

    return 0;
}
Note the brackets in the syntax.
Dynamic memory allocation is useful in many situations, such as when your program depends on input. As an example, when your program needs to read an image file, it doesn't know in advance the size of the image file and the memory necessary to store the image.

=============================
The sizeof() Operator
=============================

sizeof


While the size allocated for varying data types depends on the architecture of the computer you use to run your programs, C++ does guarantee a minimum size for the basic data types:
Category		Type		Minimum size
boolean			bool		1 byte
character		char		1 byte
integer			short		2 bytes
			int		2 bytes
			long		4 bytes
			long long	8bytes
floating point		float		4 bytes
			doubl		8 bytese
			longdouble	8 bytes

Floating Point
The sizeof operator can be used to get a variable or data type's size, in bytes.
Syntax:
sizeof (data type)
CPP
The sizeof operator determines and returns the size of either a type or a variable in bytes.
For example:
#include <iostream>
using namespace std;

int main()
{
    cout << "char: " << sizeof(char) << endl;
    cout << "int: " << sizeof(int) << endl;
    cout << "float: " << sizeof(float) << endl;
    cout << "double: " << sizeof(double) << endl;
    int var = 50;
    cout << "var: " << sizeof(var) << endl;

    return 0;
}
Output values may vary, according to the computer and compiler used.

Size of an Array


The C++ sizeof operator is also used to determine the size of an array.
For example:
#include <iostream>
using namespace std;

int main()
{
    double myArr[10];
    cout << sizeof(myArr) << endl;

    return 0;
}
On our machine, double takes 8 bytes. The array stores 10 doubles, so the entire array occupies 80 (8*10) bytes in the memory.

In addition, divide the total number of bytes in the array by the number of bytes in a single element to learn how many elements you have in the array.
For example:
#include <iostream>
using namespace std;

int main()
{
    int numbers[100];
    cout << sizeof(numbers) / sizeof(numbers[0]);

    return 0;
}

=============================
Composition, Part 1
=============================

Composition


In the real world, complex objects are typically built using smaller, simpler objects. For example, a car is assembled using a metal frame, an engine, tires, and a large number of other parts. This process is called composition.

In C++, object composition involves using classes as member variables in other classes.
This sample program demonstrates composition in action. It contains Person and Birthday classes, and each Person will have a Birthday object as its member.
Birthday:
class Birthday {
 public:
  Birthday(int m, int d, int y)
  : month(m), day(d), year(y)
  { 
  }
 private:
   int month;
   int day;
   int year;
};
CPP
Our Birthday class has three member variables. It also has a constructor that initializes the members using a member initialization list.
The class was declared in a single file for the sake of simplicity. Alternatively, you could use header and source files.

Composition


Let's also add a printDate() function to our Birthday class:
class Birthday {
 public:
  Birthday(int m, int d, int y)
  : month(m), day(d), year(y)
  {
  }
  void printDate()
  {
   cout<<month<<"/"<<day
   <<"/"<<year<<endl;
  }
 private:
  int month;
  int day;
  int year;
};
CPP
Add a printDate() function to our Birthday class.

Composition


Next, we can create the Person class, which includes the Birthday class.
#include <string>
#include "Birthday.h"

class Person {
 public:
  Person(string n, Birthday b)
  : name(n),
   bd(b)
  {
  }
 private:
  string name;
  Birthday bd;
};
CPP
The Person class has a name and a Birthday member, and a constructor to initialize them.
Ensure that the corresponding header files are included.
More on Composition coming up in the next lesson!

=============================
Composition, Part 2
=============================
Composition


Now, our Person class has a member of type Birthday
class Person {
 public:
  Person(string n, Birthday b)
  : name(n),
    bd(b)
  {
  }
 private:
  string name;
  Birthday bd;
};
CPP
Composition is used for objects that share a has-a relationship, as in "A Person has a Birthday".

Composition


Let's add a printInfo() function to our Person class, that prints the data of the object:
class Person {
 public:
  Person(string n, Birthday b)
  : name(n),
  bd(b)
  {
  }
  void printInfo()
  {
   cout << name << endl;
   bd.printDate();
  }
 private:
  string name;
  Birthday bd;
};
CPP
Notice that we can call the bd member's printDate() function, since it's of type Birthday, which has that function defined.

Composition


Now that we've defined our Birthday and Person classes, we can go to our main, create a Birthday object, and then pass it to a Person object.
We've created a Birthday object for the date of 2/21/1985. Next, we created a Person object and passed the Birthday object to its constructor. Finally, we used the Person object's printInfo() function to print its data.
In general, composition serves to keep each individual class relatively simple, straightforward, and focused on performing one task. It also enables each sub-object to be self-contained, allowing for reusability (we can use the Birthday class within various other classes).

=============================
Function Templates
=============================
Function Templates


Functions and classes help to make programs easier to write, safer, and more maintainable.
However, while functions and classes do have all of those advantages, in certain cases they can also be somewhat limited by C++'s requirement that you specify types for all of your parameters.

For example, you might want to write a function that calculates the sum of two numbers, similar to this:
#include <iostream>
using namespace std;

int sum(int a, int b) {
    return a+b;
}

int main () {
    int x=7, y=15;
    cout << sum(x, y) << endl;
}
CPP
You can use templates to define functions as well as classes. Let's see how they work.

Function Templates


We can now call the function for two integers in our main.
#include <iostream>
using namespace std;

int sum(int a, int b) {
    return a+b;
}

int main () {
    int x=7, y=15;
    cout << sum(x, y) << endl;
}
The function works as expected, but is limited solely to integers.

Function Templates


It becomes necessary to write a new function for each new type, such as doubles.
double sum(double a, double b) {
  return a+b;
}
CPP
Wouldn't it be much more efficient to be able to write one version of sum() to work with parameters of any type?
Function templates give us the ability to do that!
With function templates, the basic idea is to avoid the necessity of specifying an exact type for each variable. Instead, C++ provides us with the capability of defining functions using placeholder types, called template type parameters.

To define a function template, use the keyword template, followed by the template type definition:
template <class T> 
CPP
We named our template type T, which is a generic data type.
Tap Continue to learn more!

Function Templates


Now we can use our generic data type T in the function:
#include <iostream>
using namespace std;

template <class T>
T sum(T a, T b) {
    return a+b;
}

int main () {
    int x=7, y=15;
    cout << sum(x, y) << endl;
}
The function returns a value of the generic type T, taking two parameters, also of type T.
Our new function worked exactly as the previous one for integer values did.

Function Templates


The same function can be used with other data types, for example doubles:
#include <iostream>
using namespace std;

template <class T>
T sum(T a, T b) {
    return a+b;
}

int main () {
    double x=7.15, y=15.54;
    cout << sum(x, y) << endl;
}
The compiler automatically calls the function for the corresponding type.
When creating a template type parameter, the keyword typename may be used as an alternative to the keyword class: template <typename T>.
In this context, the keywords are identical, but throughout this course, we'll use the keyword class.

Function Templates


Template functions can save a lot of time, because they are written only once, and work with different types.
Template functions reduce code maintenance, because duplicate code is reduced significantly.
Enhanced safety is another advantage in using template functions, since it's not necessary to manually copy functions and change types.

=============================
Function Templates with Multiple Parameters
=============================
Function Templates


Function templates also make it possible to work with multiple generic data types. Define the data types using a comma-separated list.
Let's create a function that compares arguments of varying data types (an int and a double), and prints the smaller one.
template <class T, class U>
CPP
As you can see, this template declares two different generic data types, T and U.

Function Templates


Now we can continue with our function declaration:
template <class T, class U>
T smaller(T a, U b) {
  return (a < b ? a : b);
}
CPP
The ternary operator checks the a<b condition and returns the corresponding result. The expression (a < b ? a : b) is equivalent to the expression if a is smaller than b, return a, else, return b.

Function Templates


In our main, we can use the function for different data types:
#include <iostream>
using namespace std;

template <class T, class U>
T smaller(T a, U b) {
    return (a < b ? a : b);
}

int main () {
    int x=72;
    double y=15.34;
    cout << smaller(x, y) << endl;
}
The output converts to an integer, because we specified the function template's return type to be of the same type as the first parameter (T), which is an integer.

Function Templates


T is short for Type, and is a widely used name for type parameters.
It's not necessary to use T, however; you can declare your type parameters using any identifiers that work for you. The only terms you need to avoid are C++ keywords.
Remember that when you declare a template parameter, you absolutely must use it in your function definition. Otherwise, the compiler will complain!

=============================
Class Templates
=============================
Class Templates

Just as we can define function templates, we can also define class templates, allowing classes to have members that use template parameters as types.
The same syntax is used to define the class template:
template <class T>
class MyClass {

};
CPP
Just as with function templates, you can define more than one generic data type by using a comma-separated list.

Class Templates


As an example, let's create a class Pair, that will be holding a pair of values of a generic type.
template <class T>
class Pair {
 private:
  T first, second;
 public:
  Pair (T a, T b):
   first(a), second(b) {
  }
};
CPP
The code above declares a class template Pair, with two private variables of a generic type, and one constructor to initialize the variables.

Class Templates


A specific syntax is required in case you define your member functions outside of your class - for example in a separate source file.
You need to specify the generic type in angle brackets after the class name.
For example, to have a member function bigger() defined outside of the class, the following syntax is used:
template <class T>
class Pair {
 private:
  T first, second;
 public:
  Pair (T a, T b):
   first(a), second(b){
  }
  T bigger();
};

template <class T>
T Pair<T>::bigger() {
  // some code
}
CPP
A specific syntax is required in case you define your member functions outside of your class.

Class Templates


The bigger function returns the greater value of the two member variables.
template <class T>
class Pair {
 private:
  T first, second;
 public:
  Pair (T a, T b):
   first(a), second(b){
  }
  T bigger();
};

template <class T>
T Pair<T>::bigger() {
  return (first>second ? first : second);
}
CPP
The ternary operator compares the two variables, returning the greater one.

Class Templates


To create objects of the template class for different types, specify the data type in angle brackets, as we did when defining the function outside of the class.
Here, we create a Pair object for integers.
#include <iostream>
using namespace std;

template <class T>
class Pair {
    private:
        T first, second;
    public:
        Pair (T a, T b):
        first(a), second(b) { }
        T bigger();
};

template <class T>
T Pair<T>::bigger() {
    return (first>second ? first : second);
}

int main()
{
    Pair <int> obj(11, 22);
    cout << obj.bigger();

    return 0;
}
We can use the same class to create an object that stores any other type.
#include <iostream>
using namespace std;

template <class T>
class Pair {
    private:
        T first, second;
    public:
        Pair (T a, T b):
        first(a), second(b) { }
        T bigger();
};

template <class T>
T Pair<T>::bigger() {
    return (first>second ? first : second);
}

int main()
{
    Pair <double> obj(23.43, 5.68);
    cout << obj.bigger();

    return 0;
}

=============================
Template Specialization
=============================
Template Specialization


In case of regular class templates, the way the class handles different data types is the same; the same code runs for all data types.
Template specialization allows for the definition of a different implementation of a template when a specific type is passed as a template argument.

For example, we might need to handle the character data type in a different manner than we do numeric data types.
To demonstrate how this works, we can first create a regular template.
template <class T>
class MyClass {
 public:
  MyClass (T x) {
   cout <<x<<" -  not a char"<<endl;
  }
};
CPP
As a regular class template, MyClass treats all of the various data types in the same way.

Template Specialization


To specify different behavior for the data type char, we would create a template specialization.
template <class T>
class MyClass {
 public:
  MyClass (T x) {
   cout <<x<<" -  not a char"<<endl;
  }
};

template < >
class MyClass<char> {
 public:
  MyClass (char x) {
   cout <<x<<" is a char!"<<endl;
  }
};
CPP
First of all, notice that we precede the class name with template<>, including an empty parameter list. This is because all types are known and no template arguments are required for this specialization, but still, it is the specialization of a class template, and thus it requires to be noted as such.

But more important than this prefix, is the <char> specialization parameter after the class template name. This specialization parameter itself identifies the type for which the template class is being specialized (char).
In the example above, the first class is the generic template, while the second is the specialization.
If necessary, your specialization can indicate a completely different behavior from the behavior of the generic template.

Template Specialization


The next step is to declare objects of different types and check the result:
#include <iostream>
using namespace std;

template <class T>
class MyClass {
    public:
        MyClass (T x) {
            cout <<x<<" -  not a char"<<endl;
        }
};

template < >
class MyClass<char> {
    public:
        MyClass (char x) {
            cout <<x<<" is a char!"<<endl;
        }
};

int main () {
    MyClass<int> ob1(42);
    MyClass<double> ob2(5.47);
    MyClass<char> ob3('s');
}
As you can see, the generic template worked for int and double. However, our template specialization was invoked for the char data type.
Keep in mind that there is no member "inheritance" from the generic template to the specialization, so all members of the template class specializations must be defined on their own.

=============================
C# Type Casting
=============================
https://www.w3schools.com/cs/cs_type_casting.php

Type casting is when you assign a value of one data type to another type.

In C#, there are two types of casting:

Implicit Casting (automatically) - converting a smaller type to a larger type size
char -> int -> long -> float -> double

Explicit Casting (manually) - converting a larger type to a smaller size type
double -> float -> long -> int -> char
Implicit Casting
Implicit casting is done automatically when passing a smaller size type to a larger size type:

Example
int myInt = 9;
double myDouble = myInt;       // Automatic casting: int to double

Console.WriteLine(myInt);      // Outputs 9
Console.WriteLine(myDouble);   // Outputs 9

Explicit Casting
Explicit casting must be done manually by placing the type in parentheses in front of the value:

Example
double myDouble = 9.78;
int myInt = (int) myDouble;    // Manual casting: double to int

Console.WriteLine(myDouble);   // Outputs 9.78
Console.WriteLine(myInt);      // Outputs 9

Type Conversion Methods
It is also possible to convert data types explicitly by using built-in methods, such as Convert.ToBoolean, Convert.ToDouble, Convert.ToString, Convert.ToInt32 (int) and Convert.ToInt64 (long):

Example
int myInt = 10;
double myDouble = 5.25;
bool myBool = true;

Console.WriteLine(Convert.ToString(myInt));    // convert int to string
Console.WriteLine(Convert.ToDouble(myInt));    // convert int to double
Console.WriteLine(Convert.ToInt32(myDouble));  // convert double to int
Console.WriteLine(Convert.ToString(myBool));   // convert bool to string

Why Conversion?
Many times, there's no need for type conversion. But sometimes you have to. Take a look at the next chapter, when working with user input, to see an example of this.

=============================
C# .NET Delegates and Events
=============================
https://www.c-sharpcorner.com/UploadFile/puranindia/C-Sharp-net-delegates-and-events/

In this tutorial, learn what is a delegate in C# and how delegates are implemented in C#. A delegate in C# is type that is used to invoke a method. In this tutorial, you will learn the following.
What is a delegate in C#?
Why do we need delegates in C#?
What are the benefits of delegates in C# and .NET?
What are different types of delegates in C#?
How delefates are related to events in C#?
What are singlecast and multicast delegates in C#?
What is an anonmous delegate in C#?
C# delegate code examples
 
1. What is a Delegate in C#?
 
Delegate is one of the base types in .NET. Delegate is a class, which is used to create and invoke delegates at runtime.
 
C# Delegates
 
A delegate in C# is similar to a function pointer in C or C++. It's a new type of object in C#. Delegate is very special type of object as earlier the entire the object we used to defined contained data but delegate just contains the details of a method.
 
2. Why do we need delegates in C#?
 
Programmers often needs to pass a method as a parameter of other methods. For this purpose we create and use delegates.
A delegate is a class that encapsulates a method signature. Although it can be used in any context, it often serves as the basis for the event-handling model in C# and .NET.
 
One good way of understanding delegates is by thinking of a delegate as something that gives a name to a method signature.
 
Example:
public delegate int DelegateMethod(int x, int y);  
Any method that matches the delegate's signature, which consists of the return type and parameters, can be assigned to the delegate.
 
This makes is possible to programmatically change method calls, and also plug new code into existing classes. As long as you know the delegate's signature, you can assign your own-delegated method.
 
This ability to refer to a method as a parameter makes delegates ideal for defining callback methods.
 
Delegate magic
 
In class we create its object, which is instance, but in delegate when we create instance that is also referred as delegate (means whatever you do you will get delegate).
 
Delegate does not know or care about the class of the object that it references. Any object will do; all that matters is that the method's argument types and return type match the delegate's. This makes delegates perfectly suited for "anonymous" invocation.
 
3. What are the benefits of delegates?
 
In simple words delegates are object oriented and type-safe and very secure as they ensure that the signature of the method being called is correct. Delegates makes event handling simple and easy.
 
4. What are types of delegates in C#?
 
There are two types of delegates, singlecast delegates, and multiplecast delegates.
 
Singlecast delegate
 
Singlecast delegate point to single method at a time. In this the delegate is assigned to a single method at a time. They are derived from System.Delegate class.
 
Multicast Delegate
 
When a delegate is wrapped with more than one method that is known as a multicast delegate.
 
In C#, delegates are multicast, which means that they can point to more than one function at a time. They are derived from System.MulticastDelegate class.
 
5. How to define a delegates in C#?
 
 
There are three steps in defining and using delegates:
 
1. Declaration
 
To create a delegate, you use the delegate keyword.
[attributes] [modifiers] delegate ReturnType Name ([formal-parameters]);  
The attributes factor can be a normal C# attribute.
The modifier can be one or an appropriate combination of the following keywords: new, public, private, protected, or internal.
 The ReturnType can be any of the data types we have used so far. It can also be a type void or the name of a class.
 The Name must be a valid C# name. 
Because a delegate is a definituon for a method, you must use parentheses, required for every method. If this method will not take any argument, leave the parentheses empty.
 
Example:
public delegate void DelegateExample();  
The above code is how a delegate with no papameters is defined.
 
2. Instantiation
DelegateExample d1 = new DelegateExample(Display);  
The above code shows how a delegate is initiated.
 
3. Invocation 
d1();  
The above code piece invokes a delegate d1().
 
6. What is a Singlecast delegate in C#?
 
Here is a sample code that demonstrates how to create and use a singlecast delegate.
using System;    
namespace ConsoleApplication5    
{    
class Program    
{    
public delegate void delmethod();    
  
public class P    
{  
  
public static void display()    
{    
Console.WriteLine("Hello!");    
}    
  
public static void show()    
{    
Console.WriteLine("Hi!");    
}    
  
public void print()
{
Console.WriteLine("Print");
}

}
  
static void Main(string[] args)
{
// here we have assigned static method show() of class P to delegate delmethod()
delmethod del1 = P.show;
  
// here we have assigned static method display() of class P to delegate delmethod() using new operator
// you can use both ways to assign the delagate
delmethod del2 = new delmethod(P.display);
P obj = new P();
  
// here first we have create instance of class P and assigned the method print() to the delegate i.e. delegate with class    
delmethod del3 = obj.print;
  
del1();
del2();
del3();
Console.ReadLine();
}
}
}
7. What is a Multicast delegate in C#?
 
Here is sample code that demonstrates how to create and use a multicast delegate.
using System;  
namespace delegate_Example4  
{  
  
class Program  
{  
public delegate void delmethod(int x, int y);  
  
public class TestMultipleDelegate  
{  
public void plus_Method1(int x, int y)  
{  
Console.Write("You are in plus_Method");  
Console.WriteLine(x + y);  
}  
  
public void subtract_Method2(int x, int y)  
{  
Console.Write("You are in subtract_Method");  
Console.WriteLine(x - y);  
}  
}  
  
static void Main(string[] args)  
{  
  
TestMultipleDelegate obj = new TestMultipleDelegate();  
delmethod del = new delmethod(obj.plus_Method1);  
  
// Here we have multicast  
del += new delmethod(obj.subtract_Method2);  
// plus_Method1 and subtract_Method2 are called  
del(50, 10);  
Console.WriteLine();  
//Here again we have multicast  
del -= new delmethod(obj.plus_Method1);  
//Only subtract_Method2 is called  
del(20, 10);  
Console.ReadLine();  
}  
}  
}  
Point to remember about Delegates:
Delegates are similar to C++ function pointers, but are type safe.
Delegate gives a name to a method signature.
Delegates allow methods to be passed as parameters.
Delegates can be used to define callback methods.
Delegates can be chained together; for example, multiple methods can be called on a single event.
C# version 2.0 introduces the concept of Anonymous Methods, which permit code blocks to be passed as parameters in place of a separately defined method.
Delegate helps in code optimization.
Usage areas of delegates
The most common example of using delegates is in events. 
They are extensively used in threading
Delegates are also used for generic class libraries, which have generic functionality, defined.
8. What are Anonymous Delegates in C#?
 
You can create a delegate, but there is no need to declare the method associated with it. You do not have to explicitly define a method prior to using the delegate. Such a method is referred to as anonymous. In other words, if a delegate itself contains its method definition it is known as anonymous method.
 
The code is an example of using an anonymous delegate.
using System;  
  
public delegate void Test();  
  
public class Program  
{  
static int Main()  
{  
Test Display = delegate()  
{  
Console.WriteLine("Anonymous Delegate method");  
};  
  
Display();  
return 0;  
}  
}  
Note: You can also handle event in anonymous method.
 
9. How Delegates are Related to Events in C#?
 
Events and delegate work together. An event is a reference to a delegate i.e. when an event is raised, a delegate is called. In C# terms, events are a special form of delegates. 
 
Events play an important part in user interfaces and programming notifications. Events and delegates work hand-in-hand to provide a communication between code from one class to other class. When something happens in one class or one part of the code and other part of the code needs a notification, events are used. 
 
A C# event is a class member that is activated whenever the event it was designed for occurs. It starts with a class that declares an event. Any class, including the same class that the event is declared in, may register one of its methods for the event. This occurs through a delegate, which specifies the signature of the method that is registered for the event. The event keyword is a delegate modifier. It must always be used in connection with a delegate.
 
The delegate may be one of the pre-defined .NET delegates or one you declare yourself. Whichever is appropriate, you assign the delegate to the event, which effectively registers the method that will be called when the event fires.
 
10. How to Use Events and Delegates in C#?
 
Once an event is declared, it must be associated with one or more event handlers before it can be raised. An event handler is nothing but a method that is called using a delegate. Use the += operator to associate an event with an instance of a delegate that already exists.
 
Example:
obj.MyEvent += new MyDelegate(obj.Display);  
An event has the value null if it has no registered listeners.
 
Although events are mostly used in Windows controls programming, they can also be implemented in console, web and other applications.
 
Program for creating a custom Singlecast delegate and event
using System;  
namespace delegate_custom  
{  
class Program  
{  
public delegate void MyDelegate(int a);  
  
public class XX  
{  
public event MyDelegate MyEvent;  
  
public void RaiseEvent()  
{  
MyEvent(20);  
Console.WriteLine("Event Raised");  
}  
  
public void Display(int x)  
{  
Console.WriteLine("Display Method {0}", x);  
}  
}  
  
static void Main(string[] args)  
{  
  
XX obj = new XX();  
obj.MyEvent += new MyDelegate(obj.Display);  
  
obj.RaiseEvent();  
Console.ReadLine();  
}  
}  
}  
Program for creating custom a multiplecast delegate and event
using System;  
using System.Collections.Generic;  
using System.Linq;  
using System.Text;  
  
namespace delegate_custom_multicast  
{  
class Program  
{  
public delegate void MyDelegate(int a, int b);  
  
public class XX  
{  
public event MyDelegate MyEvent;  
  
public void RaiseEvent(int a, int b)  
{  
MyEvent(a, b);  
Console.WriteLine("Event Raised");  
}  
  
public void Add(int x, int y)  
{  
Console.WriteLine("Add Method {0}", x + y);  
}  
  
public void Subtract(int x, int y)  
{  
Console.WriteLine("Subtract Method {0}", x - y);  
}  
}  
  
static void Main(string[] args)  
{  
  
XX obj = new XX();  
obj.MyEvent += new MyDelegate(obj.Add);  
obj.MyEvent += new MyDelegate(obj.Subtract);  
obj.RaiseEvent(20, 10);  
Console.ReadLine();  
}  
}  
}  
Conclusion
 
Hope the article would have helped you in understanding delegates and events.

=============================
C# | Delegates
=============================
https://www.c-sharpcorner.com/UploadFile/1c8574/delegate-used-for-callback-operation/

A delegate is an object which refers to a method or you can say it is a reference type variable that can hold a reference to the methods. Delegates in C# are similar to the function pointer in C/C++. It provides a way which tells which method is to be called when an event is triggered. 
For example, if you click on a Button on a form (Windows Form application), the program would call a specific method. In simple words, it is a type that represents references to methods with a particular parameter list and return type and then calls the method in a program for execution when it is needed.
Important Points About Delegates: 
 

Provides a good way to encapsulate the methods.
Delegates are the library class in System namespace.
These are the type-safe pointer of any method.
Delegates are mainly used in implementing the call-back methods and events.
Delegates can be chained together as two or more methods can be called on a single event.
It doesn’t care about the class of the object that it references.
Delegates can also be used in “anonymous methods” invocation.
Anonymous Methods(C# 2.0) and Lambda expressions(C# 3.0) are compiled to delegate types in certain contexts. Sometimes, these features together are known as anonymous functions.
 

Declaration of Delegates
Delegate type can be declared using the delegate keyword. Once a delegate is declared, delegate instance will refer and call those methods whose return type and parameter-list matches with the delegate declaration.
Syntax: 
 

[modifier] delegate [return_type] [delegate_name] ([parameter_list]);
 

modifier: It is the required modifier which defines the access of delegate and it is optional to use.
delegate: It is the keyword which is used to define the delegate.
return_type: It is the type of value returned by the methods which the delegate will be going to call. It can be void. A method must have the same return type as the delegate.
delegate_name: It is the user-defined name or identifier for the delegate.
parameter_list: This contains the parameters which are required by the method when called through the delegate. 

Example: 
 

// "public" is the modifier
// "int" is return type
// "GeeksForGeeks" is delegate name
// "(int G, int F, int G)" are the parameters
public delegate int GeeksForGeeks(int G, int F, int G);
Note: A delegate will call only a method which agrees with its signature and return type. A method can be a static method associated with a class or can be an instance method associated with an object, it doesn’t matter. 
 

Instantiation & Invocation of Delegates
After declaring a delegate, a delegate object is created with the help of new keyword. Once a delegate is instantiated, a method call made to the delegate is pass by the delegate to that method. The parameters passed to the delegate by the caller are passed to the method, and the return value, if any, from the method, is returned to the caller by the delegate. This is known as invoking the delegate. 
Syntax:
 

[delegate_name]  [instance_name] = new [delegate_name](calling_method_name);
Example: 
 

GeeksForGeeks GFG = new GeeksForGeeks (Geeks);
       // here,
       // "GeeksForGeeks" is delegate name. 
       // "GFG" is instance_name
       // "Geeks" is the calling method.
Below program illustrate the use of Delegate:
 

// C# program to illustrate the use of Delegates
using System;
namespace GeeksForGeeks {
     
// declare class "Geeks"
class Geeks {
     
// Declaring the delegates
// Here return type and parameter type should
// be same as the return type and parameter type
// of the two methods
// "addnum" and "subnum" are two delegate names
public delegate void addnum(int a, int b);
public delegate void subnum(int a, int b);
     
    // method "sum"
    public void sum(int a, int b)
    {
        Console.WriteLine("(100 + 40) = {0}", a + b);
    }
 
    // method "subtract"
    public void subtract(int a, int b)
    {
        Console.WriteLine("(100 - 60) = {0}", a - b);
    }
 
// Main Method
public static void Main(String []args)
{
     
    // creating object "obj" of class "Geeks"
    Geeks obj = new Geeks();
 
    // creating object of delegate, name as "del_obj1"
    // for method "sum" and "del_obj2" for method "subtract" &
    // pass the parameter as the two methods by class object "obj"
    // instantiating the delegates
    addnum del_obj1 = new addnum(obj.sum);
    subnum del_obj2 = new subnum(obj.subtract);
 
    // pass the values to the methods by delegate object
    del_obj1(100, 40);
    del_obj2(100, 60);
 
    // These can be written as using
    // "Invoke" method
    // del_obj1.Invoke(100, 40);
    // del_obj2.Invoke(100, 60);
}
}
}
Output: 
 

(100 + 40) = 140
(100 - 60) = 40
Explanation: In the above program, there are two delegates addnum and subnum. We are creating the object obj of the class Geeks because both the methods(addnum and subnum) are instance methods. So they need an object to call. If methods are static then there is no need to create the object of the class.
 

Multicasting of a Delegate
Multicasting of delegate is an extension of the normal delegate(sometimes termed as Single Cast Delegate). It helps the user to point more than one method in a single call.
Properties: 
 

Delegates are combined and when you call a delegate then a complete list of methods is called.
All methods are called in First in First Out(FIFO) order.
‘+’ or ‘+=’ Operator is used to add the methods to delegates.
‘–’ or ‘-=’ Operator is used to remove the methods from the delegates list.
Note: Remember, multicasting of delegate should have a return type of Void otherwise it will throw a runtime exception. Also, the multicasting of delegate will return the value only from the last method added in the multicast. Although, the other methods will be executed successfully.
Below program demonstrates the use of Multicasting of a delegate:
 

// C# program to illustrate the
// Multicasting of Delegates
using System;
 
class rectangle {
     
// declaring delegate
public delegate void rectDelegate(double height,
                                  double width);
 
    // "area" method
    public void area(double height, double width)
    {
        Console.WriteLine("Area is: {0}", (width * height));
    }
  
    // "perimeter" method
    public void perimeter(double height, double width)
    {
        Console.WriteLine("Perimeter is: {0} ", 2 * (width + height));
    }
  
  
// Main Method
public static void Main(String []args)
{
     
    // creating object of class
    // "rectangle", named as "rect"
    rectangle rect = new rectangle();
 
    // these two lines are normal calling
    // of that two methods
    // rect.area(6.3, 4.2);
    // rect.perimeter(6.3, 4.2);
 
    // creating delegate object, name as "rectdele"
    // and pass the method as parameter by
    // class object "rect"
    rectDelegate rectdele = new rectDelegate(rect.area);
     
    // also can be written as
    // rectDelegate rectdele = rect.area;
 
    // call 2nd method "perimeter"
    // Multicasting
    rectdele += rect.perimeter;
 
    // pass the values in two method
    // by using "Invoke" method
    rectdele.Invoke(6.3, 4.2);
    Console.WriteLine();
     
    // call the methods with
    // different values
    rectdele.Invoke(16.3, 10.3);
}
}
Output: 
 

Area is: 26.46
Perimeter is: 21 

Area is: 167.89
Perimeter is: 53.2
 
Here is another recommended article on Delegates in C#.

=============================
Callback Operation By Delegate Or Interface
=============================
https://www.c-sharpcorner.com/UploadFile/1c8574/delegate-used-for-callback-operation/

Introduction
A "callback" is a term that refers to a coding design pattern. In this design pattern executable code is passed as an argument to other code and it is expected to call back at some time. This callback can be synchronous or asynchronous. So, in this way large piece of the internal behavior of a method from the outside of a method can be controlled. It is basically a function pointer that is being passed into another function.

Delegate is a famous way to implement Callback in C#.  But, it can also be implemented by Interface. I will explain Callback by Delegate and Interface one by one. 

Callback by Delegate 
Delegate provides a way to pass a method as argument to other method. To create a Callback in C#, function address will be passed inside a variable. So, this can be achieved by using Delegate.

The following is an example of Callback by Delegate

public delegate void TaskCompletedCallBack(string taskResult);
public class CallBack
{
    public void StartNewTask(TaskCompletedCallBack taskCompletedCallBack)
    {
        Console.WriteLine("I have started new Task.");
        if (taskCompletedCallBack != null)
            taskCompletedCallBack("I have completed Task.");
    }
}
C#
public class CallBackTest
{
    public void Test()
    {
        TaskCompletedCallBack callback = TestCallBack;
        CallBack testCallBack = new CallBack();
        testCallBack.StartNewTask(callback);
    }
    public void TestCallBack(string result)
    {
        Console.WriteLine(result);
    }
}
C#
static void Main(string[] args)
{
    CallBackTest callBackTest = new CallBackTest();
    callBackTest.Test();
    Console.ReadLine();
}
C#
Output

I have started new Task.

I have completed Task.

Delegate is a good way to implement Callback. But, you could use Interface for this. Because, suppose you have two methods - one for the success and another for the error and these methods will use Callback, so if you will use Delegate you will have to take two Delegates. 

If you need more than one Callback method then Callback mechanism with the use of Delegate doesn't makes sense. So, the use of Interface provides flexible and well-performing Callback mechanism for this scenario. 

Callback by Interface
Use an Interface to provide Callback mechanism. It provides flexible and well-performing Callback mechanism. The following code example will elaborate the Callback mechanism with the help of Interface:

public interface IMeeting
{
    void ShowAgenda(string agenda);
    void EmployeeAttendedMeeting(string employee);
    void EmployeeLeftMeeting(string employee);
}
C#
public class Meeting : IMeeting
{
    public void ShowAgenda(string agenda)
    {
        Console.WriteLine("Agenda Details: " + agenda);
    }

    public void EmployeeAttendedMeeting(string employee)
    {
        Console.WriteLine("Employee Attended Meeting: " + employee);
    }

    public void EmployeeLeftMeeting(string employee)
    {
        Console.WriteLine("Employee Left Meeting: " + employee);
    }
}
C#
public class MeetingRoom
{
    private string message;
    public MeetingRoom(string message)
    {
        this.message = message;
    }

    public void StartMeeting(IMeeting meeting)
    {
        // Its a callback
        if (meeting != null) meeting.ShowAgenda(message);

    }
}
C#
public class MeetingExecution
{
    public void PerformMeeting()
    {
        IMeeting meeging = new Meeting();
        MeetingRoom meetingStarted = new MeetingRoom("Code Quality Improvement.");
        meetingStarted.StartMeeting(meeging);
    }
}
C#
static void Main(string[] args)
{
    MeetingExecution meetingExecution = new MeetingExecution();
    meetingExecution.PerformMeeting();

    Console.ReadLine();
}
C#
Output

Agenda Details: Code Quality Improvement.

Conclusion
Delegate is a great way to implement Callback operation. But, interface is good for the implementation of Callback in different scenario which I have mentioned above. Please read carefully and understand the code snippets. I have also attached code files. Writing code is good but code with proper design approach increases the quality of code. So, before writing any code always try to follow some design approach. Your code will be awesome.

=============================
C# Delegate Tutorial With Easy Example
=============================
https://www.completecsharptutorial.com/basic/c-delegate-tutorial-with-easy-example.php

This article explains how to create and manipulate Delegates in c#. Before starting delegates you must understand what delegate is?

WHAT IS DELEGATE?
You may get numbers of complex reasons of using delegates on different site. I am not going to put a complex paragraph here. In simple word delegates contains the reference to several methods and call them when needed. So, you create numbers of methods as you need and attach it to delegates. At runtime, an event gets fired and delegates dynamically call the function and show the result.

REAL WORLD EXAMPLE
Let me draw a picture for you. For example, what will you do when you are in a railway station and suddenly hear a fire alarm. What would you do? You will run immediately outside of the campus. So, let me put this scenario in delegates.

When you hear fire alarm it is actually an event. As you hear fire alarm you initiate to run() function to escape.
But if you hear an announcement about your train you don't escape and go to the suitable platform to catch the train.
If you hear your name in the announcement that someone is on phone-line and want to talk to you; you go to inquiry counter to attend the phone.
If you hear that train is 6 hours late you may think of a movie meanwhile the time.
So, in real-world example we also react differently based on event or situation. In programming, delegate does the same thing. We create numbers of suitable function and execute them based on Event.fig-delegate 

Delegate figure
*function()*--------l
function()---------->v^  Delegate ---generate an event--- ++(Publisher (event generator))++
function()-----------l

SOME FACTS ABOUT DELEGATES
Delegates are reference type but instead of referencing objects it reference methods.
Delegates have no method body.
Delegates are type-safe, object-oriented and secure.
A Delegate is a function pointer that allows you to reference a method.
Delegates encapsulate methods.
A Function that is added to delegates must have same return type and same signature as delegate.
A Delegate can be created using delegate keyword.
Delegates with no parameter and no return type
Public delegate TestDelegate();

Delegates with a parameter but no return type
Public delegate TestDelegate(object obj1, object obj2);

Or,
Public delegate TestDelegate(String message)

Delegates with parameters and return type
public delegate int TestDelegate(object obj1, object obj2);

A delegate has 3 steps
Declaration
Instantiation
Invocation
PROGRAMMING EXAMPLE
Here, I am showing you very basic delegates programming. Once you understand how delegates work you will be able to crack complex delegates codes.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace ConsoleApplication2
{
    public class TestDelegate
    {
        //Declaration
        //Creating Delegates with no parameters and no return type.
        public delegate void FirstDelegate();
 
        public void fun1()
        {
            Console.WriteLine("I am Function 1");
        }
        public void fun2()
        {
            Console.WriteLine("I am Function 2");
        }
        public void fun3()
        {
            Console.WriteLine("I am Function 3");
        }
    }
 
    class Program
    {
        static void Main(string[] args)
        {
            TestDelegate testdelegate = new TestDelegate();
//Instantiation
            TestDelegate.FirstDelegate fd1 = new TestDelegate.FirstDelegate(testdelegate.fun1);
            TestDelegate.FirstDelegate fd2 = new TestDelegate.FirstDelegate(testdelegate.fun2);
            TestDelegate.FirstDelegate fd3 = new TestDelegate.FirstDelegate(testdelegate.fun3);
 
//Invocation 
           fd1();
            fd2();
            fd3();
 
            Console.ReadKey();
        }
    }
}

Output
I am Function 1

I am Function 2

I am Function 3

_
EXPLANATION
In this programming Example, I have created a delegate
 public delegate void FirstDelegate();

I have also created 3 functions
public void fun1()
public void fun2()
public void fun3()

In the main function creates an object of delegates. You must remember that a delegate always requires a function while initialized.
TestDelegate.FirstDelegate fd1 = new TestDelegate.FirstDelegate(testdelegate.fun1);
TestDelegate.FirstDelegate fd2 = new TestDelegate.FirstDelegate(testdelegate.fun2);
TestDelegate.FirstDelegate fd3 = new TestDelegate.FirstDelegate(testdelegate.fun3);

Finally call the delegates to execute the function.
fd1();
fd2();
fd3();

EXAMPLE 2
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace DelegateExample
{
    class Program
    {
        public delegate int calculator(int x, int y);
 
        static int Addition(int a, int b)
        {
            return a + b;
        }
        static int Subtraction(int a, int b)
        {
            return a - b;
        }
        static void Main(string[] args)
        {
            calculator c = new calculator(Program.Addition);
            Console.WriteLine("Addition of 5 and 10 is : {0}", c(5, 10));
 
            calculator d = new calculator(Program.Subtraction);
            Console.WriteLine("Subtraction of 5 and 10 is : {0}", d(5, 10));
 
            Console.ReadKey();
        }
    }
}

Output
Addition of 5 and 10 is : 15


Subtraction of 5 and 10 is : -5
SUMMARY
In this chapter, you learned what is delegates and how to use it in programming. In the next chapter, you will learn about multicast delegates with example.

=============================
Nested C# loops: programming loops inside each other
=============================
https://kodify.net/csharp/loop/nested-loop/

Most of the time, our C# loops process a collection or count from one value to the next. But sometimes we have to do complex calculations or handle nested collections. In those cases we need the more advanced nested loops. Let’s see how those work.

IN THIS ARTICLE:

Understand nested loops in C#
Quick example: nested for loop in C#
Code a foreach nested loop in C#
Example: code a nested foreach loop in C#
Creating nested loops with C#’s for loop
Example: program a nested for loop in C#
Make nested loops with C#’s while loop
Example: make a nested loop with the while loop
Summary
# Understand nested loops in C#
A nested loop is a construction of two or more loops that are placed inside each other (Liberty & MacDonald, 2009; Sempf, Sphar, & Davis, 2010). This makes elaborate calculations possible, as well as looping through nested arrays, lists, and dictionaries.

With a nested loop, the inner loop runs to completion for each iteration of the outer loop (Liberty & MacDonald, 2009; Sempf et al., 2010). This behaviour adds an extra dimension to our loop. Now instead of simply going through a list’s length, we can also loop through its depth.

To clarify, the inner and outer loop terms refer to different parts of a nested loop:

Terminology of nested loops in C#
Sometimes when we have a lot of loops inside each other, the first loop is called the outermost loop. And the most deeply embedded one the innermost loop.

# Quick example: nested for loop in C#
Here’s a quick nested loop example:

int rows = 2, columns = 4;

// Make a rectangular array
int[,] recArray = new int[rows, columns];

// Loop over each row and column
for (int i = 0; i < rows; i++)
{
    for (int j = 0; j < columns; j++)
    {
        recArray[i, j] = i + j;
    }
}
Here we have a nested for loop. The outer for loop goes from 0 up to 2 (the value of the rows variable). For each of those loop cycles, the inner loop goes from 0 to (but not including) 4 (columns). This fills a 2x4 array. That is, each cycle of the outer loop creates a row, and inner loop then fills the columns of that row.

Note that outer loops cannot access the loop variables of inner loops. In our example above, the outer loop – which uses the i variable – cannot look up the j variable. The other way around does work: the inner loop can access the outer loop’s i variable.

Now that we know what nested loops are, let’s look at some more C# examples.

# Code a foreach nested loop in C#
A foreach loop easily loops through all values that a collection has. With this loop we don’t handle loop indexes, and neither have to update the loop variable.

The default pattern of a nested foreach loop is:

foreach (var collection in nestedCollections)  // Outer loop
{
    // Code that should run for each collection

    foreach (var item in collection)  // Inner loop
    {
        // Code that should run for each item
    }
}
There are two foreach loops here. The outer loop goes through each collection in our list of nested collection (nestedCollections). During each of those loop cycles, the collection variable refers to a single one of those nested collections.

The inner foreach loop then processes each item for every collection in that nested collection. That handle each single item that nestedCollections has.

We can use the same pattern to run through two separate collections. That way for each loop cycle of the first collection, we process another collection in its entirety. This is how we for instance match the value of one list with the value in another list:

foreach (var itemA in mainCollection)  // Outer loop
{
    // Code that should run for each item in the main collection

    foreach (var itemB in otherCollection)  // Inner loop
    {
        // Code that can compare every single
        // `itemA` value against all values in `otherCollection`
    }
}
# Example: code a nested foreach loop in C#
The program below shows how a nested foreach loop works in practice. The program first goes through a list of domain extensions (like .net and .com). An inner loop then matches each extension against a domain name. The result is a table with domain extensions and example domains.

The program’s full code is:

using System;

class Kodify_Example
{
    static void Main()
    {
        string[] extensions = { ".com", ".org", ".net"};
        string[] domains = { "github.com", "twitter.com", "bitbucket.org",
            "signal.org", "windows.net", "ghacks.net"  };

        // Loop through all extensions
        foreach (string extension in extensions)
        {
            Console.Write("{0} | \t", extension);

            // Print domains that match the web extension
            foreach (string domain in domains)
            {
                if (domain.EndsWith(extension))
                {
                    Console.Write(domain + "\t");
                }
            }

            Console.Write("\n");
        }
    }
}
The Main() method we make two arrays with string values. The first, extensions, has three different top-level domain names. The other, domains, contains 6 example websites.

Then we make a nested loop. The outer foreach loop goes through the extensions array. With the extension loop variable we fetch a single element from that array with each pass through the loop.

Inside this loop we first print the domain extension with the Console.Write() method. Then we make a second, nested loop. This foreach loop goes through each domain in the domains array. The loop’s domain string variable represents one website domain.

Because our nested loop goes through all websites for each domain extension, we can match a particular top-level domain (like .net) with an example website (windows.net). That’s exactly what the if statement does inside the inner loop.

There we check if the domain we loop over (domain) ends with (EndsWith()) the top-level domain extension (the outer loop’s extension variable). When it does, the if statement’s code outputs that domain with Console.Write().

Here’s how that generated output looks:

.com |  github.com      twitter.com
.org |  bitbucket.org   signal.org
.net |  windows.net     ghacks.net
# Creating nested loops with C#’s for loop
A for loop easily counts from one value to another. This way we loop over collections (like arrays and lists) and perform calculations. With for loops inside each other, even more program behaviour is possible.

Here’s how nested for loops look like:

for (int i = 0; i < 10; i++)  // Outer loop
{
    // Code here executes once
    // for each outer loop cycle

    for (int j = 0; j < 10; j++)  // Inner loop
    {
        // The inner loop runs to completion
        // for each loop cycle of the outer loop
    }
}
The outer for loop has the i variable go from 0 to 10. During each of those loop cycles we run another for loop. This one has a j variable that also goes from 0 up to 10. For each cycle of the outer loop, the inner loop repeats 10 times.

# Example: program a nested for loop in C#
Let’s see how a nested for loop works in practice. The console application below has a nested loop go through two arrays. One contains domain extensions (like .com). The other has domain names (github.com). Inside the loop we match each extension with its domain names.

The program’s code is:

using System;

class Kodify_Example
{
    static void Main()
    {
        string[] extensions = { ".com", ".org", ".net"};
        string[] websites = { "github.com", "twitter.com", "bitbucket.org",
            "signal.org", "windows.net", "ghacks.net"  };

        // Go through all extensions
        for (int i = 0; i < extensions.Length; i++)
        {
            Console.Write("{0} | \t", extensions[i]);

            // And print those domains that match the extension
            for (int j = 0; j < websites.Length; j++)
            {
                if (websites[j].EndsWith(extensions[i]))
                {
                    Console.Write(websites[j] + "\t");
                }
            }

            Console.Write("\n");
        }
    }
}
We make two arrays in Main(). The first, extensions, has three domain name extensions. The other, websites, has six domain names.

To process those values we make a nested loop. The outer loop is a for loop that iterates from 0 until the number of elements in our first array (extensions.Length). After each loop cycle we increase that i loop variable with one (i++). Inside this loop the Console.Write() method outputs the current domain extension.

There we also make another for loop. This inner loop goes through each element in the websites array. For that we make the j variable, and continue for as long as that variable is less than the array’s length (websites.Length). After each loop cycle we increase that variable with one (j++).

That inner loop has an if statement. This checks if the current website we loop over (websites[j]) ends with (EndsWith()) the domain extension that the outer loop iterates over (extensions[i]). When that’s the case, we print the current website with Console.Write(). This way we match the domain names and their extension.

Here’s how that output looks:

.com |  github.com      twitter.com
.org |  bitbucket.org   signal.org
.net |  windows.net     ghacks.net
# Make nested loops with C#’s while loop
With a while loop we repeat code as long as a condition remains true. We can also translate that behaviour to nested loops. That way we can handle data and advanced calculations.

Here’s how a nested while loop can look:

while (conditionA)
{
    // Code here executes for each outer loop cycle

    while (conditionB)
    {
        // The inner loop's code runs till
        // completion for each outer loop cycle

        conditionB = ...
    }

    // Change loop condition at some point
    conditionA = ...
}
The outer while loop goes on for as long as conditionA tests true. Each time it does, the loop’s code executes. There we have another while loop. That inner loop runs based on conditionB.

When that condition is true, the inner loop executes. When it becomes false, the inner loop ends and the outer loop continues. Then with the next outer loop cycle the inner loop starts again.

# Example: make a nested loop with the while loop
The example program below has a nested while loop process two arrays. The first contains domain extensions. The second has domain names. The program’s goal is to match domain extensions (like .org) with website domains (bitbucket.org).

The code of this console application is:

using System;

class Kodify_Example
{
    static void Main()
    {
        string[] extensions = { ".com", ".org", ".net"};
        string[] websites = { "github.com", "twitter.com", "bitbucket.org",
            "signal.org", "windows.net", "ghacks.net"  };

        int i = 0;

        // Match website extensions with their domain names
        // Loop through the domain extensions
        while (i < extensions.Length)
        {
            Console.Write("{0} | \t", extensions[i]);

            // Then only print those domains with a matching extension
            int j = 0;
            while (j < websites.Length)
            {
                if (websites[j].EndsWith(extensions[i]))
                {
                    Console.Write(websites[j] + "\t");
                }
                j++;
            }

            Console.Write("\n");
            i++;
        }
    }
}
In Main() we first make two string arrays. The first, extensions, has top-level domain extensions. The other, websites, has domains for technology-related websites.

Then we declare and initialise the i variable. We use this one to control the outer loop. That while loop is what we make next. We have that loop continue for as long as i is less than (<) the length of the extensions array. That processes each of the three domain extensions.

Inside the loop we first output the top-level domain with Console.Write(). Then we look for websites that match that domain extension.

For that we first declare the j variable. With this variable we control the nested while loop, which we make next. This loop runs when that variable is less than the length of the websites array (websites.Length). For each outer loop cycle (the domain extension), this inner loop (with websites names) runs to completion.

The inner loop has an if statement. This one sees if the website we loop over (websites[j]) ends with (EndsWith()) the same domain extension as the outer loop’s variable (extensions[i]). When the current website indeed matches that domain, code inside the if statement outputs the website with the Console.Write() method. This way we match the domain extension output with the example websites.

After the if statement we’re still inside the inner loop. There we increase the j variable with one (j++). That makes the inner loop go through all array elements.

When the inner loop finishes, there are two statements left in the outer loop. We first have Console.Write() make a new line ("\n"). That ensures a proper output of all values. Then we increase the i loop variable with one (i++). That way the outer loop goes through all website extensions.

This is what the above example program outputs:

.com |  github.com      twitter.com
.org |  bitbucket.org   signal.org
.net |  windows.net     ghacks.net
LEARN MORE
Break out of nested C# loops
Skip loop cycles of nested C# loops
# Summary
Regular loops can handle a lot of situations. But with multiple collections, complex calculations, or nested collections, we need a nested loop.

A nested loop are one or more loops placed inside each other. That way the inner loop runs to completion for each loop cycle of the outer loop.

We can make a nested loop with loops of the same kind (like two for loops) or use different types. The most common are, however, two for or two foreach loops inside each other.

=============================
Nested For Loops -Bro Code
=============================
https://youtu.be/WFzLcZk137s

{{ Once we enter our Outer-for-loop we will immediately enter our Inner-for-loop in order to complete 1 iteration of the Outer-for-loop we have to finish all iterations of the Inner-for-loop & once we finish all iterations of the Inner-for-loop we can complete one iteration of the Outer-for-loop & during the next iteration we have to do it all over again So on the next iteration we have to complete all the iterations for the Inner-for-loop so this will display a rectangle made out of a certain symbol However there's one thing missing & I'll show you 4rows,5columns,@symbol So this ended up in 1 long row So after we complete our iterations for the Inner-for-loop we should probably move on to the next row kind of like a typewriter we finish one line then we move on to the next row So let's use an empty WriteLine statement just to move down to the next line Nested loop is really a loop inside another loop When you'll encounter it it really varies but they're used a lot in Sorting algorithms —Bro Code }} first iteration of outerloop then all iterations of innerloop then back to outerloop rinse repeat.
using System;
	
public class Program
{
	public static void Main()
	{
		Console.Write("How many rows?: ");
		int rows = Convert.ToInt32(Console.ReadLine());
		Console.Write("How many columns?: ");
		int columns = Convert.ToInt32(Console.ReadLine());
		Console.Write("What symbol?: ");
		string symbol = Console.ReadLine();
		for (int i = 0; i < rows; i++)
		{
			for (int j = 0; j < columns; j++)
			{
				Console.Write(symbol);
			}

			Console.WriteLine();
		}

		Console.ReadKey();
	}
}

=============================
Delegates -Wikiversity
=============================
https://en.wikiversity.org/wiki/C_Sharp

As the word suggests it delegates. It delegates the job to do an operation. In OOPS operations are called methods. So delegate is a type in c# which points to a method with a particular parameter list and return type. One can instantiate a delegate and associate it to a method/methods of similar signature and return type.

Delegates are best used as callbacks. Used to pass methods as arguments to other methods.

How to declare a delegate
    Delegates are declared with "delegate" keyword followed by return type and method signature.
    e.g: public delegate int MathOperation (int,int);

=============================
Lambda Expressions -Wikiversity
=============================
https://en.wikiversity.org/wiki/C_Sharp/Lambda

Introduction
Lambda expressions are one of the forms of anonymous methods in .Net, which can be used for passing as inputs for local functions or as an expression to execute inline. Lambda expressions are particularly helpful for writing LINQ query expressions.

Lambda expressions helps in simplifying the logical statements and looping statements. This is possible for enumerable types where we can use Lambda expressions instead of writing looping statements or logical statements in multiple execution lines making code look cleaner and simple.

Example
using System;
using System.Linq;

namespace Program
{
  class Program
  {
    public static void Main(string [] args) 
    {
      int[] myInteger = new int[] {1,2,3,4,5}; //Creates an integer array named myInteger and initializes it with 5 values(1, 2, 3, 4, 5). 1 is in index 0, 2 is in index 1, etc
      var getNumbers = from num in myInteger  where num > 1 select num;//similar to a SQL query. Return a collection of all numbers greater than one
     
       foreach(int number in getNumbers)//loop through that collection we just made.
       {
          Console.WriteLine(number);//2, 3, 4, 5
       }
       Console.ReadKey();
     }
  }
}
=============================
Loops -Wikiversity
=============================
https://en.wikiversity.org/wiki/C_Sharp/Loops

Lesson Goals
This lesson will focus on all types of loops in the flow of programming in C# via the console. At the end of this lesson you should be able to:
Understand how to use loops.
Understand the prerequisite condition of looping.
Explain the different types of loops and their specific use.
Understand the difference in various loops.
progammatically create collections that can be looped through.
Introduction
Probably in every programming language loops are there to run a specific block of code repetatively based on a specific exit condition. The exit conditon, which is nothing but a boolean expression, is checked every time before a new loop executes and it exits the loop if the condition returns false. In C# these are also present. Loops are productive, smart and clean way of writing code. In a garment factory there is only one person or machine who attach the labels to the garments one after another. You would not find as many labeler as the number of garments in the factory. The condition is, the labeler will work till there are no longer any garments available for labeling. This is a real life example of looping in action.
Types of Loops
There are mainly 4 types of loops in C#.
while loop
do loop
for loop
foreach loop
Loops can be nested as well.
While Loop
Here is the basic structure of While loop.
while(<boolean condition>)
{
 <execution step1>
 <execution step2>
 ...
 <execution stepn>
}
While loop executes a block of code (here execution step1 through execution stepn) repetatively as long as the given boolean condition returns true. Before each new run it checks the condition first and if true then only a new run begins else code flow moves below the loop. Here is an example,-
using System;
namespace WhileLoopApp
{
    class Program
    {
        static void Main()
        {
            int number = 0;
            while(number < 3)
            {
                Console.WriteLine(number);
                number ++;
            }
            Console.ReadLine();
        }
    }
}
Output
0
1
2
In the given example, while loop first checks if variable number is less than 3, which is the case here as number is initialized with 0. Code-flow moves into the while block and executes the first line and prints 0. On second line number value increments with 1. The new value is 1. On next run as number is still less than 3, again it prints number as 1. Similarly, third time it prints 2. Now after increment number value is 3. This makes the while condition false and flows out of the loop without executing the inner block of code.
Do Loop
Do loop or in other words Do-while loop is similar to while loop but the difference is it checks the boolean condition at the end of the execution block. That way, it is guaranteed to run at least once. On the other hand, since while loop validates the boolean condition at the begining of the execution block, there is no guarantee that the inner block of code will run, unless you programmatically do so. Here is the structure of do loop, -
do
{
 <execution step1>
 <execution step2>
 ...
 <execution stepn>
} while(<boolean condition>);
Please note, unlike while loop here you need to put that semi-colon at the end of the while statement.
The typical use of do loop is when you want to show some message or menu to the user and want some input after that. So that it runs at least once and based on the input the loop may or may not run again. Here is an example, -
using System;
namespace DoLoopApp
{
 class Program
 {
    public static void Main()
    {
        string myChoice;
        do
       {
            // Print A Menu
            Console.WriteLine("My Address Book\n");
            Console.WriteLine("A - Add New Address");
            Console.WriteLine("D - Delete Address");
            Console.WriteLine("M - Modify Address");
            Console.WriteLine("Q - Quit\n");
            Console.WriteLine("Choice (A,D,M or Q): ");
            // Retrieve the user's choice
            myChoice = Console.ReadLine();
            // Make a decision based on the user's choice
            switch(myChoice)
            {
                case "A":
                case "a":
                    Console.WriteLine("You want to add an address.");
                    // Put Address adding code here.
                    break;
                case "D":
                case "d":
                    Console.WriteLine("You want to delete an address.");
                    // Put Address deleting code here.
                    break;
                case "M":
                case "m":
                    Console.WriteLine("You want to modify an address.");
                    // Put Address modifying code here.
                    break;
                case "Q":
                case "q":
                    Console.WriteLine("Bye.");
                    break;
                default:
                    Console.WriteLine("{0} is not a valid choice", myChoice);
                    break;
            }
            // Pause to allow the user to see the results
            Console.Write("press Enter key to continue...");
            Console.ReadLine();
            Console.WriteLine();
        } while (myChoice != "Q" && myChoice != "q"); // Keep looping until the user wants to quit
    }
 }
}
It is a typical example of do loop.
For loop
First let us have a look at the structure of the for loop.
for (counter-initialization; counter-bound; counter-increment)
{
  <execution step1>
  <execution step2>
  ...
  <execution stepn>
}
Here are the steps of for loop,-
First counter-initialization happens. This is an one time operation for the life of the loop.
Then counter-bound gets checked. This is another boolean condition and as long as it evaluates to true code-flow moves to the next step. Else it will move out of the loop.
Now execution step1 through execution stepn gets performed.
Next counter-increment happens.
Again step-2 executes.
As you can see, for loops are useful when you know exactly how many times the looping should occur. Also, you must have noticed that the counter-bound gets checked before the execution steps gets executed. so, like while loop, for loop also executes zero or more times. Also note, all the expressions of the for loop are optional. Below is an infinite for loop example.
for (; ; )
{
    // ...
}
Now lets see a for loop in action, -
using System;
namespace ForLoopApp
{
 class Program
 {
    public static void Main()
    {
        for (int i=0; i < 20; i++)
        {
            if (i == 10)
                break;
            if (i % 2 == 0)
                continue;
            Console.Write("{0} ", i);
        }
        Console.ReadLine();
    }
 }
}
Output
1 3 5 7 9
The above example has one special thing. It has two disruptions in the otherwise smooth run of for loop execution block. As you have already learned about the branching statements the two if sections uses break and continue to breakaway from the execution block.
Foreach loop
This type of loop is typically used to iterate through a collection of objects. There are many .NET provided collection objects available for use, such as, Arraylist. The major difference between a for loop and a foreach loop is that, for loop repeats a block of code for a number of times, where as foreach loop repeats a block of code for each item in a collection of objects. Here is a structure of foreach, -
foreach (<''type''> <''iteration variable''> in <''list''>)
 {
    <''execution step 1''>
    <''execution step 2''>
    ...
    <''execution step n''>
 }
Here type is the datatype of each element that is there in the collection. The iteration variable is the meaningful name for each element. The list is the collection on which the iteration will happen. And there is these repeatable block of code from execution step 1 through execution step n.
Points to Remember: -
Not all collections can be iterated using foreach. In fact a collection has to have implementation of System.Collections.IEnumerable or System.Collections.Generic.IEnumerable(T) interface.
The in keyword and type definition is required.
While iterating through a collection using foreach, the collection is read only. This means any items in that collection can not be modified in the foreach execution block. However, if you are using custom types like collection class or structs then you can modify individual fields in that. More on this in later lessons.
Foreach in System Collections
Let's have a look at a simple example of a foreach loop using system defined collection object, an array.
using System;
namespace ForEachLoopApp
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] fibArray = new int[] { 0, 1, 1, 2, 3, 5, 8, 13 };
            foreach (int ele in fibArray)
            {
                System.Console.WriteLine(ele);
            }
            System.Console.ReadLine();
        }
    }
}
Output
0
1
1
2
3
5
8
13
Here we have an integer array populated with the first 8 numbers of Fibonacci Series. Then in the foreach loop we printed each element in each line. Here the looping is possible as the system defined collection array by default implements System.Collections.IEnumerable.
Foreach in Custom Collections
Usually custom collections do not support looping through foreach. Trying so will throw compile time error. So to enable foreach looping for a class we need to implement System.Collections.IEnumerable. Our class in initial form,-
using System;
namespace ForEachLoopApp
{
    class Splitter//:IEnumerable
    {
        private string[] elements;
        Splitter(string source, char[] delimiters)
        {
            // Parse the string into tokens:
            elements = source.Split(delimiters);
        }
        
        static void Main()
        {
            // Testing Tokens by breaking the string into tokens:
            Splitter f = new Splitter("This is C# Learning Lesson 8-Loops.", new char[] { ' ', '-' });
            foreach (string item in f)
            {
                System.Console.WriteLine(item);
            }
        }
    }
}
This throws compile time error, -
foreach statement cannot operate on variables of type 'ForEachLoopApp.Splitter' because 'ForEachLoopApp.Splitter' does not contain a public definition for 'GetEnumerator'
So now we need to implement System.Collections.IEnumerable.
using System.Collections;
namespace ForEachLoopApp
{
    class Splitter:IEnumerable
    {
        private string[] elements;
        Splitter(string source, char[] delimiters)
        {
            // Parse the string into Splitter:
            elements = source.Split(delimiters);
        }
        
        static void Main()
        {
            // Testing Tokens by breaking the string into Splitter:
            Splitter f = new Splitter("This is C# Learning Lesson 8-Loops.", new char[] { ' ', '-' });
            foreach (string item in f)
            {
                System.Console.WriteLine(item);
            }
            System.Console.ReadLine();
        }
        #region IEnumerable Members
        public IEnumerator GetEnumerator()
        {
            return new SplitterEnumerator(this);
        }
        #endregion
        // Inner class implements IEnumerator interface:
        private class SplitterEnumerator : IEnumerator
        {
            private int position = -1;
            private Splitter t;
            public SplitterEnumerator(Splitter t)
            {
                this.t = t;
            }
            #region IEnumerator Members
            public object Current
            {
                get
                {
                    return t.elements[position];
                }
            }
            public bool MoveNext()
            {
                if (position < t.elements.Length - 1)
                {
                    position++;
                    return true;
                }
                else
                {
                    return false;
                }
            }
            public void Reset()
            {
                position = -1;
            }
            #endregion
        }
    }
}
Output
This
is
C#
Learning
Lesson
8
Loops.
Here both the interfaces IEnumerable and IEnumerator are implemented. To avoid this hassle you can use of Generic Classes. There by default System.Collections.Generic.IEnumerable(T) is implemented and it will directly iterate through foreach loop.
Performance Tips
Since foreach iterates through objects of a collection, it is slower than for loop, which is looping based on counter. [1] Still sometimes you would have to use foreach over for.

{ C# Delegates (US YT):: https://youtu.be/EyR2AfLkwcA ervistrupja https://youtu.be/3ZfwqWl-YI0 codemonkey https://youtu.be/vOlLd2SsKM4 simplilearn https://youtu.be/KaxNwGA9fiY rawcoding https://youtu.be/R8Blt5c-Vi4?t=723 *iamtimcorey } threadsafe {{ The 4 types of Programming Language that are classified are: Procedural Programming Language. Functional Programming Language. Scripting Programming Language. Logic Programming Language. Object-Oriented Programming Language. }} {{ The seven steps of programming. Step 1: Define the Program Objectives. ... Step 2: Design the Program. ... Step 3: Write the Code. ... Step 4: Compile. ... Step 5: Run the Program. ... Step 6: Test and Debug the Program. ... Step 7: Maintain and Modify the Program. }} {{ Coder. Programmer. Developer. Codaholic. }} {{ -=crowdsourcing=- Getting help from a large group of people to finish something faster. -=cyberbullying=- Doing something on the internet, usually again and again, to make another personal feel angry, sad, or scared. -=digital citizen=- Someone who acts safely, responsibly, and respectfully online. -=decompose=- Break a problem down into smaller pieces. -=digital footprint=- The information about someone on the Internet. -=F.A.I.L=- First Attempt In Learning -=iteration=- A repetitive action or command typically created with programming loops. -=pixel=- Short for "picture element", the fundamental unit of a digital image, typically a tiny square or dot that contains a single point of color of a larger image. -=Object-oriented programming=- is centered around digital objects that contain functions and data. Data and code are representations of an object’s properties. This data structure allows for unique variables within the program. || OOP is a programming paradigm that allows for the independent modeling of data. Objects consist of both protocols and values. An example of an object-oriented language is JavaScript, C++, or Python. -=Class=- A class is one of the basic building blocks of a computer program. Programmers define classes that act as blueprints for creating objects in the code. The idea of a class is to group together related values and behavior. For example, in a social media app, there could be a class for a User. The User class holds reusable code and properties, such as name, picture, hobbies, and more. -=Agile software development=- is a set of practices that governs the way a team creates software programs. Agile development involves collaboration among cross-functional teams to build software efficiently. Each team within the Agile framework will work on its own piece of code that will become part of the final project. || Why Programmers Should Know About Agile Software Development Agile software development is a common software creation approach that’s used by many major tech firms. By dividing a project into smaller chunks, each programming team can write code more efficiently. Sprints provide developers with concise workloads and allows them to conduct a proper code review to ensure that each component is perfect. -=Asynchronous programming=- “out of sync” In simple terms is a technique that allows a program or application to continue its operation while waiting for other tasks to be completed. A typical example in web development is the ability of a website like Facebook to allow the user to, for example, read your post feed while the messenger chat is still loading. This technique is now widely used in modern websites and applications. -=Class (Object-oriented programming)=- In object-oriented programming, a class defines a structure for creating objects consisting of variables or attributes and functions or methods. Each of these objects is then called an “instance” of the class. -=Crawl=- Anything you look for you can find on Google, but how does Google know what each website contains? Well.. Google crawls each website from time to time to read its contents and store it in their databases so that you can later retrieve it. -=DevOps=- A set of practices, philosophies, and tools that combine software development (dev) and IT operations (ops) to increase the efficiency and speed at which teams and organizations can deliver applications and services. -=Event, Event Listener=- In certain situations, it is necessary to trigger actions after certain user or system interactions, e.g., the user moves the mouse, clicks on a button, the clock ticks a new second, etc. Those moments are called events, and an event listener is a connector that allows developers to plug custom logic or algorithms when one of these actions occurs. Note that different events will be available depending on the platform, software, tools, etc. -=Framework=- A framework is a set of tools, libraries, design, and structure that help developers build products. Not to be confused with a library (though it is quite common), a framework does not provide only functions and routines but also opinionates on how to solve certain problems. -=JWT=- JWT or JSON Web Token is a standard used to identify user identity between client and server. They contain information about the logged-in user, and it is transmitted between the FE and the BE, or even between different BE systems. The user information cannot be forged or altered as it is protected by encryption. Thus, it is a safe mechanism that enables it to become an industry standard. -=Kebab case=- Snake case is the practice of naming variables, functions, etc., by separating words with a dash (-). It is very common in URLs. E.g.: /gear-and-tools/. -=Pascal case=- Pascal case is the practice of naming variables, functions, etc., by capitalizing all words. It is very common to declare classes. E.g.: UserService. -=Snake case=- Snake case is the practice of naming variables, functions, etc., by separating words with an underscore (_). It is common in some programming languages like Python and JSON responses from APIs. E.g.: is_user_logged_in. -=Camel case=- Camel case is the practice of naming variables, functions, etc., by capitalizing all words except the first one. E.g.: isUserLoggedIn. -=NPM (Node package manager)=- NPM Is a CLI tool used by programmers to find and install tools, libraries, and frameworks to develop applications built in JavaScript / TypeScript. -=NPX=- Some NPM packages are not meant to be installed, for example, packages that allow you to set up a new project. We can use NPX to download the code and run the script without keeping it installed. -=Pair programming=- It is a technique in which two developers work together on one computer (or virtually, though it is not the same experience). It is common for junior developers to follow these practices with developers of higher seniority, but it is not the only case that can be fruitful. Senior developers can also benefit from this technique by sitting with other developers. I guess four eyes and two minds can really see and think better than the two individually. -=Parse=- It is the action of transforming data into a workable format. For example, when you retrieve data from an API, the data is transmitted as text (or string), even when the data represents a JSON object. If you want to work with that data, you must parse the string into an object. -=Plugin=- A plugin is a software, library, or module that can be added to another application, framework, or software with the end of increasing its functionality, security, or features. -=Repository (repo)=- Think of it as basically a folder that contains all the source files of a project (including its history of change), and it is stored in some location you can access to read those files. Very common when we talk about a git repository, meaning the allocated name for the project on a git server. -=Responsive Design=- When building applications or websites, we can’t ignore that nowadays, people will access them from different devices such as phones, tablets, or computers. Responsive design allows for developers to build software that adapts its contents to fit into the different screen sizes without building different applications for each. -=REST API=- Representational state transfer (REST) APIs are a way to transfer information over the HTTP protocol, following rules and conventions. -=SaaS (software as a service)=- It is a software licensing model in which software is licensed on a subscription and made available on the internet. -=Spaghetti code=- Spaghetti code is a term used to describe code that is very hard for humans to read and understand, mainly because of how the developer or developers wrote the code. It can be caused by different reasons, including changes in scope, the evolution of requirements, code written by multiple developers over long periods, lack of programming style rules, or developer experience. -=UX=- UX designs the user experience by thinking about how the user will interact with the software and making it pleasant and optimal for the target audience. -=Wireframe=- A website’s bare-bones structure can even be a sketch on a napkin. No fonts, colors, or images. This layout is the first step to testing the idea before content and design are added. -=Nested=- Functions or objects that are contained within another function or object. So, a function that exists entirely inside the directions of a separate function is nested. -=Client-Side=- Client-side is a popular term in web development. The Client-side refers to everything that an end user sees. It is quite literally the side that the clients get to see. On a web page, client-side refers to: Text Images Any other UI component visible/accessible to you Actions that your browser performs For example, the markup languages HTML and CSS are interpreted on the client side. This simply means your browser renders the web page. Opposition to the client-side is server-side. The server-side things happen remotely on a server and are inaccessible to the client. For example, when you log in to your favorite website, the authentication takes place server-side. }}

{{ Nested Loops
https://flylib.com/books/en/4.330.1.79/1/ http://www.cl72.org/070documents/C/c-primer.pdf http://spiro.fisica.unipd.it/~boschini/c/(Ebook)%20Sams%20-%20C%20%20Primer%20Plus%205Th%20Edition%202005.pdf https://zhjwpku.com/assets/pdf/books/C++.Primer.5th.Edition_2013.pdf

A nested loop is one loop inside another loop. A common use for nested loops is to display data in rows and columns. One loop can handle, say, all the columns in a row, and the second loop handles the rows. Listing 6.17 shows a simple example.

Listing 6.17. The rows1.c Program
/* rows1.c -- uses nested loops */
#include <stdio.h>
#define ROWS 6
#define CHARS 10
int main(void)
{
 int row;
 char ch;
 for (row = 0; row < ROWS; row++) /* line 10 */
 {
 for (ch = 'A'; ch < ('A' + CHARS); ch++) /* line 12 */
 printf("%c", ch);
 printf("\n");
 }
 return 0;
}

Running the program produces this output:
ABCDEFGHIJ
ABCDEFGHIJ
ABCDEFGHIJ
ABCDEFGHIJ
ABCDEFGHIJ
ABCDEFGHIJ

Program Discussion
The for loop beginning on line 10 is called an outer loop, and the loop beginning on line 12 is called an inner loop because it is inside the other loop. The outer loop starts with row having a value of 0 and terminates when row reaches 6. Therefore, the outer loop goes through six cycles, with row having the values 0 through 5. The first statement in each cycle is the inner for loop. This loop goes through 10 cycles, printing the characters A through J on the same line. The second statement of the outer loop is printf("\n");. This statement starts a new line so that the next time the inner loop is run, the output is on a new line.Note that, with a nested loop, the inner loop runs through its full range of iterations for each single iteration of the outer loop. In the last example, the inner loop prints 10 characters to a row, and the outer loop creates six rows.

A Nested Variation
In the preceding example, the inner loop did the same thing for each cycle of the outer loop. You can make the inner loop behave differently each cycle by making part of the inner loop depend on the outer loop. Listing 6.18, for example, alters the last program slightly by making the starting character of the inner loop depend on the cycle number of the outer loop. It also uses the new comment style and const instead of #define to help you get comfortable with both approaches.

Listing 6.18. The rows2.c Program
// rows2.c -- using dependent nested loops
#include <stdio.h>
int main(void)
{
 const int ROWS = 6;
 const int CHARS = 6;
 int row;
 char ch;
 for (row = 0; row < ROWS; row++)
 {
 for (ch = ('A' + row); ch < ('A' + CHARS); ch++)
 printf("%c", ch);
 printf("\n");
 }
 return 0;
}

Here's the output this time:
ABCDEF
BCDEF
CDEF
DEF
EF
F

Because row is added to 'A' during each cycle of the outer loop, ch is initialized in each row to one character later in the alphabet. The test condition, however, is unaltered, so each row still ends on F. This results in one fewer character being printed in each row. }}

 {{ https://flylib.com/books/en/4.330.1/ https://flylib.com/books/en/4.330.1.19/1/ https://www.computerhope.com/jargon/program.htm https://hackr.io/blog/programming-terms-definitions-for-beginners https://www.techgeekbuzz.com/blog/programming-terms/ https://onlinegrad.syracuse.edu/blog/coding-terms-for-beginners/ https://code.org/curriculum/docs/k-5/glossary https://careerkarma.com/blog/programming-terminology/ https://livecodestream.dev/post/programming-terms/ https://www.codingem.com/programming-glossary/ || https://dotnet.microsoft.com/en-us/learn/csharp https://www.learncs.org/ https://www.w3schools.com/cs/index.php https://www.codecademy.com/learn/learn-c-sharp https://www.tutorialsteacher.com/csharp https://www.javatpoint.com/c-sharp-tutorial https://www.programiz.com/csharp-programming https://www.tutorialspoint.com/csharp/index.htm https://www.youtube.com/watch?v=gfkTfcpWqAY c#1hr https://www.youtube.com/watch?v=GhQdlIFylQ8 c#4hrbeg https://www.youtube.com/watch?v=q_F4PyW8GTg c#7hr }}

					END OF ADHOC-CPP NOTES.
