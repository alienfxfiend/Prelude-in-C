Classes & Objects
Classes & Objects
Value & Reference Types
Class Example
Encapsulation
Constructors
Properties
Quiz
Module 1 Quiz
Code Project
Social Network
Arrays and Strings
Arrays
Using Arrays in Loops
Multidimensional Arrays
Jagged Arrays
Array Properties & Methods
Working with Strings
Quiz
Module 2 Quiz
Code Project
Words
More On Classes
Destructors
Static Members
Static Classes
this & readonly
Indexers
Operator Overloading
Quiz
Module 3 Quiz
Code Project
Dance
Inheritance & Polymorphism
Inheritance
Protected Members
Derived Class Constructor & Destructor
Polymorphism
Abstract Classes
Interfaces
Nested Classes
Namespaces
Quiz
Module 4 Quiz
Code Project
Drawing Application
Structs, Enums, Exceptions & Files
Structs
Enums
Exception Handling
Working with Files
Module 5 Quiz
Code Project
Robot-barman
Generics
Generic Methods
Generic Classes
Collections
Lists and BitArray
Stack & Queue
Dictionary & HashSet
Module 6 Quiz
Code Project
Coffee Time

######################################################################################
######################################################################################
##	endroughxfer-urldump #1#
##	<EOF><EOF> Intermediate C# (SoloLearn) Volume 1
######################################################################################
######################################################################################

===================================================================
++=====================++
++=====================++ Classes & Objects:: Classes & Objects
Classes 
As we have seen in the previous modules, built-in data types are used to store a single value in a declared variable. For example, int x stores an integer value in a variable named x.

In object-oriented programming, a class is a data type that defines a set of variables and methods for a declared object.

 For example, if you were to create a program that manages bank accounts, a BankAccount class could be used to declare an object that would have all the properties and methods needed for managing an individual bank account, such as a balance variable and Deposit and Withdrawal methods. 

A class is like a blueprint. It defines the data and behavior for a type. A class definition starts with the keyword class followed by the class name. The class body contains the data and actions enclosed by curly braces. 

class BankAccount
{
  //variables, methods, etc.
}
C#
The class defines a data type for objects, but it is not an object itself. An object is a concrete entity based on a class, and is sometimes referred to as an instance of a class.
===================================================================
Objects 
Just as a built-in data type is used to declare multiple variables, a class can be used to declare multiple objects. As an analogy, in preparation for a new building, the architect designs a blueprint, which is used as a basis for actually building the structure. That same blueprint can be used to create multiple buildings.

Programming works in the same fashion. We define (design) a class that is the blueprint for creating objects.

In programming, the term type is used to refer to a class name: We're creating an object of a particular type.

Once we've written the class, we can create objects based on that class. Creating an object is called instantiation.

An object is called an instance of a class.
===================================================================
Objects 
Each object has its own characteristics. Just as a person is distinguished by name, age, and gender, an object has its own set of values that differentiate it from another object of the same type.

The characteristics of an object are called properties. 

Values of these properties describe the current state of an object. For example, a Person (an object of the class Person) can be 30 years old, male, and named Antonio.

 

Objects aren't always representative of just physical characteristics. 

For example, a programming object can represent a date, a time, and a bank account. A bank account is not tangible; you can't see it or touch it, but it's still a well-defined object because it has its own properties.
===================================================================
++=====================++
++=====================++ Value & Reference Types
Value Types 
 

C# has two ways of storing data: by reference and by value.

The built-in data types, such as int and double, are used to declare variables that are value types. Their value is stored in memory in a location called the stack.

For example, the declaration and assignment statement int x = 10; can be thought of as: 

img-component
The value of the variable x is now stored on the stack.
===================================================================
Reference Types
Reference types are used for storing objects. For example, when you create an object of a class, it is stored as a reference type.

Reference types are stored in a part of the memory called the heap.

When you instantiate an object, the data for that object is stored on the heap, while its heap memory address is stored on the stack.

That is why it is called a reference type - it contains a reference (the memory address) to the actual object on the heap. 

img-component
As you can see, the p1 object of type Person on the stack stores the memory address of the heap where the actual object is stored.

Stack is used for static memory allocation, which includes all your value types, like x.

Heap is used for dynamic memory allocation, which includes custom objects, that might need additional memory during the runtime of your program.
===================================================================
++=====================++
++=====================++ Class Example
Example of a Class 
 

Let’s create a Person class: 

class Person
{
  int age;
  string name;
  public void SayHi()
  {
    Console.WriteLine("Hi");
  }
}
C#
The code above declares a class named Person, which has age and name fields as well as a SayHi method that displays a greeting to the screen.

You can include an access modifier for fields and methods (also called members) of a class. Access modifiers are keywords used to specify the accessibility of a member.

A member that has been defined public can be accessed from outside the class, as long as it's anywhere within the scope of the class object. That is why our SayHi method is declared public, as we are going to call it from outside of the class.

You can also designate class members as private or protected. This will be discussed in greater detail later in the course. If no access modifier is defined, the member is private by default.
===================================================================
Example of a Class
Now that we have our Person class defined, we can instantiate an object of that type in Main.

The new operator instantiates an object and returns a reference to its location:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person {
            int age;
            string name;
            public void SayHi() {
                Console.WriteLine("Hi");
            }
        }
        static void Main(string[] args)
        {
            Person p1 = new Person();
            p1.SayHi();
        }
    }
}
OUTPUT
Hi

The code above declares a Person object named p1 and then calls its public SayHi() method.

Notice the dot operator (.) that is used to access and call the method of the object.
===================================================================
Example of a Class
You can access all public members of a class using the dot operator. 

Besides calling a method, you can use the dot operator to make an assignment when valid. 

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Dog
        {
            public string name;
            public int age;
        }
        static void Main(string[] args)
        {
            Dog bob = new Dog();
            bob.name = "Bobby";
            bob.age = 3;
            
            Console.WriteLine(bob.age);
        }
    }
}
OUTPUT
3
===================================================================
Encapsulation 
Part of the meaning of the word encapsulation is the idea of "surrounding" an entity, not just to keep what's inside together, but also to protect it.

In programming, encapsulation means more than simply combining members together within a class; it also means restricting access to the inner workings of that class.

Encapsulation is implemented by using access modifiers. An access modifier defines the scope and visibility of a class member.

Encapsulation is also called information hiding.
===================================================================
Encapsulation 
C# supports the following access modifiers: public, private, protected, internal, protected internal.

As seen in the previous examples, the public access modifier makes the member accessible from the outside of the class. 

The private access modifier makes members accessible only from within the class and hides them from the outside.

protected will be discussed later in the course.
===================================================================
Encapsulation 
To show encapsulation in action, let’s consider the following example: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class BankAccount {
        private double balance=0;
        public void Deposit(double n) {
            balance += n;
        }
        public void Withdraw(double n) {
            balance -= n;
        }
        public double GetBalance() {
            return balance;
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            BankAccount b = new BankAccount();
            b.Deposit(199);
            b.Withdraw(42);
            Console.WriteLine(b.GetBalance());
        }
    }
}
OUTPUT
157

We used encapsulation to hide the balance member from the outside code. Then we provided restricted access to it using public methods. The class data can be read through the GetBalance method and modified only through the Deposit and Withdraw methods.

You cannot directly change the balance variable. You can only view its value using the public method. This helps maintain data integrity.

We could add different verification and checking mechanisms to the methods to provide additional security and prevent errors.

In summary, the benefits of encapsulation are:

- Control the way data is accessed or modified.

- Code is more flexible and easy to change with new requirements.

- Change one part of code without affecting other parts of code.
===================================================================
Constructors 
A class constructor is a special member method of a class that is executed whenever a new object of that class is created.

A constructor has exactly the same name as its class, is public, and does not have any return type.

For example:

class Person
{
  private int age;
  public Person()
  {
    Console.WriteLine("Hi there");
  }
}
C#
Now, upon the creation of an object of type Person, the constructor is automatically called.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person
        {
            private int age;
            public Person()
            {
                Console.WriteLine("Hi there");
            }
        }
        static void Main(string[] args)
        {
            Person p = new Person();
        }
    }
}
OUTPUT
Hi there

This can be useful in a number of situations. For example, when creating an object of type BankAccount, you could send an email notification to the owner.

The same functionality could be achieved using a separate public method. The advantage of the constructor is that it is called automatically.
===================================================================
Constructors 
Constructors can be very useful for setting initial values for certain member variables.

A default constructor has no parameters. However, when needed, parameters can be added to a constructor. This makes it possible to assign an initial value to an object when it's created, as shown in the following example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person
        {
            private int age;
            private string name;
            public Person(string nm)
            {
                name = nm;
            }
            public string getName()
            {
                return name;
            }
        }
        static void Main(string[] args)
        {
            Person p = new Person("David");
            Console.WriteLine(p.getName());
        }
    }
}
OUTPUT
David

Now, when the object is created, we can pass a parameter that will be assigned to the name variable.

Constructors can be overloaded like any method by using different numbers of parameters.
===================================================================
++=====================++
++=====================++ Properties
Properties 
As we have seen in the previous lessons, it is a good practice to encapsulate members of a class and provide access to them only through public methods.

A property is a member that provides a flexible mechanism to read, write, or compute the value of a private field. Properties can be used as if they are public data members, but they actually include special methods called accessors.

The accessor of a property contains the executable statements that help in getting (reading or computing) or setting (writing) a corresponding field. Accessor declarations can include a get accessor, a set accessor, or both. 

For example:

class Person
{
  private string name; //field

  public string Name //property
  {
    get { return name; }
    set { name = value; }
  }
}
C#
The Person class has a Name property that has both the set and the get accessors.

The set accessor is used to assign a value to the name variable; get is used to return its value.

value is a special keyword, which represents the value we assign to a property using the set accessor.

The name of the property can be anything you want, but coding conventions dictate properties have the same name as the private field with a capital letter.
===================================================================
Properties 
Once the property is defined, we can use it to assign and read the private member: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person
        {
            private string name;
            public string Name
            {
                get { return name; }
                set { name = value; }
            }
        }
        static void Main(string[] args)
        {
            Person p = new Person();
            p.Name = "Bob";
            Console.WriteLine(p.Name);
        }
    }
}

The property is accessed by its name, just like any other public member of the class.
===================================================================
Properties 
Any accessor of a property can be omitted. 

For example, the following code creates a property that is read-only: 

class Person
{
  private string name;
  public string Name
  {
    get { return name; }
  }
}
C#
A property can also be private, so it can be called only from within the class.
===================================================================
Properties 
 

So, why use properties? Why not just declare the member variable public and access it directly?

With properties you have the option to control the logic of accessing the variable. 

For example, you can check if the value of age is greater than 0, before assigning it to the variable: 

class Person
{
  private int age=0;
  public int Age
  {
    get { return age; }
    set {
      if (value > 0)
        age = value;
    }
  }
}
C#
You can have any custom logic with get and set accessors.
===================================================================
Auto-Implemented Properties
When you do not need any custom logic, C# provides a fast and effective mechanism for declaring private members through their properties.

For example, to create a private member that can only be accessed through the Name property's get and set accessors, use the following syntax: 

public string Name { get; set; }
C#
As you can see, you do not need to declare the private field name separately - it is created by the property automatically. Name is called an auto-implemented property. Also called auto-properties, they allow for easy and short declaration of private members.

We can rewrite the code from our previous example using an auto-property:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person
        {
            public string Name { get; set; }
        }
        static void Main(string[] args)
        {
            Person p = new Person();
            p.Name = "Bob";
            Console.WriteLine(p.Name);
        }
    }
}
===================================================================
++=====================++
++=====================++ Arrays and Strings:: Arrays
Arrays 
C# provides numerous built-in classes to store and manipulate data.

One example of such a class is the Array class.

An array is a data structure that is used to store a collection of data. You can think of it as a collection of variables of the same type.

For example, consider a situation where you need to store 100 numbers. Rather than declare 100 different variables, you can just declare an array that stores 100 elements.

To declare an array, specify its element types with square brackets: 

int[ ] myArray;
C#
This statement declares an array of integers.

Since arrays are objects, we need to instantiate them with the new keyword:

int[ ] myArray = new int[5];
C#
This instantiates an array named myArray that holds 5 integers.

Note the square brackets used to define the number of elements the array should hold.
===================================================================
Arrays & Loops 
 

It's occasionally necessary to iterate through the elements of an array, making element assignments based on certain calculations. This can be easily done using loops.

For example, you can declare an array of 10 integers and assign each element an even value with the following loop: 

int[ ] a = new int[10];
for (int k = 0; k < 10; k++) {
  a[k] = k*2;
}
C#
We can also use a loop to read the values of an array.

For example, we can display the contents of the array we just created:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] a = new int[10];
            for (int k = 0; k < 10; k++) {
                a[k] = k*2;
            }
            for (int k = 0; k < 10; k++) {
                Console.WriteLine(a[k]);
            }
        }
    }
}
OUTPUT
0
2
4
6
8
10
12
14
16
18

The variable k is used to access each array element.

The last index in the array is 9, so the for loop condition is k<10.
===================================================================
++=====================++
++=====================++ Using Arrays in Loops
Arrays & Loops 


It's occasionally necessary to iterate through the elements of an array, making element assignments based on certain calculations. This can be easily done using loops.

For example, you can declare an array of 10 integers and assign each element an even value with the following loop: 

int[ ] a = new int[10];
for (int k = 0; k < 10; k++) {
  a[k] = k*2;
}
C#
We can also use a loop to read the values of an array.

For example, we can display the contents of the array we just created:
=================================================================== Arrays & Loops 
It's occasionally necessary to iterate through the elements of an array, making element assignments based on certain calculations. This can be easily done using loops.

For example, you can declare an array of 10 integers and assign each element an even value with the following loop: 

int[ ] a = new int[10];
for (int k = 0; k < 10; k++) {
  a[k] = k*2;
}
C#
We can also use a loop to read the values of an array.

For example, we can display the contents of the array we just created:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] a = new int[10];
            for (int k = 0; k < 10; k++) {
                a[k] = k*2;
            }
            for (int k = 0; k < 10; k++) {
                Console.WriteLine(a[k]);
            }
        }
    }
}
OUTPUT
0
2
4
6
8
10
12
14
16
18

This will display the values of the elements of the array.

The variable k is used to access each array element.

The last index in the array is 9, so the for loop condition is k<10.
===================================================================
The foreach Loop 
 

The foreach loop provides a shorter and easier way of accessing array elements.

The previous example of accessing the elements could be written using a foreach loop: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] a = new int[10];
            for (int k = 0; k < 10; k++) {
                a[k] = k*2;
            }
            foreach (int k in a) {
                Console.WriteLine(k);
            }
        }
    }
}
OUTPUT
0
2
4
6
8
10
12
14
16
18

The foreach loop iterates through the array a and assigns the value of the current element to the variable k at each iteration of the loop. So, at the first iteration, k=a[0], at the second, k=a[1], etc.

The data type of the variable in the foreach loop should match the type of the array elements.

Often the keyword var is used as the type of the variable, as in: foreach (var k in a). The compiler determines the appropriate type for var.
===================================================================
Arrays 
The following code uses a foreach loop to calculate the sum of all the elements of an array: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] arr = {11, 35, 62, 555, 989};
            int sum = 0; 
            
            foreach (int x in arr) {
                sum += x;
            }
            Console.WriteLine(sum);
        }
    }
}
OUTPUT
1652

To review, we declared an array and a variable sum that will hold the sum of the elements.

Next, we utilized a foreach loop to iterate through each element of the array, adding the corresponding element's value to the sum variable.

The Array class provides some useful methods that will be discussed in the coming lessons.
=================================================================== Multidimensional Arrays
Multidimensional Arrays 
 
An array can have multiple dimensions. A multidimensional array is declared as follows:

type[, , … ,] arrayName = new type[size1, size2, …, sizeN];
C#
For example, let's define a two-dimensional 3x4 integer array:

int[ , ] x = new int[3,4];
C#
Visualize this array as a table composed of 3 rows and 4 columns:

img-component
Array indexing starts from 0.
===================================================================
Multidimensional Arrays 
 

We can initialize multidimensional arrays in the same way as single-dimensional arrays.

For example:

int[ , ] someNums = { {2, 3}, {5, 6}, {4, 6} };
C#
This will create an array with three rows and two columns. Nested curly brackets are used to define values for each row.

To access an element of the array, provide both indexes. For example someNums[2, 0] will return the value 4, as it accesses the first column of the third row.

Let's create a program that will display the values of the array in the form of a table.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ , ] someNums = { {2, 3}, {5, 6}, {4, 6} }; 
            for (int k = 0; k < 3; k++) {
                for (int j = 0; j < 2; j++) {
                    Console.Write(someNums[k, j]+" ");
                }
                Console.WriteLine();
            }
        }
    }
}
OUTPUT
2 3 
5 6 
4 6 

We have used two nested for loops, one to iterate through the rows and one through the columns.

The Console.WriteLine(); statement moves the output to a new line after one row is printed.

Arrays can have any number of dimensions, but keep in mind that arrays with more than three dimensions are harder to manage.
===================================================================
++=====================++
++=====================++ Jagged Arrays
Jagged Arrays
 

A jagged array is an array whose elements are arrays. So it is basically an array of arrays.

The following is a declaration of a single-dimensional array that has three elements, each of which is a single-dimensional array of integers:

int[ ][ ] jaggedArr = new int[3][ ];
C#
Each dimension is an array, so you can also initialize the array upon declaration like this:

int[ ][ ] jaggedArr = new int[ ][ ] 
{
  new int[ ] {1,8,2,7,9},
  new int[ ] {2,4,6},
  new int[ ] {33,42}
};
C#
You can access individual array elements as shown in the example below:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ][ ] jaggedArr = new int[ ][ ] 
            {
                new int[ ] {1,8,2,7,9},
                new int[ ] {2,4,6},
                new int[ ] {33,42}
            };
            int x = jaggedArr[2][1];
            Console.WriteLine(x);
        }
    }
}
OUTPUT
42

This accesses the second element of the third array.

A jagged array is an array-of-arrays, so an int[ ][ ] is an array of int[ ], each of which can be of different lengths and occupy their own block in memory.

A multidimensional array (int[,]) is a single block of memory (essentially a matrix). It always has the same amount of columns for every row.
===================================================================
++=====================++
++=====================++ Array Properties & Methods
Arrays Properties 
 

The Array class in C# provides various properties and methods to work with arrays. 

For example, the Length and Rank properties return the number of elements and the number of dimensions of the array, respectively. You can access them using the dot syntax, just like any class members:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] arr = {2, 4, 7};
            
            Console.WriteLine(arr.Length); 
            
            Console.WriteLine(arr.Rank); 
        }
    }
}
OUTPUT
3
1

The Length property can be useful in for loops where you need to specify the number of times the loop should run.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] arr = {2, 4, 7};
            for(int k=0; k<arr.Length; k++) {
                Console.WriteLine(arr[k]);
            }
        }
    }
}
OUTPUT
3
1
===================================================================
Array Methods 
 

There are a number of methods available for arrays.

Max returns the largest value.
Min returns the smallest value.
Sum returns the sum of all elements.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] arr = { 2, 4, 7, 1};
            Console.WriteLine(arr.Max());
            Console.WriteLine(arr.Min());
            Console.WriteLine(arr.Sum());
        }
    }
}
OUTPUT
7
1
14

C# also provides a static Array class with additional methods. You will learn about those in the next module.
===================================================================
++=====================++
++=====================++ Working with Strings
Strings 
It’s common to think of strings as arrays of characters. In reality, strings in C# are objects.

When you declare a string variable, you basically instantiate an object of type String.

String objects support a number of useful properties and methods:

Length returns the length of the string.

IndexOf(value) returns the index of the first occurrence of the value within the string.

Insert(index, value) inserts the value into the string starting from the specified index.

Remove(index) removes all characters in the string from the specified index.

Replace(oldValue, newValue) replaces the specified value in the string.

Substring(index, length) returns a substring of the specified length, starting from the specified index. If length is not specified, the operation continues to the end of the string.

Contains(value) returns true if the string contains the specified value.


The examples below demonstrate each of the String members:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string a = "some text";
            Console.WriteLine(a.Length);
            //Outputs 9

            Console.WriteLine(a.IndexOf('t'));
            //Outputs 5

             a = a.Insert(0, "This is ");
            Console.WriteLine(a);
            //Outputs "This is some text"

            a = a.Replace("This is", "I am");
            Console.WriteLine(a);
            //Outputs "I am some text"

            if(a.Contains("some"))
                Console.WriteLine("found");
            //Outputs "found"

            a = a.Remove(4);
            Console.WriteLine(a);
            //Outputs "I am"

            a = a.Substring(2);
            Console.WriteLine(a);
            //Outputs "am"
        }
    }
}
OUTPUT
9
5
This is some text
I am some text
found
I am
am

You can also access characters of a string by its index, just like accessing elements of an array:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string a = "some text";
            Console.WriteLine(a[2]);
        }
    }
}
OUTPUT
9
5
This is some text
I am some text
found
I am
am

Indexes in strings are similar to arrays, they start from 0.
===================================================================
Working with Strings 
Let's create a program that will take a string, replace all occurrences of the word "dog" with "cat" and output the first sentence only. 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string text = "This is some text about a dog. The word dog appears in this text a number of times. This is the end.";
            text = text.Replace("dog", "cat");
            text = text.Substring(0, text.IndexOf(".")+1);
            
            Console.WriteLine(text);
        }
    }
}
OUTPUT
This is some text about a cat.

The code above replaces all occurrences of "dog" with "cat". After that it takes a substring of the original string starting from the first index until the first occurrence of a period character.

We add one to the index of the period to include the period in the substring.

C# provides a solid collection of tools and methods to work and manipulate strings. You could, for example, find the number of times a specific word appears in a book with ease, using those methods.
===================================================================
++=====================++
++=====================++ More On Classes:: Destructors
Destructors 
As constructors are used when a class is instantiated, destructors are automatically invoked when an object is destroyed or deleted. 

Destructors have the following attributes:

- A class can only have one destructor.

- Destructors cannot be called. They are invoked automatically.

- A destructor does not take modifiers or have parameters. 

- The name of a destructor is exactly the same as the class prefixed with a tilde (~).

For Example: 

class Dog
{
  ~Dog() 
  {
    // code statements
  }
}
C#
Destructors can be very useful for releasing resources before coming out of the program. This can include closing files, releasing memory, and so on.
===================================================================
Destructors 
Let’s include WriteLine statements in the destructor and constructor of our class and see how the program behaves when an object of that class is created and when the program ends: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Dog
        {
            public Dog() {
                Console.WriteLine("Constructor");
            }
            ~Dog() {
                Console.WriteLine("Destructor");
            }
        }
        static void Main(string[] args)
        {
            Dog d = new Dog();
        }
    }
}
OUTPUT
Constructor
Destructor

When the program runs, it first creates the object, which calls the constructor. The object is deleted at the end of the program and the destructor is invoked when the program's execution is complete.

This can be useful, for example, if your class is working with storage or files. The constructor would initialize and open the files. Then, when the program ends, the destructor would close the files.
===================================================================
++=====================++
++=====================++ Static Members
Static 
Now it's time to discuss the static keyword.

You first noticed it in the Main method's declaration: 

static void Main(string[] args)
C#
Class members (variables, properties, methods) can also be declared as static. This makes those members belong to the class itself, instead of belonging to individual objects. No matter how many objects of the class are created, there is only one copy of the static member.

For example:

class Cat {
  public static int count=0;
  public Cat() {
    count++;
  }
}
C#
In this case, we declared a public member variable count, which is static. The constructor of the class increments the count variable by one.

No matter how many Cat objects are instantiated, there is always only one count variable that belongs to the Cat class because it was declared static.
===================================================================
Static 
Because of their global nature, static members can be accessed directly using the class name without an object.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Cat {
            public static int count=0;
            public Cat() {
                count++;
            }
        }
        static void Main(string[] args)
        {
            Cat c1 = new Cat();
            Cat c2 = new Cat();
            Console.WriteLine(Cat.count);
        }
    }
}
OUTPUT
2

As you can see, we can access the static variable using the class name: Cat.count.

The count variable is shared between all Cat objects. For this class, each time an object is created, the static value is incremented. The program above demonstrates this when 2 is displayed after creating two objects of that class.

You must access static members using the class name. If you try to access them via an object of that class, you will generate an error.
===================================================================
Static Methods 
The same concept applies to static methods. 

For example: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Dog
        {
            public static void Bark() {
                Console.WriteLine("Woof");
            }
        }
        static void Main(string[] args)
        {
            Dog.Bark();
        }
    }
}
OUTPUT
Woof

Static methods can access only static members.

The Main method is static, as it is the starting point of any program. Therefore any method called directly from Main had to be static.
===================================================================
Static 
Constant members are static by definition.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class MathClass {
            public const int ONE = 1;
        }
        static void Main(string[] args)
        {
            Console.Write(MathClass.ONE);
        }
    }
}
OUTPUT
1

As you can see, we access the property ONE using the name of the class, just like a static member. This is because all const members are static by default.

Static Constructors
Constructors can be declared static to initialize static members of the class.

The static constructor is automatically called once when we access a static member of the class.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class SomeClass {
            public static int X { get; set; }
            public static int Y { get; set; }
            
            static SomeClass() {
                X = 10;
                Y = 20;
            }
        }
        static void Main(string[] args)
        {
            Console.WriteLine(SomeClass.X);
        }
    }
}
OUTPUT
1

The constructor will get called once when we try to access SomeClass.X or SomeClass.Y.
===================================================================
++=====================++
++=====================++ Static Classes
Static Classes 
An entire class can be declared as static.

A static class can contain only static members. 

You cannot instantiate an object of a static class, as only one instance of the static class can exist in a program.

Static classes are useful for combining logical properties and methods. A good example of this is the Math class.

It contains various useful properties and methods for mathematical operations. 

For example, the Pow method raises a number to a power:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(Math.Pow(2, 3));
        }
    }
}
OUTPUT
8

You access all members of the Math class using the class name, without declaring an object.

Tap next to learn about the available methods of the Math class.
===================================================================
Static Classes 
There are a number of useful static methods and properties available in C#: 

Math 
Math.PI the constant PI.

Math.E represents the natural logarithmic base e.

Math.Max() returns the larger of its two arguments.
Math.Min() returns the smaller of its two arguments.
Math.Abs() returns the absolute value of its argument.
Math.Sin() returns the sine of the specified angle.
Math.Cos() returns the cosine of the specified angle.
Math.Pow() returns a specified number raised to the specified power.
Math.Round() rounds the decimal number to its nearest integral value.
Math.Sqrt() returns the square root of a specified number.

Array 
The Array class includes some static methods for manipulating arrays: 

int[] arr = {1, 2, 3, 4};

Array.Reverse(arr);
//arr = {4, 3, 2, 1}

Array.Sort(arr);
//arr = {1, 2, 3, 4}
C#
String 
string s1 = "some text";
string s2 = "another text";

String.Concat(s1, s2); // combines the two strings

String.Equals(s1, s2); // returns false
C#
DateTime 
The DateTime structure allows you to work with dates.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(DateTime.Now);
            Console.WriteLine(DateTime.Today);
            
            Console.WriteLine(DateTime.DaysInMonth(2016, 2));
        }
    }
}
OUTPUT
01/12/2025 18:52:03
01/12/2025 00:00:00
29

The Console class is also an example of a static class. We use its static WriteLine() method to output to the screen, or the static ReadLine() method to get user input.

The Convert class used to convert value types is also a static class.
===================================================================
++=====================++
++=====================++ this & readonly
The this Keyword 
 

The this keyword is used inside the class and refers to the current instance of the class, meaning it refers to the current object.

One of the common uses of this is to distinguish class members from other data, such as local or formal parameters of a method, as shown in the following example: 

class Person {
  private string name;
  public Person(string name) {
    this.name = name;
  }
}
C#
Here, this.name represents the member of the class, whereas name represents the parameter of the constructor.

Another common use of this is for passing the current instance to a method as parameter: ShowPersonInfo(this);
===================================================================
The readonly Modifier 
The readonly modifier prevents a member of a class from being modified after construction. It means that the field declared as readonly can be modified only when you declare it or from within a constructor.

For example:

class Person {
  private readonly string name = "John"; 
  public Person(string name) {
    this.name = name; 
  }
}
C#
If we try to modify the name field anywhere else, we will get an error.

There are three major differences between readonly and const fields.

First, a constant field must be initialized when it is declared, whereas a readonly field can be declared without initialization, as in:

readonly string name; // OK
const double PI; // Error
C#
Second, a readonly field value can be changed in a constructor, but a constant value cannot.

Third, the readonly field can be assigned a value that is a result of a calculation, but constants cannot, as in:

readonly double a = Math.Sin(60); // OK
const double b = Math.Sin(60); // Error! 
C#
The readonly modifier prevents a member of a class from being modified after construction.
===================================================================
++=====================++
++=====================++ Indexers
Indexers 
An indexer allows objects to be indexed like an array. 

As discussed earlier, a string variable is actually an object of the String class. Further, the String class is actually an array of Char objects. In this way, the string class implements an indexer so we can access any character (Char object) by its index: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string str = "Hello World";
            char x = str[4];
            Console.WriteLine(x);
        }
    }
}
OUTPUT
o

Arrays use integer indexes, but indexers can use any type of index, such as strings, characters, etc.
===================================================================
Indexers 
Declaration of an indexer is to some extent similar to a property. The difference is that indexer accessors require an index. 

Like a property, you use get and set accessors for defining an indexer. However, where properties return or set a specific data member, indexers return or set a particular value from the object instance. 

Indexers are defined with the this keyword.

For example:

class Clients {
  private string[] names = new string[10];

  public string this[int index] {
    get {
      return names[index];
    }
    set {
      names[index] = value;
    }
  }
}
C#
As you can see, the indexer definition includes the this keyword and an index, which is used to get and set the appropriate value.

Now, when we declare an object of class Clients, we use an index to refer to specific objects like the elements of an array:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Clients {
            private string[] names = new string[10];
            public string this[int index] {
                get {
                    return names[index];
                }
                set {
                    names[index] = value;
                }
            }
        }
        static void Main(string[] args)
        {
            Clients c = new Clients();
            c[0] = "Dave";
            c[1] = "Bob";
            
            Console.WriteLine(c[1]);
        }
    }
}
OUTPUT
Bob

You typically use an indexer if the class represents a list, collection, or array of objects.
===================================================================
++=====================++
++=====================++ Operator Overloading
Operator Overloading 
Most operators in C# can be overloaded, meaning they can be redefined for custom actions.

For example, you can redefine the action of the plus (+) operator in a custom class.

Consider the Box class that has Height and Width properties: 

class Box {
  public int Height {get; set;}
  public int Width {get; set;}
  public Box(int h, int w) {
    Height = h;
    Width = w;
  }
}
static void Main(string[] args) {
  Box b1 = new Box(14, 3);
  Box b2 = new Box(5, 7);
}
C#
We would like to add these two Box objects, which would result in a new, bigger Box.

So, basically, we would like the following code to work:

 Box b3 = b1 + b2;
C#
The Height and Width properties of object b3 should be equal to the sum of the corresponding properties of the b1 and b2 objects.

This is achieved through operator overloading. Tap next to learn more!
===================================================================
Operator Overloading

Overloaded operators are methods with special names, where the keyword operator is followed by the symbol for the operator being defined. 

Similar to any other method, an overloaded operator has a return type and a parameter list.

For example, for our Box class, we overload the + operator: 

public static Box operator+ (Box a, Box b) {
  int h = a.Height + b.Height;
  int w = a.Width + b.Width;
  Box res = new Box(h, w);
  return res;
}
C#
The method above defines an overloaded operator + with two Box object parameters and returning a new Box object whose Height and Width properties equal the sum of its parameter's corresponding properties.

Additionally, the overloaded operator must be static.

Putting it all together:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Box {
            public int Height { get; set; }
            public int Width { get; set; }
            public Box(int h, int w) {
                Height = h;
                Width = w;
            }
            public static Box operator+(Box a, Box b) {
                int h = a.Height + b.Height;
                int w = a.Width + b.Width;
                Box res = new Box(h, w);
                return res;
            }
        }
        static void Main(string[] args)
        {
            Box b1 = new Box(14, 3);
            Box b2 = new Box(5, 7);
            Box b3 = b1 + b2;
            
            Console.WriteLine(b3.Height);
            Console.WriteLine(b3.Width);
        }
    }
}
OUTPUT
19
10

All arithmetic and comparison operators can be overloaded. For instance, you could define greater than and less than operators for the boxes that would compare the Boxes and return a boolean result. Just keep in mind that when overloading the greater than operator, the less than operator should also be defined.
===================================================================
++=====================++
++=====================++ Inheritance & Polymorphism:: Inheritance
Inheritance 
Inheritance allows us to define a class based on another class. This makes creating and maintaining an application easy.

The class whose properties are inherited by another class is called the Base class. The class which inherits the properties is called the Derived class.

For example, base class Animal can be used to derive Cat and Dog classes.

The derived class inherits all the features from the base class, and can have its own additional features. 

img-component
Inheritance allows us to define a class based on another class.
===================================================================
Inheritance 
Let's define our base class Animal: 

class Animal {
  public int Legs {get; set;}
  public int Age {get; set;}
}
C#
Now we can derive class Dog from it:

class Dog : Animal {
  public Dog() {
    Legs = 4;
  }
  public void Bark() {
    Console.Write("Woof");
  }
}
C#
Note the syntax for a derived class. A colon and the name of the base class follow the name of the derived class.

All public members of Animal become public members of Dog. That is why we can access the Legs member in the Dog constructor.

Now we can instantiate an object of type Dog and access the inherited members as well as call its own Bark method.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Animal {
            public int Legs {get; set;}
            public int Age {get; set;}
        }
        class Dog : Animal {
            public Dog() {
                Legs = 4;
            }
            public void Bark() {
                Console.Write("Woof");
            }
        }
        static void Main(string[] args)
        {
            Dog d = new Dog();
            Console.WriteLine(d.Legs);
            
            d.Bark();
        }
    }
}
OUTPUT
4
Woof

A base class can have multiple derived classes. For example, a Cat class can inherit from Animal.

Inheritance allows the derived class to reuse the code in the base class without having to rewrite it. And the derived class can be customized by adding more members. In this manner, the derived class extends the functionality of the base class.
===================================================================
Inheritance 
A derived class inherits all the members of the base class, including its methods. 

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person {
            public void Speak() {
                Console.WriteLine("Hi there");
            }
        }
        class Student : Person {
            int number;
        }
        static void Main(string[] args)
        {
            Student s = new Student();
            s.Speak();
        }
    }
}
OUTPUT
Hi there

We created a Student object and called the Speak method, which was declared in the base class Person.

C# does not support multiple inheritance, so you cannot inherit from multiple classes.

However, you can use interfaces to implement multiple inheritance. You will learn more about interfaces in the coming lessons.
===================================================================
++=====================++
++=====================++ Protected Members
protected 
Up to this point, we have worked exclusively with public and private access modifiers.

Public members may be accessed from anywhere outside of the class, while access to private members is limited to their class. 

The protected access modifier is very similar to private with one difference; it can be accessed in the derived classes. So, a protected member is accessible only from derived classes.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person {
            protected int Age {get; set;}
            protected string Name {get; set;}
        }
        class Student : Person {
            public Student(string nm) {
                Name = nm;
            }
            public void Speak() {
                Console.Write("Name: "+Name);
            }
        }
        static void Main(string[] args)
        {
            Student s = new Student("David");
            s.Speak();
        }
    }
}
OUTPUT
Name: David
===================================================================
sealed 
A class can prevent other classes from inheriting it, or any of its members, by using the sealed modifier.

For example: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        sealed class Animal {
            //some code
        }
        class Dog : Animal { } //Error
        
        static void Main(string[] args)
        {
            
        }
    }
}

In this case, we cannot derive the Dog class from the Animal class because Animal is sealed.

The sealed keyword provides a level of protection to your class so that other classes cannot inherit from it.
===================================================================
++=====================++
++=====================++ Derived Class Constructor & Destructor
Inheritance 
Constructors are called when objects of a class are created. With inheritance, the base class constructor and destructor are not inherited, so you should define constructors for the derived classes.

However, the base class constructor and destructor are being invoked automatically when an object of the derived class is created or deleted. 

Consider the following example:

class Animal {
  public Animal() {
    Console.WriteLine("Animal created");
  }
  ~Animal() {
    Console.WriteLine("Animal deleted");
  }
}
class Dog: Animal {
  public Dog() {
    Console.WriteLine("Dog created");
  }
  ~Dog() {
    Console.WriteLine("Dog deleted");
  }
}
C#
We have defined the Animal class with a constructor and destructor and a derived Dog class with its own constructor and destructor.

So what will happen when we create an object of the derived class? Tap next to find out!
===================================================================
Inheritance 
Let's create a Dog object: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Animal {
            public Animal() {
                Console.WriteLine("Animal created");
            }
            ~Animal() {
                Console.WriteLine("Animal deleted");
            }
        }
        class Dog: Animal {
            public Dog() {
                Console.WriteLine("Dog created");
            }
            ~Dog() {
                Console.WriteLine("Dog deleted");
            }
        }
        static void Main(string[] args)
        {
            Dog d = new Dog();
        }
    }
}
OUTPUT
Animal created
Dog created
Dog deleted
Animal deleted

Note that the base class constructor is called first and the derived class constructor is called next.

When the object is destroyed, the derived class destructor is invoked and then the base class destructor is invoked.

You can think of it as the following: The derived class needs its base class in order to work, which is why the base class constructor is called first.
===================================================================
++=====================++
++=====================++ Polymorphism
Polymorphism 
The word polymorphism means "having many forms". 

Typically, polymorphism occurs when there is a hierarchy of classes and they are related through inheritance from a common base class.

Polymorphism means that a call to a member method will cause a different implementation to be executed depending on the type of object that invokes the method. 

Simply, polymorphism means that a single method can have a number of different implementations.
===================================================================
Polymorphism 
Consider having a program that allows users to draw different shapes. Each shape is drawn differently, and you do not know which shape the user will choose. 

Here, polymorphism can be leveraged to invoke the appropriate Draw method of any derived class by overriding the same method in the base class. Such methods must be declared using the virtual keyword in the base class.

For example:

class Shape {
  public virtual void Draw() {
    Console.Write("Base Draw");
  }
}
C#
The virtual keyword allows methods to be overridden in derived classes.

Virtual methods enable you to work with groups of related objects in a uniform way.
===================================================================
Polymorphism 
Now, we can derive different shape classes that define their own Draw methods using the override keyword: 

class Circle : Shape {
  public override void Draw() {
    // draw a circle...
    Console.WriteLine("Circle Draw");
  }
}
class Rectangle : Shape {
  public override void Draw() {
    // draw a rectangle...
    Console.WriteLine("Rect Draw");
  }
}
C#
The virtual Draw method in the Shape base class can be overridden in the derived classes. In this case, Circle and Rectangle have their own Draw methods.

Now, we can create separate Shape objects for each derived type and then call their Draw methods:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Shape {
            public virtual void Draw() {
                Console.Write("Base Draw");
            }
        }
        class Circle : Shape {
            public override void Draw() {
                // draw a circle...
                Console.WriteLine("Circle Draw");
            }
        }
        class Rectangle : Shape {
            public override void Draw() {
                // draw a rectangle...
                Console.WriteLine("Rect Draw");
            }
        }
        static void Main(string[] args)
        {
            Shape c = new Circle();
            c.Draw();

            Shape r = new Rectangle();
            r.Draw();
        }
    }
}
OUTPUT
Circle Draw
Rect Draw

As you can see, each object invoked its own Draw method, thanks to polymorphism.
===================================================================
Polymorphism 
To summarize, polymorphism is a way to call the same method for different objects and generate different results based on the object type. This behavior is achieved through virtual methods in the base class.

To implement this, we create objects of the base type, but instantiate them as the derived type: 

Shape c = new Circle();
C#
Shape is the base class. Circle is the derived class.

So why use polymorphism? We could just instantiate each object of its type and call its method, as in:

Circle c = new Circle();
c.Draw();
C#
The polymorphic approach allows us to treat each object the same way. As all objects are of type Shape, it is easier to maintain and work with them. You could, for example, have a list (or array) of objects of that type and work with them dynamically, without knowing the actual derived type of each object.

Polymorphism can be useful in many cases. For example, we could create a game where we would have different Player types with each Player having a separate behavior for the Attack method.

In this case, Attack would be a virtual method of the base class Player and each derived class would override it.
===================================================================
++=====================++
++=====================++ Abstract Classes
Abstract Classes 
 
As described in the previous example, polymorphism is used when you have different derived classes with the same method, which has different implementations in each class. This behavior is achieved through virtual methods that are overridden in the derived classes.

In some situations there is no meaningful need for the virtual method to have a separate definition in the base class.

These methods are defined using the abstract keyword and specify that the derived classes must define that method on their own. 

You cannot create objects of a class containing an abstract method, which is why the class itself should be abstract.

We could use an abstract method in the Shape class: 

abstract class Shape {
   public abstract void Draw();
}
C#
As you can see, the Draw method is abstract and thus has no body. You do not even need the curly brackets; just end the statement with a semicolon.

The Shape class itself must be declared abstract because it contains an abstract method. Abstract method declarations are only permitted in abstract classes.

Remember, abstract method declarations are only permitted in abstract classes. Members marked as abstract, or included in an abstract class, must be implemented by classes that derive from the abstract class. An abstract class can have multiple abstract members.
===================================================================
Abstract Classes 
 

An abstract class is intended to be a base class of other classes. It acts like a template for its derived classes.

Now, having the abstract class, we can derive the other classes and define their own Draw() methods: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        abstract class Shape {
            public abstract void Draw();
        }
        class Circle : Shape {
            public override void Draw() {
                Console.WriteLine("Circle Draw");
            }
        }
        class Rectangle : Shape {
            public override void Draw() {
                Console.WriteLine("Rect Draw");
            }
        }
        static void Main(string[] args)
        {
            Shape c = new Circle();
            c.Draw();
        }
    }
}
OUTPUT
Circle Draw

Abstract classes have the following features:

- An abstract class cannot be instantiated.

- An abstract class may contain abstract methods and accessors.

- A non-abstract class derived from an abstract class must include actual implementations of all inherited abstract methods and accessors.

It is not possible to modify an abstract class with the sealed modifier because the two modifiers have opposite meanings. The sealed modifier prevents a class from being inherited and the abstract modifier requires a class to be inherited.
===================================================================
++=====================++
++=====================++ Interfaces
Interfaces 
An interface is a completely abstract class, which contains only abstract members.

It is declared using the interface keyword: 

public interface IShape
{
  void Draw();
}
C#
All members of the interface are by default abstract, so no need to use the abstract keyword.

Interfaces can have public (by default), private and protected members.

It is common to use the capital letter I as the starting letter for an interface name.

Interfaces can contain properties, methods, etc. but cannot contain fields (variables).
===================================================================
Interfaces 
When a class implements an interface, it must also implement, or define, all of its methods.

The term implementing an interface is used (opposed to the term "inheriting from") to describe the process of creating a class based on an interface. The interface simply describes what a class should do. The class implementing the interface must define how to accomplish the behaviors.

The syntax to implement an interface is the same as that to derive a class: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        public interface IShape {
            void Draw();
        }
        class Circle : IShape {
            public void Draw() {
                Console.WriteLine("Circle Draw");
            }
        }
        static void Main(string[] args)
        {
            IShape c = new Circle();
            c.Draw();
        }
    }
}
OUTPUT
Circle Draw

Note, that the override keyword is not needed when you implement an interface.

But why use interfaces rather than abstract classes?

A class can inherit from just one base class, but it can implement multiple interfaces!

Therefore, by using interfaces you can include behavior from multiple sources in a class.

To implement multiple interfaces, use a comma separated list of interfaces when creating the class: class A: IShape, IAnimal, etc.
===================================================================
Default Implementation 
Default implementation in interfaces allows to write an implementation of any method. This is useful when there is a need to provide a single implementation for common functionality.

Let's suppose we need to add new common functionality to our already existing interface, which is implemented by many classes. Without default implementation (before C# 8), this operation would create errors, because the method we have added isn't implemented in the classes, and we would need to implement the same operation one by one in each class. Default implementation in interface solves this problem.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        public interface IShape {
            void Draw();
            void Finish(){
                Console.WriteLine("Done!");
            }
        }
        class Circle : IShape {
            public void Draw() {
                Console.WriteLine("Circle Draw");
            }
        }
        static void Main(string[] args)
        {
            IShape c = new Circle();
            c.Draw();
            c.Finish();
        }
    }
}
OUTPUT
Circle Draw
Done!

We added the Finish() method with default implementation to our IShape interface and called it without implementing it inside the Circle class.

Methods with default implementation can be freely overridden inside the class which implements that interface.
===================================================================
++=====================++
++=====================++ Nested Classes
Nested Classes 
C# supports nested classes: a class that is a member of another class.

For example:

class Car {
  string name;
  public Car(string nm) {
    name = nm;
    Motor m = new Motor();
  }
  public class Motor {
    // some code
  }
}
C#
The Motor class is nested in the Car class and can be used similar to other members of the class.

A nested class acts as a member of the class, so it can have the same access modifiers as other members (public, private, protected).

Just as in real life, objects can contain other objects. For example, a car, which has its own attributes (color, brand, etc.) contains a motor, which as a separate object, has its own attributes (volume, horsepower, etc.). Here, the Car class can have a nested Motor class as one of its members.
===================================================================
++=====================++
++=====================++ Namespaces
Namespaces 
When you create a blank project, it has the following structure: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn {
  class Program {
    static void Main(string[] args) {
    }
  }
}
C#
Note, that our whole program is inside a namespace. So, what are namespaces?

Namespaces declare a scope that contains a set of related objects. You can use a namespace to organize code elements. You can define your own namespaces and use them in your program.

The using keyword states that the program is using a given namespace.

For example, we are using the System namespace in our programs, which is where the class Console is defined:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hi");
        }
    }
}
OUTPUT
Hi

Without the using statement, we would have to specify the namespace wherever it is used:

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            System.Console.WriteLine("Hi");
        }
    }
}
OUTPUT
Hi

The .NET Framework uses namespaces to organize its many classes. System is one example of a .NET Framework namespace.

Declaring your own namespaces can help you group your class and method names in larger programming projects.
===================================================================
++=====================++
++=====================++ Structs, Enums, Exceptions & Files:: Structs
Structs 
A struct type is a value type that is typically used to encapsulate small groups of related variables, such as the coordinates of a rectangle or the characteristics of an item in an inventory. The following example shows a simple struct declaration: 

struct Book {
  public string title;  
  public double price;
  public string author;
}
C#
Structs share most of the same syntax as classes, but are more limited than classes.

Unlike classes, structs can be instantiated without using a new operator.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        struct Book {
            public string title;  
            public double price;
            public string author;
        }
        static void Main(string[] args)
        {
            Book b;
            b.title = "Test";
            b.price = 5.99;
            b.author = "David";
            
            Console.WriteLine(b.title);
        }
    }
}
OUTPUT
Test

Structs do not support inheritance and cannot contain virtual methods.
===================================================================
Structs 
Structs can contain methods, properties, indexers, and so on. Structs cannot contain default constructors (a constructor without parameters), but they can have constructors that take parameters. In that case the new keyword is used to instantiate a struct object, similar to class objects.

For example: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        struct Point {
            public int x;
            public int y;
            public Point(int x, int y) {
                this.x = x;
                this.y = y;
            }
        }
        static void Main(string[] args)
        {
            Point p = new Point(10, 15);
            Console.WriteLine(p.x);
        }
    }
}
OUTPUT
10

Structs vs Classes 
In general, classes are used to model more complex behavior, or data, that is intended to be modified after a class object is created. Structs are best suited for small data structures that contain primarily data that is not intended to be modified after the struct is created. Consider defining a struct instead of a class if you are trying to represent a simple set of data.

All standard C# types (int, double, bool, char, etc.) are actually structs.
===================================================================
++=====================++
++=====================++ Enums
Enums 
The enum keyword is used to declare an enumeration: a type that consists of a set of named constants called the enumerator list.

By default, the first enumerator has the value 0, and the value of each successive enumerator is increased by 1.

For example, in the following enumeration, Sun is 0, Mon is 1, Tue is 2, and so on: 

enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat}; 
C#
You can also assign your own enumerator values:

enum Days {Sun, Mon, Tue=4, Wed, Thu, Fri, Sat};
C#
In the example above, the enumeration will start from 0, then Mon is 1, Tue is 4, Wed is 5, and so on. The value of the next item in an Enum is one increment of the previous value.

Note that the values are comma separated.

You can refer to the values in the Enum with the dot syntax.

In order to assign Enum values to int variables, you have to specify the type in parentheses:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat }; 
        static void Main(string[] args)
        {
            int x = (int)Days.Tue;
            Console.WriteLine(x);
        }
    }
}
OUTPUT
2

Basically, Enums define variables that represent members of a fixed set.

Some sample Enum uses include month names, days of the week, cards in a deck, etc.
===================================================================
Enums 
Enums are often used with switch statements.

For example: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        enum TrafficLights { Green, Red, Yellow };
        static void Main(string[] args)
        {
            TrafficLights x = TrafficLights.Red;
            switch (x) {
                case TrafficLights.Green:
                    Console.WriteLine("Go!");
                    break;
                case TrafficLights.Red:
                    Console.WriteLine("Stop!");
                    break;
                case TrafficLights.Yellow:
                    Console.WriteLine("Caution!");
                    break;
            }
        }
    }
}
OUTPUT
Stop!
===================================================================
++=====================++
++=====================++ Exception Handling
Exceptions 
An exception is a problem that occurs during program execution. Exceptions cause abnormal termination of the program. 

An exception can occur for many different reasons. Some examples:

- A user has entered invalid data.

- A file that needs to be opened cannot be found.

- A network connection has been lost in the middle of communications.

- Insufficient memory and other issues related to physical resources.

For example, the following code will produce an exception when run because we request an index which does not exist: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] arr = new int[] { 4, 5, 8 };
            Console.Write(arr[8]);
        }
    }
}

As you can see, exceptions are caused by user error, programmer error, or physical resource issues. However, a well-written program should handle all possible exceptions.
===================================================================
Handling Exceptions 
 

C# provides a flexible mechanism called the try-catch statement to handle exceptions so that a program won't crash when an error occurs.

The try and catch blocks are used similar to: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            try {
                int[] arr = new int[] { 4, 5, 8 };
                Console.Write(arr[8]);
            }
            catch(Exception e) {
                Console.WriteLine("An error occurred");
            }
        }
    }
}
OUTPUT
An error occurred

You can also catch and handle different exceptions separately. Tap next to learn more!
===================================================================
Handling Multiple Exceptions 
A single try block can contain multiple catch blocks that handle different exceptions separately. 

Exception handling is particularly useful when dealing with user input.

For example, for a program that requests user input of two numbers and then outputs their quotient, be sure that you handle division by zero, in case your user enters 0 as the second number. 

int x, y;
try {
  x = Convert.ToInt32(Console.Read());
  y = Convert.ToInt32(Console.Read());
  Console.WriteLine(x / y);
}
catch (DivideByZeroException e) {
  Console.WriteLine("Cannot divide by 0");
}
catch(Exception e) {
  Console.WriteLine("An error occurred");
}
C#
The above code handles the DivideByZeroException separately. The last catch handles all the other exceptions that might occur. If multiple exceptions are handled, the Exception type must be defined last.

Now, if the user enters 0 for the second number, "Cannot divide by 0" will be displayed.

If, for example, the user enters non-integer values, "An error occurred" will be displayed.

The following exception types are some of the most commonly used: FileNotFoundException, FormatException, IndexOutOfRangeException, InvalidOperationException, OutOfMemoryException.
===================================================================
finally 
An optional finally block can be used after the catch blocks. The finally block is used to execute a given set of statements, whether an exception is thrown or not. 

For example: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int result=0;
            int num1 = 8;
            int num2 = 4;
            try {
                result = num1 / num2;
            }
            catch (DivideByZeroException e) {
                Console.WriteLine("Error");
            }
            finally {
                Console.WriteLine(result);
            }
        }
    }
}
OUTPUT
2

The finally block can be used, for example, when you work with files or other resources. These should be closed or released in the finally block, whether an exception is raised or not.
===================================================================
++=====================++
++=====================++ Working with Files
Writing to Files 
 

The System.IO namespace has various classes that are used for performing numerous operations with files, such as creating and deleting files, reading from or writing to a file, closing a file, and more.

The File class is one of them. 

For example:

string str = "Some text";
File.WriteAllText("test.txt", str);
C#
The WriteAllText() method creates a file with the specified path and writes the content to it. If the file already exists, it is overwritten.

The code above creates a file test.txt and writes the contents of the str string into it.

To use the File class you need to use the System.IO namespace: using System.IO;
===================================================================
Reading from Files 
 

You can read the content of a file using the ReadAllText method of the File class: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string str = "Some text";
            File.WriteAllText("test.txt", str);
            
            string txt = File.ReadAllText("test.txt");
            Console.WriteLine(txt); 
        }
    }
}
OUTPUT
Some text

This will output the content of the test.txt file.

The following methods are available in the File class:

AppendAllText() - appends text to the end of the file.

Create() - creates a file in the specified location.

Delete() - deletes the specified file.

Exists() - determines whether the specified file exists.

Copy() - copies a file to a new location.

Move() - moves a specified file to a new location

All methods automatically close the file after performing the operation.
===================================================================
++=====================++
++=====================++ Generics:: Generic Methods
Generics 
Generics allow the reuse of code across different types.

For example, let's declare a method that swaps the values of its two parameters: 

static void Swap(ref int a, ref int b) {
  int temp = a;
  a = b;
  b = temp;
}
C#
Our Swap method will work only for integer parameters. If we want to use it for other types, for example, doubles or strings, we have to overload it for all the types we want to use it with. Besides a lot of code repetition, it becomes harder to manage the code because changes in one method mean changes to all of the overloaded methods.

Generics provide a flexible mechanism to define a generic type.

static void Swap<T>(ref T a, ref T b) {
  T temp = a;
  a = b;
  b = temp;
}
C#
In the code above, T is the name of our generic type. We can name it anything we want, but T is a commonly used name. Our Swap method now takes two parameters of type T. We also use the T type for our temp variable that is used to swap the values.

Note the brackets in the syntax <T>, which are used to define a generic type.
===================================================================
Generic Methods 
 

Now, we can use our Swap method with different types, as in: 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Swap<T>(ref T a, ref T b) {
            T temp = a;
            a = b;
            b = temp;
        }
        static void Main(string[] args)
        {
            int a = 4, b = 9;
            Swap<int>(ref a, ref b);
            Console.WriteLine(a+" "+b);
            
            string x = "Hello";
            string y = "World";
            Swap<string>(ref x, ref y);
            Console.WriteLine(x+" "+y);
        }
    }
}
OUTPUT
9 4
World Hello

When calling a generic method, we need to specify the type it will work with by using brackets. So, when Swap<int> is called, the T type is replaced by int. For Swap<string>, T is replaced by string.

If you omit specifying the type when calling a generic method, the compiler will use the type based on the arguments passed to the method.

Multiple generic parameters can be used with a single method.

For example: Func<T, U> takes two different generic types.
===================================================================
++=====================++
++=====================++ Generic Classes
Generic Classes 
 

Generic types can also be used with classes.

The most common use for generic classes is with collections of items, where operations such as adding and removing items from the collection are performed in basically the same way regardless of the type of data being stored. One type of collection is called a stack. Items are "pushed", or added to the collection, and "popped", or removed from the collection. A stack is sometimes called a Last In First Out (LIFO) data structure.

For example: 

class Stack<T> {
  int index=0;
  T[] innerArray = new T[100];
  public void Push(T item) {
    innerArray[index++] = item; 
  }
  public T Pop() {
    return innerArray[--index]; 
  }
  public T Get(int k) { return innerArray[k]; }
}
C#
The generic class stores elements in an array. As you can see, the generic type T is used as the type of the array, the parameter type for the Push method, and the return type for the Pop and Get methods.

Now we can create objects of our generic class:

Stack<int> intStack = new Stack<int>();
Stack<string> strStack = new Stack<string>();
Stack<Person> PersonStack = new Stack<Person>();
C#
We can also use the generic class with custom types, such as the custom defined Person type.

In a generic class we do not need to define the generic type for its methods, because the generic type is already defined on the class level.
===================================================================
Generic Classes 
 

Generic class methods are called the same as for any other object:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Stack<T> {
            int index=0;
            T[] innerArray = new T[100];
            public void Push(T item) {
                innerArray[index++] = item; 
            }
            public T Pop() {
                return innerArray[--index]; 
            }
            public T Get(int k) { return innerArray[k]; }
        }
        static void Main(string[] args)
        {
            Stack<int> intStack = new Stack<int>();
            intStack.Push(3);
            intStack.Push(6);
            intStack.Push(7);
            
            Console.WriteLine(intStack.Get(1));
        }
    }
}
OUTPUT
6
===================================================================
++=====================++
++=====================++ Collections
C# Collections 
 

A collection is used to group related objects. Unlike an array, it is dynamic and can also group objects. A collection can grow and shrink to accommodate any number of objects. Collection classes are organized into namespaces and contain built in methods for processing elements within the collection.

A collection organizes related data in a computer so that it can be used efficiently. 

Different kinds of collections are suited to different kinds of applications, and some are highly specialized to specific tasks. For example, Dictionaries are used to represent connections on social websites (such as Twitter, Facebook), queues can be used to create task schedulers, HashSets are used in searching algorithms, etc.

A collection typically includes methods to add, remove, and count objects. The for statement and the foreach statement are used to iterate through collections. Since a collection is a class you must first declare an instance of the class before you can add elements to that collection. 

For example:

List<int> li = new List<int>();
C#
Collections provide a more flexible way to work with groups of objects. Unlike arrays, the group of objects you work with can grow and shrink dynamically as the needs of the application change.
===================================================================
Generic Collections 
 

Generic collections are the preferred type to use as long as every element in the collection is of the same data type. Only desired data types can be added to a generic collection and this is enforced by using strong typing which reduces the possibility of errors.

The .NET Framework provides a number of generic collection classes, useful for storing and manipulating data.

The System.Collections.Generic namespace includes the following generic collections:

 - List<T>

 - Dictionary<TKey, TValue>

 - SortedList<TKey, TValue>

 - Stack<T>

 - Queue<T>

 - Hashset<T>

To access a generic collection in your code, you will need to include the statement: using Systems.Collections.Generic;

Non-Generic Collections 
 

Non-generic collections can store items that are of type Object. Since an Object data type can refer to any data type, you run the risk of unexpected outcomes. Non-generic collections may also be slower to access as well as execute.

The System.Collections namespace includes the following non-generic collections: 

 - ArrayList

 - SortedList

 - Stack

 - Queue

 - Hashtable

 - BitArray 

Because non-generic collections are error prone and less performant, it is recommended to always use generic collections from the System.Collections.Generic namespace if available and to avoid using legacy collections from the System.Collections namespace.
===================================================================
++=====================++
++=====================++ Lists and BitArray
List<T> 
  

A list is similar to an array, but the elements in a list can be inserted and removed dynamically.

The C# generic collection List<T> class requires all elements be of the same type T.

List<T> properties and methods include:

Count A property that gets the number of elements contained in the list.

Item[int i] Gets or sets the element in the list at the index i. Item is the indexer and is not required when accessing an element. You only need to use the brackets [] and the index value inside the brackets.

Add(T t) Adds an element t to the end of the list.

RemoveAt(int index) Removes the element at the specified position (index) from the list.

Sort() Sorts elements in the list.

Now let's try List<T>:

using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
		    List<int> li = new List<int>();
            li.Add(59);
            li.Add(72);
            li.Add(95);
            li.Add(5);
            li.Add(9);
            li.RemoveAt(1); // remove 72
            
            Console.Write("\nList: ");
            for (int x = 0; x < li.Count; x++)
                Console.Write(li[x] + " "); // 59  95  5  9
            li.Sort();
            Console.Write("\nSorted: ");
            for (int x = 0; x < li.Count; x++)
                Console.Write(li[x] + " "); // 5  9  59  95
		}
	}
}
OUTPUT

List: 59 95 5 9 
Sorted: 5 9 59 95 

Additional List<T> properties and methods are listed below. Try them out by adding them to the List<T> example code above.
Capacity - A property that gets the number of elements the list can hold before needing to be resized.
Clear() - Removes all the elements from the list.
TrimExcess() - Sets the capacity to the actual number of elements in the list. This is useful when trying to reduce memory overhead.
AddRange(IEnumerable coll) - Adds the elements of collection coll with elements of the same type as List<T> to the end of the list. IEnumerable is the collections interface that supports simple iteration over the collection.
Insert(int i, T t) - Inserts an element t at a specific index i in the list.
InsertRange(int i, IEnumerable coll) - Inserts the elements of a collection coll at a specified index i in the list. IEnumerable is the collections interface that supports simple iteration over the collection.
Remove(T t) - Removes the first occurrence of the object t from the list.
RemoveRange(int i, int count) - Removes a specified number of elements count from the list starting at a specified index i.
Contains(T t) - Returns true if the specified element t is present in the list.
IndexOf(T t) - Returns the index of the first occurrence of the element t in the list.
Reverse() - Reverses the order of the elements in the list.
ToArray() - Copies the elements of the list into a new array.

Run the code and see how it works!

Remember, you need to include the statement: using Systems.Collections.Generic; to use List<T>.
===================================================================
SortedList<K, V> 
 

A sorted list is a collection of key/value pairs that are sorted by key. A key can be used to access its corresponding value in the sorted list.

The C# generic collection SortedList<K, V> class requires all element key/value pairs to be of the same type K, V. Duplicate keys are not permitted, which ensures that every key/value pair is unique.

SortedList<K, V> properties include:

Count - Gets the number of key/value pairs contained in the sorted list.
Item[K key] - Gets or sets the value associated the specified key contained in the sorted list. Item is the indexer and is not required when accessing an element. You only need to use the brackets [] and the key, value.
Keys - Gets a sorted and indexed collection containing only the keys in the sorted list.
SortedList<K, V> methods include:
Add(K key, V value) - Adds an element with a specific key, value pair into the sorted list.
Remove(K key) - Removes the element with the specific key, value pair associated with the specified key from the sorted list.
Now let's try SortedList<K, V>:

using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
		    SortedList<string, int> sl = new SortedList<string, int>();

		    sl.Add("Solo", 59);
		    sl.Add("A", 95);
		    sl.Add("Learn", 72);
		    sl.Remove("A");
            
		    Console.WriteLine("Sorted List: ");
		    foreach (string s in sl.Keys)
		        Console.WriteLine(s + ": " + sl[s]);  // Learn: 72  Solo: 59
		    Console.WriteLine("\nCount: " + sl.Count);  // 2
		}
	}
}
OUTPUT
Sorted List: 
Learn: 72
Solo: 59

Count: 2

Here are additional SortedList<K, V> properties and methods:
Values - Gets a sorted and indexed collection of the values in the sorted list.
Clear() - Removes all the elements from the sorted list.
ContainsKey(K key) - Returns true when the specified key is present in the sorted list.
ContainsValue(V value) - Returns true when a specified value is present in the sorted list.
IndexOfKey(K key) - Returns the index of the specified key within the sorted list.
IndexOfValue(V value) - Returns the index of the specified value within the sorted list.
===================================================================
BitArray 
A bit array is a collection of bits. The value of a bit can be either 0 (off/false) or 1 (on/true).

Bit arrays compactly store bits. Most commonly, they are used to represent a simple group of boolean flags or an ordered sequence of boolean values. 

BitArray properties include:
Count -  Gets the number of bits in the bit array.
IsReadOnly - Gets a value indicating if the bit array is read only or not.
BitArray methods include:
Get(int i) - Gets the value of the bit at a specified position i in the bit array.
Set(int i, bool value) - Sets the bit at a specified position i to a specified value in the bit array.
SetAll(bool value) - Sets all the bits to a specified value in the bit array.
And(BitArray ba) - Performs the bitwise AND operation on the elements of the bit array object with a specified bit array ba.
Or(BitArray ba) - Performs the bitwise OR operation on the elements of the bit array and the specified bit array ba.
Not() - Inverts the bit values of the bit array.
Xor(BitArray ba) - Performs the bitwise XOR operation on the elements of the current bit array object and the elements in the specified bit array ba.

This example demonstrates some properties and methods of the BitArray class:

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
 {
    class Program
    {
        // Printing BitArray
        public static void PrintBarr(string name, BitArray ba)
        {
            Console.Write(name + " : ");
            for (int x = 0; x < ba.Length; x++)
                Console.Write(ba.Get(x) + " ");
            Console.WriteLine();
        }
        
        public static void Main(string[] args)
        {
            BitArray ba1 = new BitArray(4);
            BitArray ba2 = new BitArray(4);
            
            ba1.SetAll(true);
            ba2.SetAll(false);
            
            ba1.Set(2, false);
            ba2.Set(3, true);
            
            PrintBarr("ba1", ba1);
            PrintBarr("ba2", ba2);
            Console.WriteLine();
            
            PrintBarr("ba1 AND ba2", ba1.And(ba2));
            PrintBarr("    NOT ba2", ba2.Not());
        }
    }
}
OUTPUT
ba1 : True True False True 
ba2 : False False False True 

ba1 AND ba2 : False False False True 
    NOT ba2 : True True True False 
	
For example, BitArrays can be used in image processing to store the individual bits of a gray-scale image.	
===================================================================
++=====================++
++=====================++ Stack & Queue
Stack<T> 
 

A stack is a Last In, First Out (LIFO) collection of elements where the last element that goes into the stack will be the first element that comes out.

Inserting an element onto a stack is called pushing. Deleting an element from a stack is called popping. Pushing and popping can be performed only at the top of the stack.

Stacks can be used to create undo-redo functionalities, parsing expressions (infix to postfix/prefix conversion), and much more.

The C# generic collection Stack<T> class requires all elements to be of the same type T.

Stack<T> properties include:
Count - Returns the number of elements in the stack.
Stack<T> methods include:
Peek() - Returns the element at the top of the stack without removing it.
Pop() - Returns the element at the top of the stack and removes it from the stack.
Push(T t) - Inserts an element t at the top of the stack.
Now let's try Stack<T>:

using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
		    Stack<int> s = new Stack<int>();
            
		    s.Push(59);
		    s.Push(72);
		    s.Push(65);

		    Console.Write("Stack: ");
		    foreach (int i in s)
		        Console.Write(i + " ");  // 65  72  59
		    Console.Write("\nCount: " + s.Count);  // 3
            
		    Console.Write("\nTop: " + s.Peek());  // 65
		    Console.Write("\nPop: " + s.Pop());  // 65
            
		    Console.Write("\nStack: ");
		    foreach (int i in s)
		        Console.Write(i + " ");  // 72  59
		    Console.Write("\nCount: " + s.Count);  // 2
		}
	}
}
OUTPUT
Stack: 65 72 59 
Count: 3
Top: 65
Pop: 65
Stack: 72 59 
Count: 2

Here are additional Stack<T> methods:
Clear() - Removes all the elements from the stack.
Contains(T t) - Returns true when the element t is present in the stack.
ToArray() - Copies the stack into a new array.
===================================================================
Queue<T> 
 

A queue is a First In, First Out (FIFO) collection of elements where the first element that goes into a queue is also the first element that comes out.

Inserting an element into a queue is referred to as Enqueue. Deleting an element from a queue is referred to as Dequeue.
Queues are used whenever we need to manage objects in order starting with the first one in.
Scenarios include printing documents on a printer, call center systems answering people on hold people, and so on.
The C# generic collection Queue<T> class requires that all elements be of the same type T.
Queue<T> properties include:
Count - Gets the number of elements in the queue.
And methods include:
Dequeue() - Returns the object at the beginning of the queue and also removes it.
Enqueue(T t) - Adds the object t to the end of the queue.

Now let's try Queue<T>:

using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
            Queue<int> q = new Queue<int>();
            
            q.Enqueue(5);
            q.Enqueue(10);
            q.Enqueue(15);
            Console.Write("Queue: ");
            foreach (int i in q)
                Console.Write(i + " ");  // 5  10  15
            Console.Write("\nCount: " + q.Count);  // 3
            
            Console.Write("\nDequeue: " + q.Dequeue()); // 5
            
            Console.Write("\nQueue: ");
            foreach (int i in q)
                Console.Write(i + " ");  // 10  15
            Console.Write("\nCount: " + q.Count);  // 2
		}
	}
}
OUTPUT
Queue: 5 10 15 
Count: 3
Dequeue: 5
Queue: 10 15 
Count: 2

Here are additional Queue<T> methods:
Clear() - Removes all objects from the queue.
Contains(T t) - Returns true when the element t is present in the queue.
Peek() - Returns the object at the beginning of the queue without removing it.
ToArray() - Copies the queue into a new array.
===================================================================
++=====================++
++=====================++ Dictionary & HashSet
Dictionary<U, V> 
 

A dictionary is a collection of unique key/value pairs where a key is used to access the corresponding value. Dictionaries are used in database indexing, cache implementations, and so on.

The C# generic collection Dictionary<K, V> class requires all key/value pairs be of the same type K, V. Duplicate keys are not permitted to ensure that every key/value pair is unique.

Dictionary<K, V> properties include:
Count - Gets the number of key/value pairs contained in the dictionary.
Item[K key] - Gets the value associated with the specified key in the dictionary. Item is the indexer and is not required when accessing an element. You only need to use the brackets [] and key value.
Keys - Gets an indexed collection containing only the keys contained in the dictionary.
Dictionary<K, V> methods include:
Add(K key, V value) - Adds the key, value pair to the dictionary.
Remove(K key) - Removes the key/value pair related to the specified key from the dictionary.

Now let's try Dictionary<K, V>:

using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
		    Dictionary<string, int> d = new Dictionary<string, int>();
            d.Add("Uno", 1);
            d.Add("One", 1);
            d.Add("Dos", 2);
            d.Add("Deux", 2);
            d.Remove("One");  // Remove key-value pair One, 1
            d.Remove("Dos");  // Remove key-value pair Dos, 2
            
            Console.WriteLine("Dictionary: ");
            foreach (string s in d.Keys)
                Console.WriteLine(s + ": " + d[s]);  // Uno: 1  Deux: 2
            Console.WriteLine("\nCount: {0}", d.Count); // 2 
		}
	}
}
OUTPUT
Dictionary: 
Uno: 1
Deux: 2

Count: 2

In the above example, the dictionary d uses strings as it's keys and integers as the values.
Here are the additional Dictionary<K, V> properties and methods:
Values - Gets an indexed collection containing only the values in the dictionary.
Clear() - Removes all the key/value pairs from the dictionary.
ContainsKey(K key) - Returns true if the specified key is present in the dictionary.
ContainsValue(V value) - Returns true if the specified value is present in the dictionary.
===================================================================
HashSet<T> 
 

A hash set is a set of unique values where duplicates are not allowed.

C# includes the HashSet<T> class in the generic collections namespace. All HashSet<T> elements are required to be of the same type T. 

Hash sets are different from other collections because they are simply a set of values. They do not have index positions and elements cannot be ordered.

The HashSet<T> class provides high-performance set operations. HashSets allow fast lookup, addition, and removal of items, and can be used to implement either dynamic sets of items or lookup tables that allow finding an item by its key (e.g., finding the phone number of a person by the last name).

HashSet<T> properties include:
Count Returns the number of values in the hash set.
And methods include:
Add(T t) Adds a value (t) to the hash set.
IsSubsetOf(ICollection c) Returns true if the hash set is a subset of the specified collection (c).
Now let's try HashSet<T>:

using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
            HashSet<int> hs = new HashSet<int>();
            
            hs.Add(5);
            hs.Add(10);
            hs.Add(15);
            hs.Add(20);
            Console.Write("\nHashSet: ");
            foreach (int i in hs)
                Console.Write(i + " ");  // 5  10  15  20  *elements may be in any order
            Console.Write("\nCount: " + hs.Count);  // 4
            
            HashSet<int> hs2 = new HashSet<int>();
            hs2.Add(15);
            hs2.Add(20);
            Console.Write("\n{15, 20} is a subset of {5, 10, 15, 20}: " + hs2.IsSubsetOf(hs)); // True 
		}
	}
}
HashSet: 5 10 15 20 
Count: 4
{15, 20} is a subset of {5, 10, 15, 20}: True

Here are additional HashSet<T> methods:
Remove(T t) Removes the value (t) from the hash set.
Clear() Removes all the elements form the hash set.
Contains(T t) Returns true when a value (t) is present in the hash set.
ToString() Creates a string from the hash set.
sSupersetOf(ICollection c) Returns true if the hash set is a superset of the specified collection.
UnionWith(ICollection c) Applies set union operation on the hash set and the specified collection (c).
IntersectWith(ICollection c) Applies set intersection operation on the hash set and the specified collection (c).
ExceptWith(ICollection c) Applies set difference operation on the hash set and the specified collection (c).
===================================================================



Getting started
Your first C# Program
Multiple Statements
Delivery Service
Program Structure
That's the Price
Basic concepts
Everyone can code!
Variables
Drawing a Snowflake
Data Types
University Information System
Doing Math
Soccer Team
Quiz
Module 1 Quiz
Operators and Strings
Arithmetic Operators
Where are my points?
Assignment Operators
Hit the Target!
User Input
More on Strings
Star Triangle
Concatenation and Interpolation
Simple Calculator
Quiz
Module 2 Quiz
Decision Making
Comparison Operators
The if statement
Lights On!
The else if statement
Club Entrance
Logical Operators
Elore the Countries
The switch statement
Browser Theme
The Ternary Operator
Guess the word!
Quiz
Module 3 Quiz
Loops
The for loop
Odd Numbers
The while loop
Countdown
break and continue
Nearest Restaurant
Quiz
Module 4 Quiz
Methods
Methods
Loading...
Parameters and Arguments
Game Machine
Returning from Methods
Time to Dance!
Quiz
Module 5 Quiz

######################################################################################
######################################################################################
##	endroughxfer-urldump #1#
##	<EOF><EOF> Introduction to C++ - Volume 2
######################################################################################
######################################################################################


===================================================================
++=====================++
++=====================++ Getting Started:: Your First C# Program
Welcome to C#!
C# (pronounced See-Sharp) is one of the most popular modern programming languages.

C# is elegant and powerful. You can use it to create video games, web, mobile, database applications, and much, much more.

This course will get you coding your own C# programs in no time, in the most uncomplicated way, so you can solve real-world problems and challenges and create your own applications.
===================================================================
Coding
Humans use computer programs to communicate with machines. Without computer programs, we wouldn't have smartphones, websites, or even exploration in outer space.

img-component
Learning some coding can help you innovate and create different solutions to problems, giving you a competitive edge in this technology-driven world.

Everyone can learn to code with Sololearn.
===================================================================
Output
Most computer programs are designed to produce outputs. Examples of outputs are:

- "You've got a new message" notifications

- "Game Over" displayed on the screen when playing video games

- Your account balance when checking your online banking app.

The simplest output consists of a message displayed on the screen.
===================================================================
Output
Coders use outputs all the time to check that the computer is following the given instructions and fix problems with code.

The following line of code displays a message on the screen as an output:

Console.WriteLine("Welcome to C#!");
===================================================================
The Code Playground
Ready to write, run and test real code?

Open the Code Playground 👇. Then hit "run" to see the output on the screen.

using System;

public class Program
{
    public static void Main(string[] args)
    {
        Console.WriteLine("Welcome to the Code Playground");
    }
}
OUTPUT
Welcome to the Code Playground

You'll see other lines of code when you open the Code Playground. They are needed for the code to run without errors. You will learn everything about these lines in the upcoming lessons.
===================================================================
Lesson Takeaways
Awesome! You completed your first lesson 🚀. Remember the following important points:

💡 You can write code that generates outputs with the Console.WriteLine statement

💡 The Console.WriteLine instruction needs to be followed by parentheses

What's next?
In the next lesson, you will create code with multiple lines and different types of data.
===================================================================
Statements
Real computer programs can include thousands of lines of code.

A line of code is called a statement. A statement performs a specific task.

The output command is an example of a statement:

using System;

public class Program
{
    public static void Main(string[] args)
    {
        Console.WriteLine("Coding is an art");
    }
}
OUTPUT
Coding is an art

Each statement needs to end with a semicolon ;.
===================================================================
Multiple Statements
You can add as many statements (or lines of code) as you need.

The following piece of code consists of 2 statements. It outputs two messages in different lines.

using System;

public class Program
{
    public static void Main(string[] args)
    {
        Console.WriteLine("Name:");
        Console.WriteLine("Surname:");
    }
}
OUTPUT
Name:
Surname:

Remember your code will result in an error if you forget the semicolons ; at the end of the statements.
===================================================================
Text vs Numbers
Computers treat text and numbers differently. When printing text outputs, you need to enclose the text in double quotes. You don’t need quotes when outputting numbers.
using System;

public class Program
{
    public static void Main(string[] args)
    {
        Console.WriteLine("Points:");
        Console.WriteLine(500);
    }
}
OUTPUT
Points:
500

Your code will result in an error if you forget the quotes around the text.
===================================================================
C# is a case-sensitive language. This means that you need to pay attention to the correct input of uppercase and lowercase letters.

Drag and drop to write code that runs without errors.

.WriteLine("Score:");
Console.WriteLine(500);
===================================================================
Lesson Takeaways
Great work 🎯! You completed the lesson. You learned that:

💡 You can add multiple statements to your programs

💡 Text needs to be enclosed in quotes

💡 C# is a case-sensitive language.

What's next?
In the next lesson, you will learn about the structure of programs in C#.
===================================================================
++=====================++
++=====================++ Program Structure
C# Program
Hey!👋 Happy to see you here, at the next step of your coding journey!

In this lesson, we will break down the structure of C# programs and understand how they work.

All the code you need to create a valid C# program that outputs a simple line of text is the following:

using System;

public class Program
{
    public static void Main(string[] args)
    {
        Console.WriteLine("Hi there!");
    }
}
OUTPUT
Hi there!

You are already familiar with the Console.WriteLine method to create output, so let's learn about the other parts of the code.
===================================================================
Namespaces
Namespaces are used in C# to organize and provide code separation. They categorize different elements by putting related members in the same namespace.

The first line of the code defines the System namespace with the using keyword:

using System;
C#
The System is a standard namespace that contains different functionalities, such as the familiar Console.WriteLine method.

This means that the Console.WriteLine method is defined in the System namespace.
===================================================================
Namespaces
Namespaces are not mandatory in a C# program, but they do play an important role in writing cleaner code and managing larger projects.

Also, for example, not defining the System namespace will require writing System.Console.WriteLine instead of Console.WriteLine every time. So, basically, using a namespace is shorthand and makes the code more readable.

Here is the same code without the System namespace:

public class Program
{
    public static void Main(string[] args)
    {
        System.Console.WriteLine("Hi there!");
    }
}
OUTPUT
Hi there!

Pay attention to the dot . operator. It is used to access the members of namespaces or classes.
===================================================================
C# Program
The next line of code in our program defines a class called Program using the class keyword.

using System;

public class Program
C#
In C#, creating a class is mandatory for the program’s execution. You can call the class anything you want.

The public keyword is an access modifier that is used to declare the accessibility of the class and its members.

We will learn more about classes and access modifiers in more advanced modules. For now, just remember, that any C# program needs to have a class.
===================================================================
C# Program
The class opens and closes using curly brackets, like this:

public class Program
{

}
C#
Any code that we want to include in the class needs to go inside the brackets. They are used to define the scope of the class.
===================================================================
C# Program
Our program includes one more thing that we need to cover - the Main method inside the class:

using System;

public class Program
{
    public static void Main(string[] args)
    {
        Console.WriteLine("Hi there!");
    }
}
OUTPUT
Hi there!

In C#, each application has an entry point, or a starting point, which is a method called Main.

We will cover each keyword of the definition in later lessons when learning about methods. For now, remember that the Main method needs to be declared just as it was in the code above.
===================================================================
C# Program
Notice that the Main method, similar to the class, opens and closes with curly brackets.

public static void Main(string[] args)
{
    Console.WriteLine("Hi there!");
}
C#
The Main method contains the code that executes when we run our program.

In this case, the Console.WriteLine method will be executed.
===================================================================
C# Program
The Main method can contain multiple statements, for example:

using System;

public class Program
{
public static void Main(string[] args)
    {
        Console.WriteLine("Hey!");
        Console.WriteLine("You are doing great!");
        Console.WriteLine("Keep it on!");
    }
}
OUTPUT
Hey!
You are doing great!
Keep it on!

This is now a fully functioning C# program!✨
===================================================================
Lesson takeaways
You are fantastic! 🚀 You already know how to create a fully functioning C# program!

Here is the summary:

💡You can include a namespace in your program with the using keyword

💡In C#, creating a class is mandatory for the program’s execution. You can call the class anything you want.

💡Each application in C# has an entry point, or a starting point, which is a method called Main.

💡Classes and methods open and close with curly brackets {}, which define their scope.

What's next?
In the next lesson, you will learn another way to display messages, and how to explain what your code does directly inside it - which will make the people reading your code grateful!
===================================================================
++=====================++
++=====================++ Basic Concepts
Output
You're making great progress!

Let's quickly recall the Console.WriteLine method:

using System;

public class Program
{
public static void Main(string[] args)
    {
        Console.WriteLine("Hey!");
        Console.WriteLine("Happy to see you here!");
    }
}
OUTPUT
Hey!
Happy to see you here!

If you run the code you will see that the Console.WriteLine method prints each message from a new line.
===================================================================
The Console.Write method
There is another way to display messages in C# - the Console.Write method.

So, what's the difference? Check out the same code we just saw with the Console.Write method 👇:

using System;

public class Program
{
public static void Main(string[] args)
    {
        Console.Write("Hey!");
        Console.Write("Happy to see you here!");
    }
}
OUTPUT
Hey!Happy to see you here!

Yes! The Console.Write method doesn't set a new line for the next output.

There are other ways to set new lines in C#, you will learn about them very soon!
===================================================================
Comments
Comments are explanatory statements that you can include in a program to help the person reading your code.

A single-line comment starts with //:

using System;

public class Program
{
public static void Main(string[] args)
    {
        // outputs a wish
        Console.Write("Have a good day!");
    }
}
OUTPUT
Have a good day!

Comments don't affect how code is run and what it outputs.
===================================================================
Comments
You can also create multi-line comments.

They start with /* and end with */, making everything in between a comment.

using System;

public class Program
{
public static void Main(string[] args)
    {
        /*an important
        reminder
        for you */
        Console.WriteLine("Keep rocking!");
    }
}
OUTPUT
Keep rocking!

Code is for computers, while comments are for humans who read and work with the code.
===================================================================
Comments
You can also comment out lines of code, in case they are work-in-progress or you don't want to delete them yet:

using System;

public class Program
{
public static void Main(string[] args)
    {
        //Console.WriteLine(0);
        Console.WriteLine(1);
    }
}
OUTPUT
1

The commented lines of code will get ignored when you run the program.
===================================================================
Lesson takeaways
Awesome job! Keep it up!🚀

Here is the summary:

💡The Console.Write method displays messages but doesn't set a new line for the next output

💡Comments are statements that explain what the code is doing

💡single line comments start with //

💡multi-line comments start with /* and end with */

What's next?
In the next lesson, you will learn about another key concept in programming - variables!
===================================================================
++=====================++
++=====================++ Variables
Variables
Hey!👋 Great to see you here, continuing your coding journey!

Imagine you are developing a game 🕹️ where the points that the player scores are displayed many times. How do you handle so many values representing the same element? Do you update them in the code every time 😨? Of course not!

Enter variables - containers for storing values and working with them throughout the program. Let's see them in action!
===================================================================
Variables
Every variable has a type, which defines the type of the value it holds.

A variable can hold text, a number, a decimal, etc.

You are already familiar with text values - they are created using quotes:

"knowledge is power"
C#
Text in quotes is called a string.
===================================================================
Variables
Let's create a variable of type string:

string name;
C#
This code creates a variable called name of type string.

Now our variable name can hold string values.

In programming terms, the process of creating a variable is called declaration.
===================================================================
Variables
After creating the variable we can assign it a value. This is called initialization.

For example:

string name;
name = "James";
C#
Now the variable name has the value "James", which is text data.

The equal sign = is used to assign a value to the variable.
===================================================================
Variables
C# can make it even easier!

We can combine the declaration and assignment into one statement, like this:

string name = "James";
C#
This is handy when you already know the value for your variable and makes the code shorter and more readable.
===================================================================
Variables
After initializing a variable, we can output its value:

using System;

public class Program
{
public static void Main(string[] args)
    {
        string name = "James";
        Console.WriteLine(name);
    }
}

Open the Code Playground, modify the code to assign your name to the variable, and output it.
===================================================================
Variables
Variables can change their value throughout the program. That's why they are called variables 😀!

For example, the player of a game can change his name 👇:

using System;

public class Program
{
public static void Main(string[] args)
    {
        string name = "James";
        name = "Skywalker";

        Console.WriteLine(name);
    }
}
OUTPUT
Skywalker
===================================================================
Rules of Naming Variables
Let's talk about names.

There are several naming rules that you need to follow in C#:

variable names must begin with a letter or an underscore
variable names cannot contain spaces
variable names can only contain letters, numbers, or underscores
C# is case-sensitive, which means that, for example, Name and name variables are different
C# keywords can't be used as variable names. A keyword is a word that is part of the C# language
💡It's very important to use variable names that are descriptive, which makes the code more understandable.

using System;

public class Program
{
public static void Main(string[] args)
    {
        //results in error
        string name* = "James";
        
        Console.WriteLine(name*);
    }
}
===================================================================
Lesson Takeaways
Fantastic job!🚀 Variables are in your coding arsenal!

Let's summarize the stuff:

💡variables are containers for storing values
💡every variable has a type, which defines the type of the value it holds, for example, string
💡to create a variable you need to use its type and give that variable a name, for example, string country;
💡you can assign a variable a value with the equal sign =, for example, string country = "Spain";
💡variables can change their value throughout the program
💡remember to keep the rules of naming variables

What's next?
In the next lesson, you will learn what the difference between 5 and "5" is and what is true and false in programming. Can you guess? Data types!
===================================================================
Data Types
You are making great progress! 🌟

Another important concept in programming is data types.

The term 'data type' refers to the types of values a program can work with.

You are already familiar with strings:

using System;

public class Program
{
public static void Main(string[] args)
    {
        string name = "James";
        Console.WriteLine(name);
    }
}
OUTPUT
James
===================================================================
Strings
Everything in double quotes is a string, even numbers.

For example:

using System;

public class Program
{
public static void Main(string[] args)
    {
        Console.WriteLine("42");
    }
}
42

In the code above, 42 is a string, not a number, which means that the program will treat it as text consisting of two symbols: "4" and "2".
===================================================================
Characters
The char data type is used to store a single character. The character must be enclosed in single quotes:

using System;

public class Program
{
public static void Main(string[] args)
    {
        char label = 'A';
        Console.WriteLine(label);
    }
}
OUTPUT
A

If we enclose the same character A in double quotes, like this, "A",  it will be a string.
===================================================================
Types
Ok, then what about numbers?

In C#, the int type is used to store whole numbers (or integers, as we call them in programming).

using System;

public class Program
{
public static void Main(string[] args)
    {
        int age = 42;
        Console.WriteLine(age);
    }
}
OUTPUT
42

Now, the age variable of type int holds the value 42.
===================================================================
Decimals
To work with decimal numbers, use the type double:

using System;

public class Program
{
public static void Main(string[] args)
    {
        double weight = 95.4;
        Console.WriteLine(weight);
    }
}
OUTPUT
95.4
===================================================================
Decimals
C# has other two types for decimal numbers, float and decimal.

float uses less storage in memory, but is not as precise as the double type. The decimal, on the other hand, is more precise than the double, and accordingly uses more memory.

You need to use an f postfix when using the float type, and m postfix when using decimal.

Check it out 👇:

using System;

public class Program
{
public static void Main(string[] args)
    {
        float height = 1.82f;
        decimal weight = 92.8m;

        Console.WriteLine(height);
        Console.WriteLine(weight);
    }
}
OUTPUT
1.82
92.8

As a general rule: use float instead of double when memory usage is critical. If you need more precise computations, for example, when dealing with currency, use double or decimal.
===================================================================
Boolean
Very often, in programming, you will work with states or conditions, where you will need variables to check whether those states or conditions are true or false.

In these instances, we use the Boolean data type which can only take the values of true or false. To create a Boolean variable you need to use the bool keyword:

using System;

public class Program
{
public static void Main(string[] args)
    {
        bool isOpen = true;

        Console.WriteLine(isOpen);
    }
}
True

For example, the bool variable above👆 can show whether a shop is open or closed.
===================================================================
Lesson Takeaways
You are unstoppable!🚀 Yet another step taken 💪!

Here is a quick summary:

💡the term data type refers to the types of values a program can work with
💡everything in double quotes is a string, even numbers
💡the char data type is used to store a single character, which must be enclosed in single quotes
💡the int type is used to store whole numbers
💡to work with decimals use double, float or decimal data types
💡the bool data type is used for only one of two values: true or false

What's next?
In the next lesson, you will learn how C# can help you to perform mathematical operations. See you there! 👋
===================================================================
Doing Math
Let's talk about calculations! They are everywhere, including in programming, because computers are very good at them. So, they will be in your future programs too!

Let's get prepared for them! 😉

Performing a calculation in C# is simple, just enter it into the Console.WriteLine function:

using System;

public class Program
{
public static void Main(string[] args)
    {
        Console.WriteLine(5+4);
        Console.WriteLine(6-3);
    }
}
9
3

The + and - are arithmetic operators which are used for addition and subtraction accordingly.
===================================================================
Doing Math
Since you already know about variables, let's do some calculations that use them:

using System;

public class Program
{
public static void Main(string[] args)
    {
        int x = 5;
        int y = 4;

        Console.WriteLine(x+y);
    }
}
OUTPUT
9

This will output the sum of the two variables.
===================================================================
Doing Math
The result can be assigned to another variable, like this:

using System;

public class Program
{
public static void Main(string[] args)
    {
        int x = 5;
        int y = 4;

        int z = x+y;
        Console.WriteLine(z);
    }
}
OUTPUT
9

The variable z now holds the sum of the variables x and y.
===================================================================
Multiplication
Do you know how many times does a hummingbird's 🐦 wings beat per second? 80 times!

Let's calculate how much that will be in a minute:

using System;

public class Program
{
public static void Main(string[] args)
    {
        int beatsPerSecond = 80;
        int beatsPerMinute = 80*60;

        Console.WriteLine(beatsPerMinute);
    }
}
OUTPUT
4800

As you can see, the <b>*</b> operator is used for multiplication.

By the way, hummingbird’s heart beats over 1,263 beats per minute (a human's beats about 70 times per minute).
===================================================================
Division
The / operator divides one value by another.

The following program calculates how many products with the given price you can buy with the given amount:

using System;

public class Program
{
public static void Main(string[] args)
    {
        int amount = 54000;
        int price = 1300;
        int result = amount/price;

        Console.WriteLine(result);
    }
}
OUTPUT
41

In the example above, the result of the division equation will be a whole number, as int is used as the data type. 

If you work with decimal, you must use double, float or decimal data types.
===================================================================
Doing Math
You can perform multiple calculations within one statement:

using System;

public class Program
{
public static void Main(string[] args)
    {
        int x = 2;
        int y = 3;
        int z = 4;

        Console.WriteLine(x+y-z);
    }
}

OUTPUT
1
===================================================================
Doing Math
Just like in regular math, multiplication and division are calculated before addition and subtraction:

using System;

public class Program
{
public static void Main(string[] args)
    {
        int x = 2;
        int y = 3;
        int z = 4;

        //y*z will be calculated first
        Console.WriteLine(x+y*z);
    }
}
OUTPUT
14
===================================================================
Doing Math
To control precedence, use parentheses to indicate the order in which you want to perform operations, like this:

 using System;

public class Program
{
public static void Main(string[] args)
    {
        int x = 2;
        int y = 3;
        int z = 4;

        //x+y will be calculated first
        Console.WriteLine((x+y)*z);
    }
}
OUTPUT
20

Make sure to close all your parentheses.
===================================================================
Lesson Takeaways
You are unstoppable!🚀 This was the last lesson of this module, and you nailed it! 💪

Here is a quick summary:

💡you can do calculations directly in the Console.WriteLine method
💡+ , - , * , /  are arithmetic operators which perform calculations
💡you can perform multiple calculations within one statement
💡multiplication and division have higher precedence than addition and subtraction have
💡you can control precedence using parentheses

What's next?
In the next lesson, you will learn about other C# operators. Also, you will get a deeper understanding of strings. See you there!
=================================================================== Operators and Strings:: Arithmetic Operators
Arithmetic Operations
You are doing great!

Let's quickly recall some simple mathematical operations from previous lessons before learning new stuff:

using System;

public class Program
{
public static void Main(string[] args)
    {
        int x = 8;
        int y = 3;

        Console.WriteLine(x+y);//addition
        Console.WriteLine(x-y);//subtraction
        Console.WriteLine(x*y);//multiplication
        Console.WriteLine(x/y);//division
    }
}
OUTPUT
11
5
24
2
===================================================================
Remainder
Let's imagine you want to equally distribute 100 balls in boxes. Each box contains only 3 balls. How many balls will be left over?

In other words, we need to calculate the remainder of 100 divided by 3, which is done using the modulo operator %.

So, let's find the answer:

using System;

public class Program
{
public static void Main(string[] args)
    {
        int balls = 100;
        int ballsInBox = 3;

        int result = balls%ballsInBox;

        Console.WriteLine(result);
    }
}
OUTPUT
1

If the boxes could contain 5 balls, all 100 would be equally distributed in 20 boxes, and the remainder would be 0.
===================================================================
Increment
Good job! 😎 You are really close to being able to work well with math in C#!

Sometimes we need to repeatedly add 1 to a variable.

For example, when counting attempts in a game, or the number of clicks on a web page.

This can be done using the increment ++ operator:

using System;

public class Program
{
public static void Main(string[] args)
    {

        int points = 10;
        Console.Write("Your score: ");
        Console.WriteLine(points);
        
        //good shot!
        points++;

        Console.Write("Your score: ");
        Console.WriteLine(points);
    }
}
OUTPUT
Your score: 10
Your score: 11

Basically, points++ is shorthand for points = points+1.
===================================================================
Decrement
Similarly, the decrement -- operator can be used to subtract 1 from a variable:

using System;

public class Program
{
public static void Main(string[] args)
    {

        int points = 11;
        Console.Write("Your score: ");
        Console.WriteLine(points);
        
        //hit an ally
        points--;

        Console.Write("Your score: ");
        Console.WriteLine(points);
    }
}
OUTPUT
Your score: 11
Your score: 10

Remember that these operations can only be applied to variables, and applying this operation to numerical values will return an error.
===================================================================
Postfix and Prefix
The ++ or -- can be applied both before and after the variable. This is where it gets a bit tricky. Let's figure this out!

The postfix form returns the original value of the variable, and only then increments/decrements it.

using System;

public class Program
{
public static void Main(string[] args)
    {
        int x = 5;
        Console.WriteLine(x++);
        Console.WriteLine(x);
    }
}
OUTPUT
5
6

In the example above, the original value will be outputted, and then will be incremented.
===================================================================
Postfix and Prefix
The prefix form increments/decrements the value, and only then returns it.

using System;

public class Program
{
public static void Main(string[] args)
    {
        int x = 5;
        Console.WriteLine(++x);
    }
}
OUTPUT
6

In this case, the incremented value will be outputted.
===================================================================
Lesson Takeaways
Fantastic job! 🚀 Now you can complete arithmetic operations, and that's really cool!

Here is a quick summary:

💡modulo operator % is used to calculate the remainder of a division
💡you can use ++/-- operators to increment/decrement the value of a variable
💡increment and decrement operators can be used only with variables

What's next?
In the next lesson, you will learn about another type of operator in C# - assignment operators. 
===================================================================
++=====================++
++=====================++ Assignment Operators
Assignment Operators
Here we go! 👋

Let's learn about assignment operators, a very important type of operator which make working with variables much more convenient.

Assignment operators assign values to variables.

You already know one of them: when initializing a variable we use the = assignment operator to assign a value to it:

double weight = 75.5;
C#
===================================================================
Assignment Operators
It's time for some syntax sugar! C# has lots of it.

You can create different variables of the same type within one statement, separating them with commas:

using System;

public class Program
{
public static void Main(string[] args)
    {
        int x = 5, y = 6, z = 8;

        Console.WriteLine(x);
        Console.WriteLine(y);
        Console.WriteLine(z);
    }
}
OUTPUT
5
6
8
===================================================================
Assignment operators
Let's imagine you are creating a coin collector game. The game starts with a score of 100, and when the player collects a coin the score increases by 10.

In this case, you will write this code:

int score = 100;
score = score +10;
C#
But there is an easier way to do this. Keep going to see it!
===================================================================
Assignment operators
C# lets you write the code score = score + 10 more concisely, using the += operator.

Check it out 👇:

using System;

public class Program
{
public static void Main(string[] args)
    {
        int score = 100;
        score+=10;
        Console.WriteLine(score);
    }
}
OUTPUT
110

This operator is called addition assignment operator.
===================================================================
Assignment Operators
Best of all, this pattern can be followed for other arithmetic operators:

using System;

public class Program
{
public static void Main(string[] args)
    {
        int x = 15;
        x+=5; // x = x+5;
        Console.WriteLine(x);

        x-=5; // x = x-5;
        Console.WriteLine(x);

        x*=5; // x = x*5;
        Console.WriteLine(x);

        x/=5; // x = x/5;
        Console.WriteLine(x);

        x%=5; // x = x%5;
        Console.WriteLine(x);

    }
}
OUTPUT
20
15
75
15
0
===================================================================
Assignment Operators
And, of course, you can perform the same operations with two variables.

For example:

using System;

public class Program
{
public static void Main(string[] args)
    {
        double price = 50;
        double rate = 1.2;

        price*=rate;//price = price*rate;

        Console.WriteLine(price);
    }
}
OUTPUT
60
===================================================================
Lesson Takeaways
Amazing! 🚀 You’ve taken another big step forward!

Let's summarize what you've just learned:

💡we use the assignment operator = to assign a value to a variable
💡you can shorthand codes like x=x+5 with x+=5, and similar logic for all the other mathematical operations 

What's next?
In the next lesson, you will learn how to make our program interactive so you can talk to the user! 🤩
===================================================================
++=====================++
++=====================++ User Input
User Input
Welcome to the next stage of your journey!

Let's talk about interactivity. There are many situations when different programs ask for your input, which means that you talk to the program by passing a piece of information to it. It can be a nickname for a videogame 🎮, a username and a password 🔑 for your social network accounts, your address 📍 for delivery, etc.

Let's find out how this is done in C#!😎
===================================================================
User Input
Do you remember the Console class? Of course you do, since you use its WriteLine method to generate output each time.

Well, the Console class will help you with user input as well. Meet the Console.ReadLine method!🌟

The following code declares the nickname variable, asks you to input your nickname, and assigns the inputted value to that variable.

Check it out. Run your first interactive C# program! 👇

using System;

public class Program
{
public static void Main(string[] args)
    {
        string nickname;

        nickname = Console.ReadLine();

        Console.Write("Welcome, ");
        Console.WriteLine(nickname);
    }
}
Don't forget about the parentheses(). Each method definition or call in C# requires them. You will learn about methods in future lessons.
===================================================================
Type Conversion
One important thing to consider - the Console.ReadLine method returns only string values.

If you are expecting another type of value (such as int or double), the entered data must be converted to that type.

So, now is the right time to talk about type conversion in C#.

Let's have a look at this code 👇:

using System;

public class Program
{
public static void Main(string[] args)
    {
        string text = "5";

        int number = Convert.ToInt32(text);
        
        Console.WriteLine(number);
    }
}
OUTPUT
5

The Convert.ToInt32 method converts the value of the text variable to an integer and assigns it to the number variable. It has a value of 5 now.

There are two alternatives available based on the bit size of the integer: Convert.ToInt16 and Convert.ToInt64. The default int type in C# is 32-bit.
===================================================================
Type Conversion
Note that you cannot convert a textual string like "hello" to an int.

For example:

using System;

public class Program
{
public static void Main(string[] args)
    {
        string text = "hello";

        int number = Convert.ToInt32(text);
    }
}
===================================================================
Type Conversion
You can do the same and vice versa: convert an int to a string with the Convert.ToString method.

For example 👇:

using System;

public class Program
{
public static void Main(string[] args)
    {
        int number = 5;

        string text = Convert.ToString(number);

        Console.WriteLine(text);
    }
}
OUTPUT
5

Here are all methods of the Convert class that are used for type conversion:

ToBoolean: converts a type to a Boolean value
ToChar:  converts a type to a char type
ToDouble:  converts a type to a double type
ToInt16, ToInt32, ToInt64: converts a type to a 16-bit, 32-bit and 64-bit int type accordingly
ToString: converts a type to a string
===================================================================
User Input
Ok, back to user input!

The Console.ReadLine method returns only string values.

If you are expecting another type of value (such as int or double), the entered data must be converted to that type.

Let's build a simple calculator that takes two numbers as input and calculates their sum.

Since the taken values are strings, we need to convert them to int to work with them as numbers:

using System;

public class Program
{
public static void Main(string[] args)
    {
        //taking inputs
        string input1 = Console.ReadLine();
        string input2 = Console.ReadLine();

        //converting to int
        int number1 = Convert.ToInt32(input1);
        int number2 = Convert.ToInt32(input2);

        //calculating the sum
        int result = number1 + number2;

        Console.WriteLine(result);
    }
}

In the Code Playground, after running the code you need to input the values on two separate lines: enter the first number, go to the next line, and enter the second number.
===================================================================
User Input
We can make the program shorter and more efficient by passing the Console.ReadLine method to the Convert.ToInt32 method as an argument:

using System;

public class Program
{
public static void Main(string[] args)
    {
        /* taking the inputs and
        converting them to int */
        int number1 = Convert.ToInt32(Console.ReadLine());
        int number2 = Convert.ToInt32(Console.ReadLine());

        //calculating the sum
        int result = number1 + number2;

        Console.WriteLine(result);
    }
}
===================================================================
Lesson Takeaways
So impressive! 🚀Now you know how to make programs interactive! ✨

Here is a quick summary:

💡the Console.ReadLine method is used to take user input
💡the Console.ReadLine returns only string values
💡whenever you need to change the type of a value use the methods of the Convert class, such as Convert.ToInt32
💡you can build your own calculator!🤩

What's next?
In the next lesson, you will learn more about strings - how to escape characters, and create new lines and tabs. Keep it up!👏
===================================================================
++=====================++
++=====================++ More on Strings
Strings
In C#, how do you output text that contains quotes? For example, He said "I am back!".

You: This way? 👇

Console.WriteLine("He said "I am back!"");
C#
C#: Nope, this will result in an error. How do I know where the string ends?

The answer is…the escape character \.

using System;

public class Program
{
public static void Main(string[] args)
    {
        Console.WriteLine("He said \"I am back!\"");
    }
}
OUTPUT
He said "I am back!"
===================================================================
Escape character
Yes! The escape character \ is used to include quotes " or special characters in a string.

For example, it's also used to create new lines in text. To do it, we use \n.

Check it out 👇:

using System;

public class Program
{
public static void Main(string[] args)
    {
        Console.WriteLine("One\nTwo\nThree");
    }
}
OUTPUT
One
Two
Three
===================================================================
Tab
Similar to a new line, we can create a tab using \t:

using System;

public class Program
{
public static void Main(string[] args)
    {
        Console.WriteLine("\t hey \t there");
    }
}
OUTPUT
	 hey 	 there
===================================================================
Verbatim Strings
The verbatim string allows special characters and linebreaks in strings. It can be created by prefixing the @ symbol before double quotes.

For example:

using System;

public class Program
{
public static void Main(string[] args)
    {
        Console.WriteLine(@"Hey!
I'm a verbatim string.");
    }
}
OUTPUT
Hey!
I'm a verbatim string.
===================================================================
Lesson Takeaways
This one was easy, right? You are so cool! 😎

Here is a quick summary:

💡the escape character \ is used to include quotes or special characters in a string
💡you can use \n for a new line, and \t for a tab
💡the verbatim string allows special characters and linebreaks in strings

What's next?
In the next lesson, you will learn about how to add strings - concatenation!
===================================================================
++=====================++
++=====================++ Concatenation and Interpolation
Concatenation
Not only can we add numbers, but we can also add strings, using something called concatenation, which can be done on any two or more strings.

For example:

using System;

public class Program
{
public static void Main(string[] args)
    {
        Console.WriteLine("Solo" +"learn");
    }
}
OUTPUT
Sololearn

As you can see, the addition operator + is used for concatenation.
===================================================================
Concatenation
Strings containing numbers are still added as strings rather than numbers.


Like this:

using System;

public class Program
{
public static void Main(string[] args)
    {
        Console.WriteLine("2" + "2");
    }
}
OUTPUT
22
===================================================================
Concatenation
You can perform concatenation with variables as well:

using System;

public class Program
{
public static void Main(string[] args)
    {
        string text1 = "C";
        string text2 = "#";
        
        string result = text1 + text2;

        Console.WriteLine(result);
    }
}
OUTPUT
C#
===================================================================
Concatenation
To add a space between words, add a " ":

using System;

public class Program
{
public static void Main(string[] args)
    {
        Console.WriteLine("Hakuna" + " " + "Matata");
    }
}
OUTPUT
Hakuna Matata

Or, You can include the space in the first string, like this: "Hakuna " + "Matata".
===================================================================
Concatenation
Let's put some things together! 🌟

Run the following code, enter your name and see a message made by concatenation:

using System;

public class Program
{
public static void Main(string[] args)
    {
        string name = Console.ReadLine();

        Console.WriteLine(name + " is an awesome Sololearner!");
        Console.WriteLine(name + " learns!");
        Console.WriteLine(name + " practises!");
        Console.WriteLine("Be like " + name + "!");
    }
}
===================================================================
String Interpolation
Is it possible to use a variable inside a string? It is, using string interpolation!

Let's have a look at the following code 👇:

using System;

public class Program
{
public static void Main(string[] args)
    {
        string city = "London";

        Console.WriteLine($"{city} is the capital of the United Kingdom.");
    }
}
OUTPUT
London is the capital of the United Kingdom.

To create an interpolated string you need to prefix the $ symbol before the double quotes. To use a variable inside the string, you just need to enclose it in curly brackets: {variable name}.
===================================================================
Lesson Takeaways
This was the last lesson of the second module🎉. You rock! 

Let's summarize what you've just learned:

💡you can add strings using the + operator, that's called concatenation
💡you can perform concatenation using variables with string data
💡don't forget about the spaces when making a sentence using concatenation
💡the string interpolation allows you to use variables in strings without concatenation

What's next?
In the next module, you will learn how to create programs that make decisions 🤯! It will be fun, see you there! 👋
===================================================================
++=====================++
++=====================++ Decision Making:: Comparison Operators
Booleans
Do you remember the bool data type? Let's quickly recap what they are and then see them in action.

The Boolean data types can only take the values: True or False.

using System;

public class Program
{
    static void Main(string[] args)
    {
        bool isActive = true;
        bool isHoliday = false;

        Console.WriteLine(isActive);
        Console.WriteLine(isHoliday);
    }
}
OUTPUT
True
False
===================================================================
Comparison Operators
Imagine that you are creating a game, and that your code needs to check if the player's score is above 99. Technically speaking, you need to evaluate whether the expression is true or false.

Let's check it out 👇:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int score = 85;
        Console.WriteLine(score>99);
    }
}
OUTPUT
False

> is a comparison operator, which compares the values and results in corresponding bool values - either True or False. So, in our case the result is False.
===================================================================
Comparison Operators
C# has a number of comparison operators:

equal to ==
not equal to !=
greater than >
smaller than <
greater or equal to >=
smaller or equal to <=
Let's check them out in the following code 👇:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int x = 7;
        
        Console.WriteLine(x == 7);
        Console.WriteLine(x!=8);
        Console.WriteLine(x > 10);
        Console.WriteLine(x < 2);
        Console.WriteLine(x >= 7);
        Console.WriteLine(x <= 7);
    }
}
OUTPUT
True
True
False
False
True
True
===================================================================
Comparison Operators
You can use the == or the != comparison operator to check whether values are equal:

using System;

public class Program
{
    static void Main(string[] args)
    {
        string password = "Xn5fg";
        string repeat = "Xn5fg";

        Console.WriteLine(password==repeat);
        Console.WriteLine(password!=repeat);
    }
}
OUTPUT
True
False
===================================================================
Lesson Takeaways
Amazing job! 🚀

Let's summarize what you've just learned:

💡comparison operators are used to evaluate whether an expression is true or false
💡that expression results in a bool data type with values of either True or False
💡you can use the == quality comparison operator to check whether strings are equal
💡here are all the comparison operators:

equal to: ==
not equal to: !=
greater than: &gt;
smaller than: &lt;
greater or equal to: &gt;=
smaller or equal to: &lt;=
What's next?
In the next lesson, you will learn about the if statement, which will help you to control the behavior of your program based on different conditions and will open tons of new opportunities!
===================================================================
++=====================++
++=====================++ The if statement
The if statement
Okay, now you know how to evaluate expressions, but how do you use them?

Let's suppose you are creating a program for a shop, where a discount is provided if the total purchase exceeds 1500.

This means that your program needs to perform some action only if the given condition is true. And this is where the if statement comes in.

An if statement looks like this:

if (condition)
{
    // block of code
}
===================================================================
The if statement
So, let's use the if statement in our example with the discount in the shop.

Here is what the solution looks like:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int purchase = 1700;
        if (purchase>=1500)
        {
            Console.WriteLine("Discount!");
        }
    }
}
OUTPUT
Discount!

The purchase>=1500 condition results in True, so the code inside the if statement will be executed.

Notice that the condition should be enclosed in parentheses, followed by curly braces {}, where the block of code is written.
===================================================================
The if Statement
If the condition is false, the block of code will not be executed:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int purchase = 1400;
        if (purchase>=1500)
        {
            Console.WriteLine("Discount!");
        }
    }
}
OUTPUT
No output.
===================================================================
The if Statement
You can use any expression that can be evaluated as true or false for your if statement.

Here is an example with the equal operator:

using System;

public class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Do you enjoy learning?");

        string answer = Console.ReadLine();

        if(answer == "Yes")
        {
            Console.WriteLine("You are awesome!");
        }
    }
}
===================================================================
The if Statement
Here is an example of how we can create a simple personalized congratulations program using an if statement and string interpolation:

using System;

public class Program
{
    static void Main(string[] args)
    {

        string name = Console.ReadLine();
        int points = 144;
        int minPoints = 100;

        if(points>=minPoints)
        {
            Console.WriteLine($"Well done, {name}!");
        }
    }
}
Remember when you started this course? This code would have looked like hieroglyphics to you. Now you understand it at a glance. You rock! 👏
===================================================================
The if Statements
Sometimes we’ll have to perform more complex checks. But that’s no problem because if statements can be nested, one inside the other.

For example:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int num = 12;
        if(num > 5)
        {
            Console.WriteLine("Bigger than 5");
            if(num<47)
            {
                Console.WriteLine("Between 5 and 47");
            }
        }
    }
}
OUTPUT
Bigger than 5
Between 5 and 47

In the case of nesting, the second if statement will be performed only if the condition of the first one is evaluated as true.
===================================================================
Lesson Takeaways
Your programs now can make decisions!🚀

Here is a quick summary:

💡you can let your program make decisions based on a condition using the if statement
💡the code inside of the if statement will be performed only if the condition is evaluated as true
💡if statements can be nested, one inside the other

What's next?
In the next lesson, you will learn how to make more complex and flexible decision-making!
===================================================================
else statement
Hey 👋! Ready to take the next step? Let's do it!

Let's imagine you are developing a game where the level is considered completed if the player has collected 100 points. You can already output the congratulations message with the if statement, and that's great! But what about the loss case? How to show a message when the player didn't get enough points (the condition is false)?

The else statement will help you out here!

How? Look at this code 👇:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int score = 98;
        
        if(score >=100)
        {
            Console.WriteLine("Level Completed!");
        } 
        else
        {
            Console.WriteLine("Try again!");
        }
    }
}
OUTPUT
Try again!

The code inside the else statement will be executed only if the condition is false.
===================================================================
else statement
As with the if statement, the piece of code inside the else statement is enclosed in curly braces {}:

else
{
    Console.WriteLine("Try again!");
}
C#
The else statement doesn't have its own condition - it just checks the condition of the if statement and performs a specific action if it's false.
===================================================================
else if statement
There will be times when you want to test multiple conditions. That is where the else if statements turn. It's written between if and else statements.

For example👇:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int time = 15;
        
        if(time<10)
        {
            Console.WriteLine("Good morning!");
        } 
        else if(time<20)
        {
            Console.WriteLine("Good day!");
        }
        else
        {
            Console.WriteLine("Good evening!");
        }
    }
}
OUTPUT
Good day!

The program will move to the else if statement when the condition of the if statement is false. If its condition is also false, then the program will move to the else block.
===================================================================
else if statement
With the help of the else if statements you can use as many conditions as you need 🙌:

using System;

public class Program
{
    static void Main(string[] args)
    {
        string stopLight = "green";
        
        if(stopLight == "red")
        {
            Console.WriteLine("Stop!");
        } 
        else if(stopLight == "yellow")
        {
            Console.WriteLine("Slow down.");
        }
        else if(stopLight == "green")
        {
            Console.WriteLine("Go!");
        }
        else
        {
            Console.WriteLine("Unknown.");
        }
    }
}
OUTPUT
Go!
===================================================================

Translate course
Lesson Takeaways
You've taken another giant step forward, you are on fire! 🔥

Let's summarize what you've just learned:

💡the else statement allows you to control the cases when the condition in the if statement is false
💡you can use else if statements to handle multiple conditions
💡Here is a generic structure of if else statements 👇:

if(condition)
{
    //some code
}
else if(condition)
{
    //some other code
}
else
{
    //some other code
}
C#
What's next?
In the next lesson, you will learn how to chain multiple conditions within one statement. Keep it up, warrior 👏!
===================================================================
++=====================++
++=====================++ Logical Operators
Logical Operators
Let's go back to your game, where the player completes the level if 90 points have been earned. What if you want to add one more challenge to complete the level? For example, a challenge to find two magic keys.

Technically speaking, you need to add one more condition to the if statement.

This can be done with the logical AND operator &&. It returns true only if both conditions (operands) return true 👇:

if(condition1 && condition2)
{
    //some code
}
===================================================================
Logical Operators
Let's solve the problem with the two conditions from the previous game use case.

Check it out 👇:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int points = 95;
        int keys = 2;

        if(points>=90 && keys >=2)
        {
            Console.WriteLine("Level Completed!");
        }
        else
        {
            Console.WriteLine("Try again!");
        }
    }
}
OUTPUT
Level Completed!

Both conditions in the if statement are true, so the block of code inside it will be executed.
===================================================================
Logical Operators
The && operator returns false if one of the conditions (or both of them) is false:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int points = 95;
        int keys = 1;

        if(points>=90 && keys >=2 )
        {
            Console.WriteLine("Level Completed!");
        }
        else
        {
            Console.WriteLine("Try again!");
        }
    }
}
Try again!
===================================================================
Logical Operators
The logical OR operator || returns true if any one of its operands is true:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int hour = 18;
        string day = "Sunday";

        if(hour>20 || day=="Sunday")
        {
            Console.WriteLine("Closed");
        }
        else
        {
            Console.WriteLine("Opened");
        }
    }
}
OUTPUT
Closed
===================================================================
Logical operators
The logical NOT operator ! works with just a single operand, reversing its logical state. Thus, if a condition is true, the NOT operator makes it false, and vice versa.

Check it out 👇:

using System;

public class Program
{
    static void Main(string[] args)
    {
        string day = "Monday";

        if( !(day=="Sunday"))
        {
            Console.WriteLine("Working day");
        }
        else
        {
            Console.WriteLine("Non-working day");
        }
    }
}
OUTPUT
Working day

Simply said, the code above outputs Working day if the day is NOT Sunday.

Note that the expression is enclosed in parentheses.
===================================================================
Multiple Conditions
You can chain multiple conditions using parentheses and logical operators.

For example 👇:

using System;

public class Program
{
    static void Main(string[] args)
    {
        string country = "US";
        int age = 42;

        if ((country == "US" || country == "GB") &&(age >0 && age <=100))
        {
            Console.WriteLine("Welcome!");
        }
    }
}
OUTPUT
Welcome!
===================================================================
Lesson Takeaways
Great job 🚀! Now you can chain multiple conditions and make a more flexible decision-making program.

Let's summarize what you've just learned:

💡logical operators are used to evaluate multiple conditions or invert them
💡the logical AND operator && returns true if both operands return true
💡the logical OR operator || returns true if any one of the operands returns true
💡the logical NOT operator ! returns true if its operand is false, and vice versa
💡 you can chain multiple conditions using parentheses and logical operators

What's next?
In the next lesson, you will learn about another decision-making statement.
===================================================================
++=====================++
++=====================++ The switch statement
The switch statement
Let's suppose you are creating a social media application, and you need to develop a menu where the user can choose the topic he is interested in marked by corresponding numbers.

This can be handled with multiple if else statements:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int choice = 2;

        if(choice==1)
        {
            Console.WriteLine("Sports");
        }
        else if(choice==2)
        {
            Console.WriteLine("Business");
        }
        else if(choice==3)
        {
            Console.WriteLine("Technology");
        }
    }
}
OUTPUT
Business

But C# has another way to make this happen. Keep going to see it!
===================================================================
The switch statement
Instead of many if else statements, which become hard to read, we can use a switch statement.

A switch statement tests a variable for equality against a list of values.

Here is the previous example using a switch statement:

using System;

public class Program
{
  static void Main(string[] args)
    {
      int choice = 2;

      switch(choice)
      {
        case 1:
          Console.WriteLine("Sports");
          break;
            
        case 2:
          //match!
          Console.WriteLine("Business");
          break;

        case 3:
          Console.WriteLine("Technology");
          break;            
      }
  }
}
OUTPUT
Business

The value of the switch expression is compared with the values of each case, and if there’s a match, that block of code is executed.

You can have any number of case statements within a switch. Each case is followed by the comparison value and a colon.

The switch statement makes code more readable.
===================================================================
break statement
Imagine you have 10 boxes and there is a ball in one of them. If you find it in the 5th box, you don't need to check the other 5 boxes, right? After getting the ball you will just stop searching because you've already gotten what you need.

The break statement does the same thing in the switch statement. It stops the execution of other cases when there is a match and the program just goes out from the switch statement.

using System;

public class Program
{
    static void Main(string[] args)
    {
        int choice = 2;

        switch(choice)
        {
            case 1:
              Console.WriteLine("Sports");
              break;
            
            case 2:
              //match!
              Console.WriteLine("Business");
              //stop
              break;
            
            case 3:
              Console.WriteLine("Technology");
              break;            
        }
    }
}
OUTPUT
Business
===================================================================
The default keyword
Often there will be no match, but we still need the program to do some action. For this, we use the default keyword, which specifies the code to run if there’s no case match.

Like this 👇:

using System;

public class Program
{
    static void Main(string[] args)
    {
        string color = "yellow";
        switch(color)
        {
          case "blue": 
            Console.WriteLine("This is blue.");
            break;
          case "red": 
            Console.WriteLine("This is red.");
            break;
          default: 
            Console.WriteLine("Color not found.");
            break;
        }
    }
}
OUTPUT
Color not found.

The default block can be omitted if there is no need to handle the case when no match is found.
===================================================================
Lesson Takeaways
Awesome job!🚀

Let's summarize what you've just learned:

💡the switch statement tests a variable for equality against a list of values, and performs actions if there is a match
💡there are cases when the switch statement can replace multiple if else statements, and that makes the code more readable
💡the break statement is obligatory for each case
💡the default keyword is used to perform an action when there is no match

What's next?
In the next lesson, you will learn how to create a conditional statement in just one line - a ternary operator!
===================================================================
++=====================++
++=====================++ The Ternary Operator
Ternary operator
Conditional, or ternary, operators assign a value to a variable, based on some condition.

This is what the syntax would look like:

variable = condition ? expression1: expression2
C#
It takes three operands:

a condition followed by a question mark ?
an expression1 to execute if the condition is true followed by a colon :
an expression2 to execute if the condition is false
This operator is frequently used as an alternative to an if else statement.
===================================================================
Ternary operator
Here is an example of a ternary operator 👇:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int age = 42;
        string isAdult = age<18 ? "Too young": "Old enough";

        Console.WriteLine(isAdult);
    }
}
OUTPUT
Old enough
===================================================================
Ternary operator
Remember the discount example? If the total amount is equal to or above 1500 it will be discounted by 15%.

Let's calculate and show the discounted bill to your customers using the ternary operator:

using System;

public class Program
{
    static void Main(string[] args)
    {
        double bill = 1800;
        bill = bill>=1500 ? bill * 0.85 : bill;

        Console.WriteLine(bill);
    }
}
OUTPUT
1530
===================================================================
Lesson Takeaways
This was the last lesson of Module 3! Congratulations! 🎉

Let's summarize the lesson:
💡you can use ternary operators as an alternative to if else statements
💡they have 3 operands: the condition, and 2 values, one of which will be assigned to the variable based on that condition

What's next?
In the next module, you will learn another important concept - loops. Keep going!👏
===================================================================
++=====================++
++=====================++ Loops:: The for loop
Loops
Hey 👋! Happy to see you here, at Module 4!

In this module, we will talk about loops. Loops allow you to run the same code multiple times.

This is useful, for example, when drawing animations in games, or creating a countdown.

The for loop has the following syntax:

for (initializer; condition; iterator)
{
    //code block 
}
C#
The initializer runs once when we enter the loop, and initializes the variable.

The second part is the condition that specifies when to stop the loop.

The third part, the iterator, runs every time the loop runs. It is usually used to increment the variable used in the condition.

Each run of the loop is called an iteration.
===================================================================
For loop
Here is an example of a for loop outputting the number 1 to 10 👇:

using System;

public class Program
{
    static void Main(string[] args)
    {
        for(int i = 1; i <= 10; i++)
        {
            Console.WriteLine($"Value of i: {i}");
        }
    }
}
OUTPUT
Value of i: 1
Value of i: 2
Value of i: 3
Value of i: 4
Value of i: 5
Value of i: 6
Value of i: 7
Value of i: 8
Value of i: 9
Value of i: 10

The loop creates an int variable called i and initializes it to 1.

Then, after each iteration, it increments the i variable by 1.

The loop stops when i reaches 11, breaking the condition.

Modify the code to output the numbers 10 to 50.
===================================================================
For loop
Let's make another loop, which outputs only the even numbers from 0 to 20:

using System;

public class Program
{
    static void Main(string[] args)
    {
        for(int i = 0; i <= 20; i+=2)
        {
            Console.WriteLine($"Value of i: {i}");
        }
    }
}
OUTPUT
Value of i: 0
Value of i: 2
Value of i: 4
Value of i: 6
Value of i: 8
Value of i: 10
Value of i: 12
Value of i: 14
Value of i: 16
Value of i: 18
Value of i: 20

We increment i by 2 after each iteration, resulting in only the even numbers.

Change the code to output only the odd numbers.
===================================================================
The for loop
Let's write a program for a shooter game, which will control the number of shots fired. At the start of the level, the player has 5 bullets. Each time the player shoots, the number of bullets should be decreased by 1.

The for loop will help you here as well 👇:

using System;

public class Program
{
    static void Main(string[] args)
    {
        for(int i=5; i>=0; i--)
        {
            Console.WriteLine($"Bullets: {i}");
        }
    }
}
OUTPUT
Bullets: 5
Bullets: 4
Bullets: 3
Bullets: 2
Bullets: 1
Bullets: 0
===================================================================
Lesson Takeaways
Great job! Let's summarize what you've just learned:

💡loops allow you to run the same code multiple times

💡the for loop has 3 components: the initializer, the condition, and the iterator

💡here is a default structure of a for loop:

for (initializer; condition; iterator)
{
    //code block 
}
C#
What's next?
In the next lesson, you will learn a new type of loop - the while loop!
===================================================================
++=====================++
++=====================++ The while loop
while Loops
A while loop statement repeatedly executes a target statement as long as a given condition is true.

Example 👇:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int x = 5;

        while(x>0)
        {
            Console.WriteLine(x);
            x--;
        }
    }
}
OUTPUT
5
4
3
2
1

The while loops check for the condition x > 0. If it evaluates to true, it executes the statements within its body. Then it checks for the statement again and repeats.

The code above will output the numbers 3 to 1, and then stop, as the condition will become false, after x reaches 0.
===================================================================
while Loops
Let's look at the code again:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int x = 5;

        while(x>=0)
        {
            Console.WriteLine(x);
            x--;
        }
    }
}
OUTPUT
5
4
3
2
1
0

The line x--; is important, as without it the condition would never become false and the loop would run forever. 

Each time the loop runs, 1 is subtracted from x.
===================================================================
while Loops
You can perform calculations and other operations in loops.

For example, let's calculate the sum of the numbers from 1 to 100 and output it:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int sum = 0;
        int num = 100;

        while(num>=0)
        {
            sum+=num;
            num--;
        }

        Console.WriteLine(sum);
    }
}
OUTPUT
5050

We add the value of num to sum each time the loop runs, and then decrease the num value by 1.

At the end of the loop, sum holds the result of our calculation.

Notice that the last Console.WriteLine statement is out of the while scope.
===================================================================
The do...while loop
The last loop you're looking at is the do while loop, it's a variant of the while loop but with one important difference.

This loop will execute the code block once, before checking if the condition is true, and then it will repeat the loop as long as the condition is true. This means that do while is guaranteed to run at least once, even with a false condition.

For example:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int i = 5;
        
        do
        {
            Console.WriteLine(i);
            i++;
        } while (i < 5);
    }
}
OUTPUT
5

The condition is tested after the first iteration, that's why the code inside it is executed once. The while loop with the same conditions will not output anything in this case.
===================================================================
Loops
Both for and while can be used to accomplish the same task.

The for loop is usually used when the number of times we need to run the loop is known.

The while loop is used when the condition of the loop is more complex and the number of times it runs is based on the expression in the loop. 

Use for loops when possible, as it has a cleaner syntax and is easier to read and understand.
===================================================================
Lesson Takeaways
You are amazing, you have taken yet another step forward! 🚀

Let's summarize what you've just learned:
💡the while loop runs as long as the condition is true
💡make sure your condition eventually becomes false, otherwise, you will have an infinite loop.
💡the do while loop executes the code block once, before checking if the condition is true, and then it repeats the loop as long as the condition is true

What's next?
In the next lesson, you will learn how to control the iterations inside the loops.
===================================================================
++=====================++
++=====================++ break and continue
The break statement
Do you remember the break statement from the switch statement? Well, that's not the only place where you can use it.

The break statement allows you to exit a loop prematurely, based on the given condition.

For example:

using System;

public class Program
{
    static void Main(string[] args)
    {
        for(int i = 0; i<=10; i++)
        {
            if(i==5)
            {
                break;
            }
            Console.WriteLine(i);
        }
    }
}
OUTPUT
0
1
2
3
4

This can be useful, for example, to exit a loop when the user enters a specific number, or taps on a specific button.
===================================================================
The break statement
In the same way, you can use the break statement in while loops.

For example:

using System;

public class Program
{
    static void Main(string[] args)
    {
        int num = 1;
        while(num<=10)
        {
            if(num == 3)
            {
                break;
            }
        Console.WriteLine(num);
        num++;
        }
    }
}
OUTPUT
1
2
===================================================================
continue
The continue statement is used to skip an iteration of the loop and continue from the next one.

This can be useful, for example, to skip some particular elements in the loop:

using System;

public class Program
{
    static void Main(string[] args)
    {
        for(int i = 0; i<=10; i++)
        {
            if(i==5)
            {
                continue;
            }
            Console.WriteLine(i);
        }
    }
}
OUTPUT
0
1
2
3
4
6
7
8
9
10

This will skip the number 5.
===================================================================
Lesson Takeaways
The break statement didn't break you, you completed Module 4! Well done!🚀

Let's summarize what you've just learned:
 💡you can use the break statement in for and while loops
 💡the break statement allows you to exit a loop prematurely, based on the given condition
 💡the continue statement is used to skip an iteration of the loop and continue from the next one

What's next?
Do you know what you are really doing when you write Console.WriteLine()? Or when you write Convert.ToString()? You are calling methods. It's time to find out what a method is, and how you can create your own!
===================================================================
++=====================++
++=====================++ Methods: Methods
Methods
A method is a block of code designed to perform a particular task.

For example, our app can have methods like Login, Logout, Convert, etc.

The Console.WriteLine that we use for output is also a method.

The purpose of a method is to create it once and call it multiple times when needed to perform particular tasks.
===================================================================
Methods
You can define your own methods to perform your desired tasks.

Here is an example:

static void Welcome() 
{
    Console.WriteLine("Welcome");
    Console.WriteLine("I am a method");
    Console.WriteLine("End of method");
}
C#
The code above declares a method called Welcome, which prints 3 lines of text.

Note that the name of the method is followed by parentheses (). The statements of the method are inside curly braces.
===================================================================
Methods
Let's look at the code again 👇:

static void Welcome() 
{
    Console.WriteLine("Welcome");
    Console.WriteLine("I am a method");
    Console.WriteLine("End of method");
}
C#
The static is needed to be able to use the method in Main. You will learn about the static keyword in more advanced lessons.

void means that this method does not have a return value. You will learn more about return values later in this module.

Welcome is the name of the method.

In C#, it's good practice to start with an uppercase letter when naming methods, as it makes the code easier to read.
===================================================================
Calling a Method
After defining the method, we can use it in our program by "calling" it.

To call a method, type its name followed by a set of parentheses.

For example:

using System;

public class Program
{
    static void Main(string[] args)
    {
        Welcome();
    }
    static void Welcome() 
    {
        Console.WriteLine("Welcome");
        Console.WriteLine("I am a method");
        Console.WriteLine("End of method");
    }
}
OUTPUT
Welcome
I am a method
End of method

As the Main method is the entry point of the program, we call our method inside its scope.
===================================================================
Calling a Method
You can call a method as many times as necessary.

Example:

using System;

public class Program
{
    static void Main(string[] args)
    {
        Welcome();
        //same code
        Welcome();
        Welcome();
    }
    static void Welcome() 
    {
        Console.WriteLine("Welcome");
        Console.WriteLine("I am a method");
        Console.WriteLine("End of method");
    }
}

OUTPUT
Welcome
I am a method
End of method
Welcome
I am a method
End of method
Welcome
I am a method
End of method
===================================================================
Lesson Takeaways
You are fantastic!🚀 Here are the main points to remember when defining your own methods:

💡methods are reusable, we define them once and can call them multiple times
💡the static keyword is used in the definition of a method, so we can call them in Main.
💡The void keyword means that the method does not return a value.
💡In C#, it is good practice to start with an uppercase letter when naming methods
💡To call a method, use its name followed by parentheses.

We will learn about return values in the next lessons, so stay tuned!

What's next?
In the next lesson, we will learn how to pass parameters to functions.
=================================================================== Parameters and Arguments
Method Parameters
Methods can have parameters, which they can use in their code.

The parameters are defined in parentheses and can be used like variables in the method.

For example, let's add a name string parameter to our Welcome() function:

static void Welcome(string name)
{
 Console.WriteLine("Welcome, " + name);
}
C#
The method above takes a string called name as its parameter, which is used in the method.
===================================================================
Method Parameters
Now, when calling the method, we need to pass it a value for the name parameter inside the parentheses:

using System;

public class Program
{
    static void Main(string[] args)
    {
        Welcome("John");
        Welcome("Tom");
    }
    static void Welcome(string name) 
    {
        Console.WriteLine("Welcome " + name);
    }
}
OUTPUT
Welcome John
Welcome Tom

This way, we can call our method with different parameters and generate different results based on them.

The values passed as parameters are called arguments.
===================================================================
Multiple Parameters
Methods can take multiple parameters. For that, we simply need to separate them using commas, for example:

static void Welcome(string name, int age) 
{
    Console.WriteLine("Welcome " + name);
    Console.WriteLine("You age: " + age);
}
C#
Now, our Welcome method takes a string and an integer as its parameters.
===================================================================
Multiple Parameters

Now, when calling the function, we need to provide all the parameters:

using System;

public class Program
{
    static void Main(string[] args)
    {
        Welcome("John", 25);
        Welcome("Tom", 36);
    }
    static void Welcome(string name, int age) 
    {
        Console.WriteLine("Welcome " + name);
        Console.WriteLine("You age: " + age);
    }
}
OUTPUT
Welcome John
You age: 25
Welcome Tom
You age: 36

Note that the arguments need to match the parameters and must be passed in the same order.
===================================================================
Method Parameters
Method parameters are really handy! They allow our method to work with different values and produce results.

For example, we can create a method to calculate a given percentage of a number and output it:

using System;

public class Program
{
    static void Main(string[] args)
    {
        Perc(640,24);
    }
    static void Perc(double num, int percentage)
    {
        double res = num*percentage/100;
        Console.WriteLine(res);
    }
}
OUTPUT
153.6
===================================================================
Multiple Parameters
Again, let's remember our discount case - if the total amount is equal to or above 1500 it will be discounted by 15%.

So as to not write the same code multiple times, we can just create a function that will perform the same calculation, then call it on each customer.

Here it is 👇:

using System;

public class Program
{
    static void Main(string[] args)
    {
        Discount("Tom", 1700);
        Discount("Bob", 1300);
    }
    static void Discount(string name, double purchase)
    {
        if(purchase>=1500)
        {
            purchase*=0.85;
        }

        Console.WriteLine($"Customer: {name}");
        Console.WriteLine($"Total: {purchase}");
    }
}
OUTPUT
Customer: Tom
Total: 1445
Customer: Bob
Total: 1300

Open the code to see the method in action 🎯! Look how much you can do now! It's just awesome!🤩
===================================================================
Lesson Takeaways
Great job 🚀!

Here is your summary:
💡functions can have parameters, which can be used in their code
💡the parameters are defined in the parentheses
💡multiple parameters need to be separated by commas
💡when calling a method, you need to provide its parameters in the same order, as defined

What's next?
You will learn how to return values in the next lesson.
===================================================================
++=====================++
++=====================++ Returning from Methods
Return Values
The methods we have seen so far output their result.

In some cases we do not need to output the result, but need to assign it to a variable, to work with it in our program.

In these cases, we need our method to return the result value.
===================================================================
The Return Type
Consider a method from our previous lesson, that was used to output a percentage of the given value:

static void Perc(double num, int percentage)
{
    double res = num*percentage/100;
    Console.WriteLine(res);
}
C#
The void keyword in the definition specifies that the method does not return any value.
===================================================================
The Return Type
Here is the same function definition, specifying the return type to be a double:

static double Perc(double num, int percentage)
{
    ....
}
C#
This means that our Perc method will return a value of type double.
===================================================================
Returning a Value
Now, we can return our result using the return keyword:

static double Perc(double num, int percentage)
{
    double res = num*percentage/100;
    return res;
}
C#
The return keyword stops the method from executing. If there are any statements after, they won't run.

This also means that a method can have only one return keyword.
===================================================================
Returning a Value
After we have created our method that returns a value, we can call it in our code and assign the result to a variable:

using System;

public class Program
{
    static void Main(string[] args)
    {
        double result = Perc(640,24);

        Console.WriteLine($"Result is: {result}");
    }
    static double Perc(double num, int percentage)
    {
        double res = num*percentage/100;
        return res;
    }
}
OUTPUT
Result is: 153.6

Returning is useful when you don't need to print the result of the method, but need to use it in your code. For example, a bank account's Withdraw() method could return the remaining balance of the account.
===================================================================
Lesson Takeaways
You did it 🚀! This was the last lesson of this course. Fantastic job!🌟

Here is a quick summary:
💡the return statement ends function execution and returns the resulting value
💡you can use that value throughout the program, which is the advantage of the return statement
💡The returned value can be assigned to a variable when calling the method.

Great job – you are an amazing Sololearner and a superhero 🦸!  You can be proud of yourself, this is a big achievement in your coding journey! Go get your certificate! 🏆
===================================================================



Basic Concepts
What is C#?
Variables
Your First C# Program
Printing Text
Getting User Input
Comments
The var Keyword
Constants
Arithmetic Operators
Assignment & Increment Operators
Module 1 Quiz
Code Project
Area of a Circle
Conditionals and Loops
The if-else Statement
The switch Statement
The while Loop
The for Loop
The do-while Loop
break and continue
Logical Operators
The Conditional Operator
Basic Calculator
Module 2 Quiz
Code Project
Multiple of 3
Methods
Introduction to Methods
Method Parameters
Multiple Parameters
Optional & Named Arguments
Passing Arguments
Method Overloading
Recursion
Making a Pyramid
Module 3 Quiz
Code Project
Level Points
Classes & Objects
Classes & Objects
Value & Reference Types
Class Example
Encapsulation
Constructors
Properties
Module 4 Quiz
Code Project
Social Network
Arrays and Strings
Arrays
Using Arrays in Loops
Multidimensional Arrays
Jagged Arrays
Array Properties & Methods
Working with Strings
Module 5 Quiz
Code Project
Words
More On Classes
Destructors
Static Members
Static Classes
this & readonly
Indexers
Operator Overloading
Module 6 Quiz
Code Project
Dance
Inheritance & Polymorphism
Inheritance
Protected Members
Derived Class Constructor & Destructor
Polymorphism
Abstract Classes
Interfaces
Nested Classes
Namespaces
Module 7 Quiz
Code Project
Drawing Application
Structs, Enums, Exceptions & Files
Structs
Enums
Exception Handling
Working with Files
Module 8 Quiz
Code Project
Robot-barmen
Generics
Generic Methods
Generic Classes
Collections
Lists and BitArray
Stack & Queue
Dictionary & HashSet
Module 9 Quiz
Code Project
Coffee Time

######################################################################################
######################################################################################
##	endroughxfer-urldump #1#
##	<EOF><EOF> C++ Complete (Original) - Volume 3
######################################################################################
######################################################################################


===================================================================
++=====================++
++=====================++ Basic Concepts:: What is C#?
Welcome to C#
C# is an elegant object-oriented language that enables developers to build a variety of secure and robust applications that run on the .NET Framework.
You can use C# to create Windows applications, Web services, mobile applications, client-server applications, database applications, and much, much more.

You will learn more about these concepts in the upcoming lessons!
===================================================================
The .NET Framework
The .NET Framework consists of the Common Language Runtime (CLR) and the .NET Framework class library.
The CLR is the foundation of the .NET Framework. It manages code at execution time, providing core services such as memory management, code accuracy, and many other aspects of your code.
The class library is a collection of classes, interfaces, and value types that enable you to accomplish a range of common programming tasks, such as data collection, file access, and working with text.
C# programs use the .NET Framework class library extensively to do common tasks and provide various functionalities.

These concepts might seem complex, but for now just remember that applications written in C# use the .NET Framework and its components.
===================================================================
++=====================++
++=====================++ Variables
Variables
Programs typically use data to perform tasks.
Creating a variable reserves a memory location, or a space in memory, for storing values. It is called variable because the information stored in that location can be changed when the program is running.
To use a variable, it must first be declared by specifying the name and data type.
A variable name, also called an identifier, can contain letters, numbers and the underscore character (_) and must start with a letter or underscore.
Although the name of a variable can be any set of letters and numbers, the best identifier is descriptive of the data it will contain. This is very important in order to create clear, understandable and readable code!

For example, firstName and lastName are good descriptive variable names, while abc and xyz are not.
===================================================================
Variable Types
A data type defines the information that can be stored in a variable, the size of needed memory and the operations that can be performed with the variable.
For example, to store an integer value (a whole number) in a variable, use the int keyword:

int myAge;
The code above declares a variable named myAge of type integer.

A line of code that completes an action is called a statement. Each statement in C# must end with a semicolon.

You can assign the value of a variable when you declare it:

int myAge = 18;
or later in your code:

int myAge;
myAge = 18;
Remember that you need to declare the variable before using it.
===================================================================
Built-in Data Types
There are a number of built-in data types in C#. The most common are:
int - integer.
float - floating point number.
double - double-precision version of float.
char - a single character.
bool - Boolean that can have only one of two values: True or False.
string - a sequence of characters.
The statements below use C# data types:

int x = 42;
double pi = 3.14;
char y = 'Z';
bool isOnline = true;
string firstName = "David";
Note that char values are assigned using single quotes and string values require double quotes.
You will learn how to perform different operations with variables in the upcoming lessons!
===================================================================
++=====================++
++=====================++ Your First C# Program
Your First C# Program
You can run, save, and share your C# codes on our Code Playground, without installing any additional software.

Reference this lesson if you need to install the software on your computer.

To create a C# program, you need to install an integrated development environment (IDE) with coding and debugging tools.
We will be using Visual Studio Community Edition, which is available to download for free.
After installing it, choose the default configuration.
Next, click File->New->Project and then choose Console Application as shown below:

img-component
Enter a name for your Project and click OK.

Console application uses a text-only interface. We chose this type of application to focus on learning the fundamentals of C#.
===================================================================
Your First C# Program
Visual Studio will automatically generate some code for your project:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace SoloLearn
{
   class Program
   {
      static void Main(string[] args)
      {
      }
   }
}
You will learn what each of the statements does in the upcoming lessons.
For now, remember that every C# console application must contain a method (a function) named Main. Main is the starting point of every application, i.e. the point where our program starts execution from.

We will learn about classes, methods, arguments, and namespaces in the upcoming lessons.
===================================================================
Your First C# Program
To run your program, press Ctrl+F5. You will see the following screen:

img-component
This is a console window. As we did not have any statements in our Main method, the program just produces a general message. Pressing any key will close the console.

Congratulations, you just created your first C# program.
===================================================================
++=====================++
++=====================++ Printing Text
Displaying Output
Most applications require some input from the user and give output as a result.
To display text to the console window you use the Console.Write or Console.WriteLine methods. The difference between these two is that Console.WriteLine is followed by a line terminator, which moves the cursor to the next line after the text output.
The program below will display Hello World! to the console window:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
OUTPUT
Hello World!

Note the parentheses after the WriteLine method. This is the way to pass data, or arguments, to methods. In our case WriteLine is the method and we pass "Hello World!" to it as an argument. String arguments must be enclosed in quotation marks.
===================================================================
Displaying Output
We can display variable values to the console window:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 89;
            Console.WriteLine(x);
        }
    }
}
OUTPUT
89

To display a formatted string, use the following syntax:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 10;
            double y = 20;
            Console.WriteLine("x = {0}; y = {1}", x, y);
        }
    }
}
OUTPUT
89

As you can see, the value of x replaced {0} and the value of y replaced {1}.

You can have as many variable placeholders as you need. (i.e.: {3}, {4}, etc.).
===================================================================
++=====================++
++=====================++ Getting User Input
User Input
You can also prompt the user to enter data and then use the Console.ReadLine method to assign the input to a string variable.
The following example asks the user for a name and then displays a message that includes the input:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string yourName;
            Console.WriteLine("What is your name?");
            yourName = Console.ReadLine();
 
            Console.WriteLine("Hello {0}", yourName);
        }
    }
}

The Console.ReadLine method waits for user input and then assigns it to the variable. The next statement displays a formatted string containing Hello with the user input. For example, if you enter David, the output will be Hello David.
===================================================================
User Input
The Console.ReadLine() method returns a string value.
If you are expecting another type of value (such as int or double), the entered data must be converted to that type.
This can be done using the Convert.ToXXX methods, where XXX is the .NET name of the type that we want to convert to. For example, methods include Convert.ToDouble and Convert.ToBoolean.
For integer conversion, there are three alternatives available based on the bit size of the integer: Convert.ToInt16, Convert.ToInt32 and Convert.ToInt64. The default int type in C# is 32-bit.
Let’s create a program that takes an integer as input and displays it in a message:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = Convert.ToInt32(Console.ReadLine());
            Console.WriteLine("You are {0} years old", age);
        }
    }
}

If, in the program above, a non-integer value is entered (for example, letters), the Convert will fail and cause an error.
===================================================================
++=====================++
++=====================++ Comments
Comments
Comments are explanatory statements that you can include in a program to benefit the reader of your code.
The compiler ignores everything that appears in the comment, so none of that information affects the result.

A comment beginning with two slashes (//) is called a single-line comment. The slashes tell the compiler to ignore everything that follows, until the end of the line.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            // Prints Hello
            Console.WriteLine("Hello");
        }
    }
}
OUTPUT
Hello

When you run this code, Hello will be displayed to the screen. The // Prints Hello line is a comment and will not appear as output.
===================================================================
Multi-Line Comments
Comments that require multiple lines begin with /* and end with */ at the end of the comment block.
You can place them on the same line or insert one or more lines between them.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            /* Some long 
                comment text     
            */
            int x = 42;
            Console.WriteLine(x);
        }
    }
}
OUTPUT
42

Adding comments to your code is good programming practice. It facilitates a clear understanding of the code for you and for others who read it.
===================================================================
++=====================++
++=====================++ The var Keyword
The var Keyword
A variable can be explicitly declared with its type before it is used.
Alternatively, C# provides a handy function to enable the compiler to determine the type of the variable automatically based on the expression it is assigned to.

The var keyword is used for those scenarios:
var num = 15;
The code above makes the compiler determine the type of the variable. Since the value assigned to the variable is an integer, the variable will be declared as an integer automatically.
===================================================================
The var Keyword
Variables declared using the var keyword are called implicitly typed variables.
Implicitly typed variables must be initialized with a value.

For example, the following program will cause an error:
var num;
num = 42;
Although it is easy and convenient to declare variables using the var keyword, overuse can harm the readability of your code. Best practice is to explicitly declare variables.
===================================================================
++=====================++
++=====================++ Constants
Constants
Constants store a value that cannot be changed from their initial assignment.
To declare a constant, use the const modifier.

For example:
const double PI = 3.14;
The value of const PI cannot be changed during program execution.
For example, an assignment statement later in the program will cause an error:

const double PI = 3.14;
PI = 8; //error
Constants must be initialized with a value when declared.
===================================================================
++=====================++
++=====================++ Arithmetic Operators
Operators
An operator is a symbol that performs mathematical or logical manipulations.

[h2]Arithmetic Operators[/h2]
C# supports the following arithmetic operators:

img-component
For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 10;
            int y = 4;
            Console.WriteLine(x-y);
        }
    }
}
OUTPUT
6
===================================================================
Division
The division operator (/) divides the first operand by the second. If the operands are both integers, any remainder is dropped in order to return an integer value.

Example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 10 / 4;
            Console.WriteLine(x);
        }
    }
}
OUTPUT
2

Division by 0 is undefined and will crash your program.
===================================================================
Modulus
The modulus operator (%) is informally known as the remainder operator because it returns the remainder of an integer division.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 25 % 7;
            Console.WriteLine(x);
        }
    }
}
OUTPUT
4
===================================================================
Operator Precedence
Operator precedence determines the grouping of terms in an expression, which affects how an expression is evaluated. Certain operators take higher precedence over others; for example, the multiplication operator has higher precedence than the addition operator.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 4+3*2;
            Console.WriteLine(x);
        }
    }
}
OUTPUT
10

The program evaluates 3*2 first, and then adds the result to 4.
As in mathematics, using parentheses alters operator precedence.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = (4 + 3) *2;
            Console.WriteLine(x);
        }
    }
}
OUTPUT
10

The operations within parentheses are performed first. If there are parenthetical expressions nested within one another, the expression within the innermost parentheses is evaluated first.

If none of the expressions are in parentheses, multiplicative (multiplication, division, modulus) operators will be evaluated before additive (addition, subtraction) operators. Operators of equal precedence are evaluated from left to right.
===================================================================
++=====================++
++=====================++ Assignment & Increment Operators
Assignment Operators
The = assignment operator assigns the value on the right side of the operator to the variable on the left side.

C# also provides compound assignment operators that perform an operation and an assignment in one statement.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 42;
            x += 2; // equivalent to x = x + 2
            Console.WriteLine(x);

            x -= 6; // equivalent to x = x - 6
            Console.WriteLine(x);
        }
    }
}
OUTPUT
44
38
===================================================================
Assignment Operators
The same shorthand syntax applies to the multiplication, division, and modulus operators.

x *= 8; // equivalent to x = x * 8
x /= 5; // equivalent to x = x / 5
x %= 2; // equivalent to x = x % 2
The same shorthand syntax applies to the multiplication, division, and modulus operators.
===================================================================
Increment Operator
The increment operator is used to increase an integer's value by one, and is a commonly used C# operator.

x++; //equivalent to x = x + 1
For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 10;
            x++;
            Console.WriteLine(x);
        }
    }
}
OUTPUT
11

The increment operator is used to increase an integer's value by one.
===================================================================
Prefix & Postfix Forms
The increment operator has two forms, prefix and postfix.

++x; //prefix
x++; //postfix
Prefix increments the value, and then proceeds with the expression.
Postfix evaluates the expression and then performs the incrementing.

Prefix example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 3;
            int y = ++x;
            Console.WriteLine(x+" "+y);
        }
    }
}
OUTPUT
4 4

Postfix example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 3;
            int y = x++;
            Console.WriteLine(x+" "+y);
        }
    }
}
OUTPUT
4 4

The prefix example increments the value of x, and then assigns it to y.
The postfix example assigns the value of x to y, and then increments x.
===================================================================
Decrement Operator
The decrement operator (--) works in much the same way as the increment operator, but instead of increasing the value, it decreases it by one.

--x; // prefix
x--; // postfix
The decrement operator (--) works in much the same way as the increment operator.
===================================================================
++=====================++
++=====================++ Conditionals and Loops:: The if-else Statement
The if Statement
The if statement is a conditional statement that executes a block of code when a condition is true.

The general form of the if statement is:
if (condition)
{
    // Execute this code when condition is true
}
The condition can be any expression that returns true or false.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 8;
            int y = 3;
            
            if (x > y)
            { 
                Console.WriteLine("x is greater than y");
            }
        }
    }
}

The code above will evaluate the condition x > y. If it is true, the code inside the if block will execute.

When only one line of code is in the if block, the curly braces can be omitted.
For example:
if (x > y)
Console.WriteLine("x is greater than y");
===================================================================
Relational Operators
Use relational operators to evaluate conditions. In addition to the less than (<) and greater than (>) operators, the following operators are available:

img-component
Example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int a=7, b=7;
            if (a == b) {
                Console.WriteLine("Equal");
            }
        }
    }
}

OUTPUT
Equal
===================================================================
The else Clause
An optional else clause can be specified to execute a block of code when the condition in the if statement evaluates to false.

Syntax:
if (condition) 
{
   //statements
}
else 
{
   //statements
}
For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int mark = 85;
            
            if (mark < 50) 
            {
                Console.WriteLine("You failed.");
            }
            else
            {
                Console.WriteLine("You passed.");
            }
        }
    }
}
OUTPUT
You passed.
===================================================================
Nested if Statements
You can also include, or nest, if statements within another if statement.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int mark = 100;
            
            if (mark >= 50) {
                Console.WriteLine("You passed.");
                if (mark == 100) {
                    Console.WriteLine("Perfect!");
                }
            }
            else {
                Console.WriteLine("You failed.");
            }
        }
    }
}
OUTPUT
You passed.
Perfect!

You can nest an unlimited number of if-else statements.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = 17;
            if (age > 14) {
                if(age > 18) {
                    Console.WriteLine("Adult");
                }
                else {
                    Console.WriteLine("Teenager");
                }
            }
            else {
                if (age > 0) {
                    Console.WriteLine("Child");
                }
                else {
                    Console.WriteLine("Something's wrong");
                }
            }
        }
    }
}
OUTPUT
You passed.
Perfect!

Remember that all else clauses must have corresponding if statements.
===================================================================
The if-else if Statement
The if-else if statement can be used to decide among three or more actions.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 33;
            
            if (x == 8) {
                Console.WriteLine("Value of x is 8");
            }
            else if (x == 18) {
                Console.WriteLine("Value of x is 18");
            }
            else if (x == 33) {
                Console.WriteLine("Value of x is 33");
            }
            else {
                Console.WriteLine("No match");
            }
        }
    }
}
OUTPUT
Value of x is 33

Remember, that an if can have zero or more else if's and they must come before the last else, which is optional.
Once an else if succeeds, none of the remaining else if's or else clause will be tested.
===================================================================
++=====================++
++=====================++ The switch Statement
switch
The switch statement provides a more elegant way to test a variable for equality against a list of values.
Each value is called a case, and the variable being switched on is checked for each switch case.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int num = 3;
            switch (num)
            {
                case 1:
                    Console.WriteLine("one");
                    break;
                case 2:
                    Console.WriteLine("two");
                    break;
                case 3:
                    Console.WriteLine("three");
                    break;
            }
        }
    }
}
OUTPUT
three

Each case represents a value to be checked, followed by a colon, and the statements to get executed if that case is matched.

A switch statement can include any number of cases. However, no two case labels may contain the same constant value.
The break; statement that ends each case will be covered shortly.
===================================================================
The default Case
In a switch statement, the optional default case is executed when none of the previous cases match.

Example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = 88;
            switch (age) {
                case 16:
                    Console.WriteLine("Too young");
                    break;
                case 42:
                    Console.WriteLine("Adult");
                    break;
                case 70:
                    Console.WriteLine("Senior");
                    break;
                default:
                    Console.WriteLine("The default case");
                    break;
            }
        }
    }
}
OUTPUT
The default case

The default code executes when none of the cases matches the switch expression.
===================================================================
The break Statement
The role of the break statement is to terminate the switch statement.
Without it, execution continues past the matching case statements and falls through to the next case statements, even when the case labels don’t match the switch variable.
This behavior is called fallthrough and modern C# compilers will not compile such code. All case and default code must end with a break statement.

The break statement can also be used to break out of a loop. You will learn about loops in the coming lessons.
===================================================================
++=====================++
++=====================++ The while Loop
while
A while loop repeatedly executes a block of code as long as a given condition is true.

For example, the following code displays the numbers 1 through 5:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int num = 1;
            while(num < 6) 
            {
                Console.WriteLine(num);
                num++;
            }
        }
    }
}
OUTPUT
1
2
3
4
5

The example above declares a variable equal to 1 (int num = 1). The while loop checks the condition (num < 6) and, if true, executes the statements in its body, which increment the value of num by one, before checking the loop condition again.

After the 5th iteration, num equals 6, the condition evaluates to false, and the loop stops running.

The loop body is the block of statements within curly braces.
===================================================================
The while Loop
The compound arithmetic operators can be used to further control the number of times a loop runs.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int num = 1;
            while(num < 6) 
            {
                Console.WriteLine(num);
                num+=2;
            }
        }
    }
}
OUTPUT
1
3
5

Without a statement that eventually evaluates the loop condition to false, the loop will continue indefinitely.
===================================================================
The while Loop
We can shorten the previous example, by incrementing the value of num right in the condition:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int num = 0;
            while(++num < 6) 
                Console.WriteLine(num);
        }
    }
}
OUTPUT
1
2
3
4
5

What do you think, is there a difference between while(num++ < 6) and while(++num < 6)?
Yes! The loop while(++num < 6) will execute 5 times, because pre-increment increases the value of x before checking the num < 6 condition, while post-increment will check the condition before increasing the value of num, making while(num++ < 6) execute 6 times.
===================================================================
++=====================++
++=====================++ The for Loop
The for Loop
A for loop executes a set of statements a specific number of times, and has the syntax:

for ( init; condition; increment ) {
  statement(s);
}
A counter is declared once in init.
Next, the condition evaluates the value of the counter and the body of the loop is executed if the condition is true.
After loop execution, the increment statement updates the counter, also called the loop control variable.
The condition is again evaluated, and the loop body repeats, only stopping when the condition becomes false.

For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int x = 10; x < 15; x++)
            {
                Console.WriteLine("Value of x: {0}", x);
            }
        }
    }
}
OUTPUT
Value of x: 10
Value of x: 11
Value of x: 12
Value of x: 13
Value of x: 14

Note the semicolons in the syntax.
===================================================================
The for Loop
Compound arithmetic operators can be used to further control loop iterations.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int x = 0; x < 10; x+=3)
            {
                Console.WriteLine(x);
            }
        }
    }
}
OUTPUT
0
3
6
9

You can also decrement the counter:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int x = 10; x > 0; x-=2)
            {
                Console.WriteLine(x);
            }
        }
    }
}
OUTPUT
0
3
6
9
===================================================================
The for Loop
The init and increment statements may be left out, if not needed, but remember that the semicolons are mandatory.

For example, the init can be left out:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 10;
            for ( ; x > 0; x -= 3)
            {
                Console.WriteLine(x);
            }
        }
    }
}
OUTPUT
10
7
4
1

You can have the increment statement in the for loop body:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 10;
            for ( ; x > 0 ; )
            {
                Console.WriteLine(x);
                x -= 3;
            }
        }
    }
}
OUTPUT
10
7
4
1

for (; ;) {} is an infinite loop.
===================================================================
++=====================++
++=====================++ The do-while Loop
do-while
A do-while loop is similar to a while loop, except that a do-while loop is guaranteed to execute at least one time.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 0;
            do {
                Console.WriteLine(a);
                a++;
            } while(a < 5);
        }
    }
}
OUTPUT
0
1
2
3
4

Note the semicolon after the while statement.
===================================================================
do-while vs. while
If the condition of the do-while loop evaluates to false, the statements in the do will still run once:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 42;
            do {
                Console.WriteLine(x);
                x++;
            } while(x < 10);
        }
    }
}
OUTPUT
42

The do-while loop executes the statements at least once, and then tests the condition.
The while loop executes the statement only after testing condition.
===================================================================
break and continue

break
We saw the use of break in the switch statement.
Another use of break is in loops: When the break statement is encountered inside a loop, the loop is immediately terminated and the program execution moves on to the next statement following the loop body.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int num = 0;
            while (num < 20)
            {
                if (num == 5)
                    break;

                Console.WriteLine(num);
                num++;
            }
        }
    }
}
OUTPUT
0
1
2
3
4

If you are using nested loops (i.e., one loop inside another loop), the break statement will stop the execution of the innermost loop and start executing the next line of code after the block.
===================================================================
continue
The continue statement is similar to the break statement, but instead of terminating the loop entirely, it skips the current iteration of the loop and continues with the next iteration.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int i = 0; i < 10; i++) {
                if (i == 5)
                    continue;

                Console.WriteLine(i);
            }
        }
    }
}
OUTPUT
0
1
2
3
4
6
7
8
9

As you can see, number 5 is not printed, as the continue statement skips the remaining statements of that iteration of the loop.
===================================================================
++=====================++
++=====================++ Logical Operators
Logical Operators
Logical operators are used to join multiple expressions and return true or false.

img-component
The AND operator (&&) works the following way:

img-component
For example, if you wish to display text to the screen only if age is greater than 18 AND money is greater than 100:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = 42;
            double money = 540;
            if(age > 18 && money > 100) {
                Console.WriteLine("Welcome");
            }
        }
    }
}
OUTPUT
Welcome

The AND operator was used to combine the two expressions.

With the AND operator, both operands must be true for the entire expression to be true.
===================================================================
AND
You can join more than two conditions:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = 42;
            int grade = 75;
            if(age > 16 && age < 80 && grade > 50) 
                Console.WriteLine("Hey there");
        }
    }
}
OUTPUT
Hey there

The entire expression evaluates to true only if all of the conditions are true.
===================================================================
The OR Operator
The OR operator (||) returns true if any one of its operands is true.

img-component
For Example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = 18;
            int score = 85;
            if (age > 20 || score > 50) {
                Console.WriteLine("Welcome");
            }
        }
    }
}
OUTPUT
Welcome

You can join any number of logical OR statements you want.
In addition, multiple OR and AND statements may be joined together.
===================================================================
Logical NOT
The logical NOT (!) operator works with just a single operand, reversing its logical state. Thus, if a condition is true, the NOT operator makes it false, and vice versa.

img-component

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = 8;
            if ( !(age > 16) ) {
                Console.Write("Your age is less than 16");
            }
        }
    }
}
OUTPUT
Your age is less than 16
===================================================================
++=====================++
++=====================++ The Conditional Operator
The ? : Operator
Consider the following example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = 42;
            string msg;
            if(age >= 18)
                msg = "Welcome";
            else
                msg = "Sorry";

            Console.WriteLine(msg);
        }
    }
}
OUTPUT
Welcome

The code above checks the value of the age variable and displays the corresponding message to the screen.
This can be done in a more elegant and shorter way by using the ?: operator, which has the following form:

Exp1 ? Exp2 : Exp3;
The ?: operator works the following way: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire expression. If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression.
So, the example above can be replaced by the following:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int age = 42;
            string msg;
            msg = (age >= 18) ? "Welcome" : "Sorry";
            Console.WriteLine(msg);
        }
    }
}
OUTPUT
Welcome
===================================================================
++=====================++
++=====================++ Basic Calculator
Basic Calculator
Now let's create a simple project that repeatedly asks the user to enter two values and then displays their sum, until the user enters exit.
We start with a do-while loop that asks the user for input and calculates the sum:

do {
  Console.Write("x = ");
  int x = Convert.ToInt32(Console.ReadLine());

  Console.Write("y = ");
  int y = Convert.ToInt32(Console.ReadLine());

  int sum = x+y;
  Console.WriteLine("Result: {0}", sum);
}
while(true);
This code will ask for user input infinitely. Now we need to handle the "exit".

If the user enters a non-integer value, the program will crash from a conversion error. We will learn how to handle errors like that in the coming modules.
===================================================================
Basic Calculator
If the user enters "exit" as the value of x, the program should quit the loop. To do this, we can use a break statement:

Console.Write("x = ");
string str = Console.ReadLine();
if (str == "exit")
  break;

int x = Convert.ToInt32(str);
Here we compare the input with the value "exit" and break the loop.

So the whole program looks like:
do {
  Console.Write("x = ");
  string str = Console.ReadLine();
  if (str == "exit")
    break;

  int x = Convert.ToInt32(str);

  Console.Write("y = ");
  int y = Convert.ToInt32(Console.ReadLine());

  int sum = x + y;
  Console.WriteLine("Result: {0}", sum);
}
while (true);
If the user enters "exit" as the value of x, the program should quit the loop.
===================================================================
++=====================++
++=====================++ Methods:: Introduction to Methods
What is a Method?
A method is a group of statements that perform a particular task.
In addition to the C# built-in methods, you may also define your own.

Methods have many advantages, including:
- Reusable code.
- Easy to test.
- Modifications to a method do not affect the calling program.
- One method can accept many different inputs.

Every valid C# program has at least one method, the Main method.
===================================================================
Declaring Methods
To use a method, you need to declare the method and then call it.
Each method declaration includes:
- the return type
- the method name
- an optional list of parameters.

<return type> name(type1 par1, type2 par2, … , typeN parN)
{
    List of statements
}
For example, the following method has an int parameter and returns the number squared:

int Sqr(int x)
{
  int result = x*x;
  return result;
}
The return type of a method is declared before its name. In the example above, the return type is int, which indicates that the method returns an integer value. When a method returns a value, it must include a return statement. Methods that return a value are often used in assignment statements.
Occasionally, a method performs the desired operations without returning a value. Such methods have a return type void. In this case, the method cannot be called as part of an assignment statement.

void is a basic data type that defines a valueless state.
===================================================================
Calling Methods
Parameters are optional; that is, you can have a method with no parameters.
As an example, let's define a method that does not return a value, and just prints a line of text to the screen.

static void SayHi()
{
  Console.WriteLine("Hello");
}
Our method, entitled SayHi, returns void, and has no parameters.
To execute a method, you simply call the method by using the name and any required arguments in a statement.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void sayHi()
        {
            Console.WriteLine("Hello");
        }
        static void Main(string[] args)
        {
            sayHi();
        }
    }
}
OUTPUT
Hello

The static keyword will be discussed later; it is used to make methods accessible in Main.
===================================================================
Calling Methods
You can call the same method multiple times:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void SayHi()
        {
            Console.WriteLine("Hello");
        }
        static void Main(string[] args)
        {
            SayHi();
            SayHi();
            SayHi();
        }
    }
}
OUTPUT
Hello
Hello
Hello
===================================================================
++=====================++
++=====================++ Method Parameters
Parameters
Method declarations can define a list of parameters to work with.
Parameters are variables that accept the values passed into the method when called.

For example:
void Print(int x) 
{
  Console.WriteLine(x);
}
This defines a method that takes one integer parameter and displays its value.

Parameters behave within the method similarly to other local variables. They are created upon entering the method and are destroyed upon exiting the method.
===================================================================
Parameters
Now you can call the method in Main and pass in the value for its parameters (also called arguments):

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Print(int x) 
        {
            Console.WriteLine(x);
        }
        static void Main(string[] args)
        {
            Print(42);
        }
    }
}
OUTPUT
42

The value 42 is passed to the method as an argument and is assigned to the formal parameter x.
===================================================================
Parameters
You can pass different arguments to the same method as long as they are of the expected type.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Func(int x)
        {
            Console.WriteLine(x*2);
        }
        static void Main(string[] args)
        {
            Func(5);
  
            Func(12);

            Func(42);
        }
    }
}
OUTPUT
10
24
84
===================================================================
++=====================++
++=====================++ Multiple Parameters
Multiple Parameters
You can have as many parameters as needed for a method by separating them with commas in the definition.
Let's create a simple method that returns the sum of two parameters:

int Sum(int x, int y)
{
   return x+y;
}
The Sum method takes two integers and returns their sum. This is why the return type of the method is int. Data type and name should be defined for each parameter.

Methods return values using the return statement.
===================================================================
Multiple Parameters
A method call with multiple parameters must separate arguments with commas.
For example, a call to Sum requires two arguments:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static int Sum(int x, int y)
        {
            return x+y;
        }
        static void Main(string[] args)
        {
            Console.WriteLine(Sum(8, 6));
        }
    }
}
OUTPUT
14

In the call above, the return value was displayed to the console window. Alternatively, we can assign the return value to a variable, as in the code below:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static int Sum(int x, int y)
        {
            return x+y;
        }
        static void Main(string[] args)
        {
            int res = Sum(11, 42);
            Console.WriteLine(res);
        }
    }
}
OUTPUT
14

You can add as many parameters to a single method as you want. If you have multiple parameters, remember to separate them with commas, both when declaring them and when calling the method.
===================================================================
++=====================++
++=====================++ Optional & Named Arguments
Optional Arguments
When defining a method, you can specify a default value for optional parameters. Note that optional parameters must be defined after required parameters. If corresponding arguments are missing when the method is called, the method uses the default values.
To do this, assign values to the parameters in the method definition, as shown in this example.

static int Pow(int x, int y=2)
{
  int result = 1;
  for (int i = 0; i < y; i++)
  {
    result *= x;
  }
 
  return result;
}
The Pow method assigns a default value of 2 to the y parameter. If we call the method without passing the value for the y parameter, the default value will be used.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static int Pow(int x, int y=2)
        {
            int result = 1;
            for (int i = 0; i < y; i++)
            {
                result *= x;
            }
            return result;
        }
        static void Main(string[] args)
        {
            Console.WriteLine(Pow(6));

            Console.WriteLine(Pow(3, 4));
        }
    }
}
OUTPUT
36
81

As you can see, default parameter values can be used for calling the same method in different situations without requiring arguments for every parameter.
Just remember, that you must have the parameters with default values at the end of the parameter list when defining the method.
===================================================================
Named Arguments
Named arguments free you from the need to remember the order of the parameters in a method call. Each argument can be specified by the matching parameter name.
For example, the following method calculates the area of a rectangle by its height and width:

static int Area(int h, int w)
{
  return h * w;
}
When calling the method, you can use the parameter names to provide the arguments in any order you like:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static int Area(int h, int w)
        {
            return h * w;
        }
        static void Main(string[] args)
        {
            int res = Area(w: 5, h: 8);
            Console.WriteLine(res);
        }
    }
}
OUTPUT
40

Named arguments use the name of the parameter followed by a colon and the value.
===================================================================
++=====================++
++=====================++ Passing Arguments
Passing Arguments
There are three ways to pass arguments to a method when the method is called: By value, By reference, and as Output.

By value copies the argument's value into the method's formal parameter. Here, we can make changes to the parameter within the method without having any effect on the argument.

By default, C# uses call by value to pass arguments.

The following example demonstrates by value:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Sqr(int x)
        {
            x = x * x;
        }
        static void Main(string[] args)
        {
            int a = 3;
            Sqr(a);
            
            Console.WriteLine(a);
        }
    }
}
OUTPUT
3

In this case, x is the parameter of the Sqr method and a is the actual argument passed into the method.

As you can see, the Sqr method does not change the original value of the variable, as it is passed by value, meaning that it operates on the value, not the actual variable.
===================================================================
Passing by Reference
Pass by reference copies an argument's memory address into the formal parameter. Inside the method, the address is used to access the actual argument used in the call. This means that changes made to the parameter affect the argument.
To pass the value by reference, the ref keyword is used in both the call and the method definition:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Sqr(ref int x)
        {
            x = x * x;
        }
        static void Main(string[] args)
        {
            int a = 3;
            Sqr(ref a);
            
            Console.WriteLine(a);
        }
    }
}
OUTPUT
9

The ref keyword passes the memory address to the method parameter, which allows the method to operate on the actual variable.

The ref keyword is used both when defining the method and when calling it.
===================================================================
Passing by Output
Output parameters are similar to reference parameters, except that they transfer data out of the method rather than accept data in. They are defined using the out keyword.
The variable supplied for the output parameter need not be initialized since that value will not be used. Output parameters are particularly useful when you need to return multiple values from a method.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void GetValues(out int x, out int y)
        {
            x = 5;
            y = 42;
        }
        static void Main(string[] args)
        {
            int a, b;
            GetValues(out a, out b);
            Console.WriteLine(a+" "+b);
        }
    }
}
OUTPUT
5 42

Unlike the previous reference type example, where the value 3 was referred to the method, which changed its value to 9, output parameters get their value from the method (5 and 42 in the above example).

Similar to the ref keyword, the out keyword is used both when defining the method and when calling it.
===================================================================
++=====================++
++=====================++ Method Overloading
Overloading
Method overloading is when multiple methods have the same name, but different parameters.
For example, you might have a Print method that outputs its parameter to the console window:

void Print(int a)
{
  Console.WriteLine("Value: "+a);
}
The + operator is used to concatenate values. In this case, the value of a is joined to the text "Value: ".
This method accepts an integer argument only.
Overloading it will make it available for other types, such as double:

void Print(double a)
{
  Console.WriteLine("Value: "+a);
}
Now, the same Print method name will work for both integers and doubles.
===================================================================
Overloading
When overloading methods, the definitions of the methods must differ from each other by the types and/or number of parameters.
When there are overloaded methods, the method called is based on the arguments. An integer argument will call the method implementation that accepts an integer parameter. A double argument will call the implementation that accepts a double parameter. Multiple arguments will call the implementation that accepts the same number of arguments.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Print(int a) {
            Console.WriteLine("Value: " + a);
        }
        static void Print(double a) {
            Console.WriteLine("Value: " + a);
        }
        static void Print(string label, double a) {
            Console.WriteLine(label + a);
        }
        static void Main(string[] args)
        {
            Print(11);
            Print(4.13);
            Print("Average: ", 7.57);
        }
    }
}
OUTPUT
Value: 11
Value: 4.13
Average: 7.57

You cannot overload method declarations that differ only by return type.
The following declaration results in an error.
int PrintName(int a) { }
float PrintName(int b) { }
double PrintName(int c) { }
===================================================================
++=====================++
++=====================++ Recursion
Recursion
A recursive method is a method that calls itself.
One of the classic tasks that can be solved easily by recursion is calculating the factorial of a number.
In mathematics, the term factorial refers to the product of all positive integers that are less than or equal to a specific non-negative integer (n). The factorial of n is denoted as n!

For example:
4! = 4 * 3 * 2 * 1 = 24

A recursive method is a method that calls itself.
===================================================================
Recursion
As you can see, a factorial can be thought of as repeatedly calculating num * num-1 until you reach 1.
Based on this solution, let's define our method:

static int Fact(int num) {
  if (num == 1) {
    return 1;
  }
  return num * Fact(num - 1);
}
In the Fact recursive method, the if statement defines the exit condition, a base case that requires no recursion. In this case, when num equals one, the solution is simply to return 1 (the factorial of one is one).
The recursive call is placed after the exit condition and returns num multiplied by the factorial of n-1.
For example, if you call the Fact method with the argument 4, it will execute as follows:
return 4*Fact(3), which is 4*3*Fact(2), which is 4*3*2*Fact(1), which is 4*3*2*1.

Now we can call our Fact method from Main:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static int Fact(int num) {
            if (num == 1) {
                return 1;
            }
            return num * Fact(num - 1);
        }
        static void Main(string[] args)
        {
            Console.WriteLine(Fact(6));
        }
    }
}

The factorial method calls itself, and then continues to do so, until the argument equals 1. The exit condition prevents the method from calling itself indefinitely.
===================================================================
++=====================++
++=====================++ Making a Pyramid
Making a Pyramid
Now, let's create a method that will display a pyramid of any height to the console window using star (*) symbols.
Based on this description, a parameter will be defined to reflect the number of rows for the pyramid.

So, let's start by declaring the method:
static void DrawPyramid(int n)
{
   //some code will go here
}
DrawPyramid does not need to return a value and takes an integer parameter n.
In programming, the step by step logic required for the solution to a problem is called an algorithm. The algorithm for MakePyramid is:
1. The first row should contain one star at the top center of the pyramid. The center is calculated based on the number of rows in the pyramid.
2. Each row after the first should contain an odd number of stars (1, 3, 5, etc.), until the number of rows is reached.

Based on the algorithm, the code will use for loops to display spaces and stars for each row:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
  class Program
  {
    static void DrawPyramid(int n)
    {
      for (int i=1; i<=n; i++)
      {
        for (int j=i; j<=n; j++)
        {
          Console.Write("  ");
        }
        for (int k=1; k<=2*i-1; k++)
        {
          Console.Write("*"+" ");
        }
        Console.WriteLine();
      }
    }
    static void Main(string[] args)
    {
      DrawPyramid(5);
    }
  }
}
          * 
        * * * 
      * * * * * 
    * * * * * * * 
  * * * * * * * * * 
  
The first for loop that iterates through each row of the pyramid contains two for loops.
The first inner loop displays the spaces needed before the first star symbol. The second inner loop displays the required number of stars for each row, which is calculated based on the formula (2*i-1) where i is the current row.
The final Console.WriteLine(); statement moves the cursor to the next row.

Now, if we call the DrawPyramid method, it will display a pyramid having the number of rows we pass to the method.
===================================================================
++=====================++
++=====================++ Classes & Objects:: Classes & Objects
Classes
As we have seen in the previous modules, built-in data types are used to store a single value in a declared variable. For example, int x stores an integer value in a variable named x.
In object-oriented programming, a class is a data type that defines a set of variables and methods for a declared object.
For example, if you were to create a program that manages bank accounts, a BankAccount class could be used to declare an object that would have all the properties and methods needed for managing an individual bank account, such as a balance variable and Deposit and Withdrawal methods.

A class is like a blueprint. It defines the data and behavior for a type. A class definition starts with the keyword class followed by the class name. The class body contains the data and actions enclosed by curly braces.

class BankAccount
{
  //variables, methods, etc.
}
The class defines a data type for objects, but it is not an object itself. An object is a concrete entity based on a class, and is sometimes referred to as an instance of a class.
===================================================================
Objects
Just as a built-in data type is used to declare multiple variables, a class can be used to declare multiple objects. As an analogy, in preparation for a new building, the architect designs a blueprint, which is used as a basis for actually building the structure. That same blueprint can be used to create multiple buildings.
Programming works in the same fashion. We define (design) a class that is the blueprint for creating objects.
In programming, the term type is used to refer to a class name: We're creating an object of a particular type.

Once we've written the class, we can create objects based on that class. Creating an object is called instantiation.

An object is called an instance of a class.
===================================================================
Objects
Each object has its own characteristics. Just as a person is distinguished by name, age, and gender, an object has its own set of values that differentiate it from another object of the same type.
The characteristics of an object are called properties.
Values of these properties describe the current state of an object. For example, a Person (an object of the class Person) can be 30 years old, male, and named Antonio.

Objects aren't always representative of just physical characteristics.
For example, a programming object can represent a date, a time, and a bank account. A bank account is not tangible; you can't see it or touch it, but it's still a well-defined object because it has its own properties.

Let's move on and see how to create your own custom classes and objects!
===================================================================
++=====================++
++=====================++ Value & Reference Types
Value Types
C# has two ways of storing data: by reference and by value.
The built-in data types, such as int and double, are used to declare variables that are value types. Their value is stored in memory in a location called the stack.
For example, the declaration and assignment statement int x = 10; can be thought of as:

img-component
The value of the variable x is now stored on the stack.
===================================================================
Reference Types
Reference types are used for storing objects. For example, when you create an object of a class, it is stored as a reference type.
Reference types are stored in a part of the memory called the heap.
When you instantiate an object, the data for that object is stored on the heap, while its heap memory address is stored on the stack.
That is why it is called a reference type - it contains a reference (the memory address) to the actual object on the heap.

img-component
As you can see, the p1 object of type Person on the stack stores the memory address of the heap where the actual object is stored.

Stack is used for static memory allocation, which includes all your value types, like x.
Heap is used for dynamic memory allocation, which includes custom objects, that might need additional memory during the runtime of your program.
===================================================================
++=====================++
++=====================++ Class Example
Example of a Class
Let’s create a Person class:

class Person
{
  int age;
  string name;
  public void SayHi()
  {
    Console.WriteLine("Hi");
  }
}
The code above declares a class named Person, which has age and name fields as well as a SayHi method that displays a greeting to the screen.
You can include an access modifier for fields and methods (also called members) of a class. Access modifiers are keywords used to specify the accessibility of a member.
A member that has been defined public can be accessed from outside the class, as long as it's anywhere within the scope of the class object. That is why our SayHi method is declared public, as we are going to call it from outside of the class.

You can also designate class members as private or protected. This will be discussed in greater detail later in the course. If no access modifier is defined, the member is private by default.
===================================================================
Example of a Class
Now that we have our Person class defined, we can instantiate an object of that type in Main.
The new operator instantiates an object and returns a reference to its location:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person {
            int age;
            string name;
            public void SayHi() {
                Console.WriteLine("Hi");
            }
        }
        static void Main(string[] args)
        {
            Person p1 = new Person();
            p1.SayHi();
        }
    }
}
OUTPUT
Hi

The code above declares a Person object named p1 and then calls its public SayHi() method.

Notice the dot operator (.) that is used to access and call the method of the object.
===================================================================
Example of a Class
You can access all public members of a class using the dot operator.
Besides calling a method, you can use the dot operator to make an assignment when valid.

For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Dog
        {
            public string name;
            public int age;
        }
        static void Main(string[] args)
        {
            Dog bob = new Dog();
            bob.name = "Bobby";
            bob.age = 3;
            
            Console.WriteLine(bob.age);
        }
    }
}
OUTPUT
3
===================================================================
++=====================++
++=====================++ Encapsulation
Encapsulation
Part of the meaning of the word encapsulation is the idea of "surrounding" an entity, not just to keep what's inside together, but also to protect it.
In programming, encapsulation means more than simply combining members together within a class; it also means restricting access to the inner workings of that class.
Encapsulation is implemented by using access modifiers. An access modifier defines the scope and visibility of a class member.

Encapsulation is also called information hiding.
===================================================================
Encapsulation
C# supports the following access modifiers: public, private, protected, internal, protected internal.
As seen in the previous examples, the public access modifier makes the member accessible from the outside of the class.
The private access modifier makes members accessible only from within the class and hides them from the outside.

protected will be discussed later in the course.
===================================================================
Encapsulation
To show encapsulation in action, let’s consider the following example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class BankAccount {
        private double balance=0;
        public void Deposit(double n) {
            balance += n;
        }
        public void Withdraw(double n) {
            balance -= n;
        }
        public double GetBalance() {
            return balance;
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            BankAccount b = new BankAccount();
            b.Deposit(199);
            b.Withdraw(42);
            Console.WriteLine(b.GetBalance());
        }
    }
}
OUTPUT
157

We used encapsulation to hide the balance member from the outside code. Then we provided restricted access to it using public methods. The class data can be read through the GetBalance method and modified only through the Deposit and Withdraw methods.
You cannot directly change the balance variable. You can only view its value using the public method. This helps maintain data integrity.
We could add different verification and checking mechanisms to the methods to provide additional security and prevent errors.

In summary, the benefits of encapsulation are:
- Control the way data is accessed or modified.
- Code is more flexible and easy to change with new requirements.
- Change one part of code without affecting other parts of code.
===================================================================
Constructors
A class constructor is a special member method of a class that is executed whenever a new object of that class is created.
A constructor has exactly the same name as its class, is public, and does not have any return type.

For example:
class Person
{
  private int age;
  public Person()
  {
    Console.WriteLine("Hi there");
  }
}
Now, upon the creation of an object of type Person, the constructor is automatically called.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person
        {
            private int age;
            public Person()
            {
                Console.WriteLine("Hi there");
            }
        }
        static void Main(string[] args)
        {
            Person p = new Person();
        }
    }
}
OUTPUT
Hi there

This can be useful in a number of situations. For example, when creating an object of type BankAccount, you could send an email notification to the owner.
The same functionality could be achieved using a separate public method. The advantage of the constructor is that it is called automatically.
===================================================================
Constructors
Constructors can be very useful for setting initial values for certain member variables.
A default constructor has no parameters. However, when needed, parameters can be added to a constructor. This makes it possible to assign an initial value to an object when it's created, as shown in the following example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person
        {
            private int age;
            private string name;
            public Person(string nm)
            {
                name = nm;
            }
            public string getName()
            {
                return name;
            }
        }
        static void Main(string[] args)
        {
            Person p = new Person("David");
            Console.WriteLine(p.getName());
        }
    }
}
OUTPUT
David

Now, when the object is created, we can pass a parameter that will be assigned to the name variable.

Constructors can be overloaded like any method by using different numbers of parameters.
===================================================================
++=====================++
++=====================++ Properties
Properties
As we have seen in the previous lessons, it is a good practice to encapsulate members of a class and provide access to them only through public methods.
A property is a member that provides a flexible mechanism to read, write, or compute the value of a private field. Properties can be used as if they are public data members, but they actually include special methods called accessors.
The accessor of a property contains the executable statements that help in getting (reading or computing) or setting (writing) a corresponding field. Accessor declarations can include a get accessor, a set accessor, or both.

For example:
class Person
{
  private string name; //field

  public string Name //property
  {
    get { return name; }
    set { name = value; }
  }
}
The Person class has a Name property that has both the set and the get accessors.
The set accessor is used to assign a value to the name variable; get is used to return its value.

value is a special keyword, which represents the value we assign to a property using the set accessor.
The name of the property can be anything you want, but coding conventions dictate properties have the same name as the private field with a capital letter.
===================================================================
Properties
Once the property is defined, we can use it to assign and read the private member:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person
        {
            private string name;
            public string Name
            {
                get { return name; }
                set { name = value; }
            }
        }
        static void Main(string[] args)
        {
            Person p = new Person();
            p.Name = "Bob";
            Console.WriteLine(p.Name);
        }
    }
}
OUTPUT
Bob

The property is accessed by its name, just like any other public member of the class.
===================================================================
Properties
Any accessor of a property can be omitted.
For example, the following code creates a property that is read-only:

class Person
{
  private string name;
  public string Name
  {
    get { return name; }
  }
}
A property can also be private, so it can be called only from within the class.
===================================================================
Properties
So, why use properties? Why not just declare the member variable public and access it directly?
With properties you have the option to control the logic of accessing the variable.
For example, you can check if the value of age is greater than 0, before assigning it to the variable:

class Person
{
  private int age=0;
  public int Age
  {
    get { return age; }
    set {
      if (value > 0)
        age = value;
    }
  }
}
You can have any custom logic with get and set accessors.
===================================================================
Auto-Implemented Properties
When you do not need any custom logic, C# provides a fast and effective mechanism for declaring private members through their properties.
For example, to create a private member that can only be accessed through the Name property's get and set accessors, use the following syntax:

public string Name { get; set; }
As you can see, you do not need to declare the private field name separately - it is created by the property automatically. Name is called an auto-implemented property. Also called auto-properties, they allow for easy and short declaration of private members.
We can rewrite the code from our previous example using an auto-property:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person
        {
            public string Name { get; set; }
        }
        static void Main(string[] args)
        {
            Person p = new Person();
            p.Name = "Bob";
            Console.WriteLine(p.Name);
        }
    }
}
OUTPUT
Bob
===================================================================
++=====================++
++=====================++ Arrays
Arrays
C# provides numerous built-in classes to store and manipulate data.
One example of such a class is the Array class.
An array is a data structure that is used to store a collection of data. You can think of it as a collection of variables of the same type.
For example, consider a situation where you need to store 100 numbers. Rather than declare 100 different variables, you can just declare an array that stores 100 elements.
To declare an array, specify its element types with square brackets:

int[ ] myArray;
This statement declares an array of integers.
Since arrays are objects, we need to instantiate them with the new keyword:

int[ ] myArray = new int[5];
This instantiates an array named myArray that holds 5 integers.

Note the square brackets used to define the number of elements the array should hold.
===================================================================
Arrays
After creating the array, you can assign values to individual elements by using the index number:

int[ ] myArray = new int[5];
myArray[0] = 23;
This will assign the value 23 to the first element of the array.

Arrays in C# are zero-indexed meaning the first member has index 0, the second has index 1, and so on.
===================================================================
Arrays
We can provide initial values to the array when it is declared by using curly brackets:

string[ ] names = new string[3] {"John", "Mary", "Jessica"};
double[ ] prices = new double[4] {3.6, 9.8, 6.4, 5.9};
We can omit the size declaration when the number of elements are provided in the curly braces:

string[ ] names = new string[ ] {"John", "Mary", "Jessica"};
double[ ] prices = new double[ ] {3.6, 9.8, 6.4, 5.9};
We can even omit the new operator. The following statements are identical to the ones above:

string[ ] names = {"John", "Mary", "Jessica"};
double[ ] prices = {3.6, 9.8, 6.4, 5.9};
Array values should be provided in a comma separated list enclosed in {curly braces}.
===================================================================
Arrays
As mentioned, each element of an array has an index number.

For example, consider the following array:
int[ ] b = {11, 45, 62, 70, 88};
The elements of b have the following indexes:

img-component
To access individual array elements, place the element's index number in square brackets following the array name.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] b = {11, 45, 62, 70, 88};

            Console.WriteLine(b[2]);
            Console.WriteLine(b[3]);
        }
    }
}
OUTPUT
62
70

Remember that the first element has index 0.
===================================================================
++=====================++
++=====================++ Using Arrays in Loops
Arrays & Loops
It's occasionally necessary to iterate through the elements of an array, making element assignments based on certain calculations. This can be easily done using loops.
For example, you can declare an array of 10 integers and assign each element an even value with the following loop:

int[ ] a = new int[10];
for (int k = 0; k < 10; k++) {
  a[k] = k*2;
}
We can also use a loop to read the values of an array.
For example, we can display the contents of the array we just created:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] a = new int[10];
            for (int k = 0; k < 10; k++) {
                a[k] = k*2;
            }
            for (int k = 0; k < 10; k++) {
                Console.WriteLine(a[k]);
            }
        }
    }
}
OUTPUT
0
2
4
6
8
10
12
14
16
18

This will display the values of the elements of the array.

The variable k is used to access each array element.
The last index in the array is 9, so the for loop condition is k<10.
===================================================================
The foreach Loop
The foreach loop provides a shorter and easier way of accessing array elements.
The previous example of accessing the elements could be written using a foreach loop:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] a = new int[10];
            for (int k = 0; k < 10; k++) {
                a[k] = k*2;
            }
            foreach (int k in a) {
                Console.WriteLine(k);
            }
        }
    }
}
OUTPUT
0
2
4
6
8
10
12
14
16
18

The foreach loop iterates through the array a and assigns the value of the current element to the variable k at each iteration of the loop. So, at the first iteration, k=a[0], at the second, k=a[1], etc.

The data type of the variable in the foreach loop should match the type of the array elements.
Often the keyword var is used as the type of the variable, as in: foreach (var k in a). The compiler determines the appropriate type for var.
===================================================================
Arrays
The following code uses a foreach loop to calculate the sum of all the elements of an array:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] arr = {11, 35, 62, 555, 989};
            int sum = 0; 
            
            foreach (int x in arr) {
                sum += x;
            }
            Console.WriteLine(sum);
        }
    }
}
OUTPUT
1652

To review, we declared an array and a variable sum that will hold the sum of the elements.
Next, we utilized a foreach loop to iterate through each element of the array, adding the corresponding element's value to the sum variable.

The Array class provides some useful methods that will be discussed in the coming lessons.
===================================================================
Multidimensional Arrays
Multidimensional Arrays
An array can have multiple dimensions. A multidimensional array is declared as follows:

type[, , … ,] arrayName = new type[size1, size2, …, sizeN];
For example, let's define a two-dimensional 3x4 integer array:

int[ , ] x = new int[3,4];
Visualize this array as a table composed of 3 rows and 4 columns:

img-component
Array indexing starts from 0.
===================================================================
Multidimensional Arrays
We can initialize multidimensional arrays in the same way as single-dimensional arrays.

For example:
int[ , ] someNums = { {2, 3}, {5, 6}, {4, 6} };
This will create an array with three rows and two columns. Nested curly brackets are used to define values for each row.
To access an element of the array, provide both indexes. For example someNums[2, 0] will return the value 4, as it accesses the first column of the third row.
Let's create a program that will display the values of the array in the form of a table.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ , ] someNums = { {2, 3}, {5, 6}, {4, 6} }; 
            for (int k = 0; k < 3; k++) {
                for (int j = 0; j < 2; j++) {
                    Console.Write(someNums[k, j]+" ");
                }
                Console.WriteLine();
            }
        }
    }
}
OUTPUT
2 3 
5 6 
4 6 

We have used two nested for loops, one to iterate through the rows and one through the columns.
The Console.WriteLine(); statement moves the output to a new line after one row is printed.

Arrays can have any number of dimensions, but keep in mind that arrays with more than three dimensions are harder to manage.
===================================================================
++=====================++
++=====================++ Jagged Arrays
Jagged Arrays
A jagged array is an array whose elements are arrays. So it is basically an array of arrays.
The following is a declaration of a single-dimensional array that has three elements, each of which is a single-dimensional array of integers:

int[ ][ ] jaggedArr = new int[3][ ];
Each dimension is an array, so you can also initialize the array upon declaration like this:

int[ ][ ] jaggedArr = new int[ ][ ] 
{
  new int[ ] {1,8,2,7,9},
  new int[ ] {2,4,6},
  new int[ ] {33,42}
};
You can access individual array elements as shown in the example below:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ][ ] jaggedArr = new int[ ][ ] 
            {
                new int[ ] {1,8,2,7,9},
                new int[ ] {2,4,6},
                new int[ ] {33,42}
            };
            int x = jaggedArr[2][1];
            Console.WriteLine(x);
        }
    }
}
OUTPUT
42

This accesses the second element of the third array.

A jagged array is an array-of-arrays, so an int[ ][ ] is an array of int[ ], each of which can be of different lengths and occupy their own block in memory.
A multidimensional array (int[,]) is a single block of memory (essentially a matrix). It always has the same amount of columns for every row.
===================================================================
++=====================++
++=====================++ Array Properties & Methods
Arrays Properties
The Array class in C# provides various properties and methods to work with arrays.
For example, the Length and Rank properties return the number of elements and the number of dimensions of the array, respectively. You can access them using the dot syntax, just like any class members:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] arr = {2, 4, 7};
            
            Console.WriteLine(arr.Length); 
            
            Console.WriteLine(arr.Rank); 
        }
    }
}
OUTPUT
3
1

The Length property can be useful in for loops where you need to specify the number of times the loop should run.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] arr = {2, 4, 7};
            for(int k=0; k<arr.Length; k++) {
                Console.WriteLine(arr[k]);
            }
        }
    }
}
OUTPUT
3
1
===================================================================
Array Methods
There are a number of methods available for arrays.
Max returns the largest value.
Min returns the smallest value.
Sum returns the sum of all elements.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[ ] arr = { 2, 4, 7, 1};
            Console.WriteLine(arr.Max());
            Console.WriteLine(arr.Min());
            Console.WriteLine(arr.Sum());
        }
    }
}
OUTPUT
7
1
14

C# also provides a static Array class with additional methods. You will learn about those in the next module.
===================================================================
++=====================++
++=====================++ Working with Strings
Strings
It’s common to think of strings as arrays of characters. In reality, strings in C# are objects.
When you declare a string variable, you basically instantiate an object of type String.
String objects support a number of useful properties and methods:
Length returns the length of the string.
IndexOf(value) returns the index of the first occurrence of the value within the string.
Insert(index, value) inserts the value into the string starting from the specified index.
Remove(index) removes all characters in the string from the specified index.
Replace(oldValue, newValue) replaces the specified value in the string.
Substring(index, length) returns a substring of the specified length, starting from the specified index. If length is not specified, the operation continues to the end of the string.
Contains(value) returns true if the string contains the specified value.

The examples below demonstrate each of the String members:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string a = "some text";
            Console.WriteLine(a.Length);
            //Outputs 9

            Console.WriteLine(a.IndexOf('t'));
            //Outputs 5

             a = a.Insert(0, "This is ");
            Console.WriteLine(a);
            //Outputs "This is some text"

            a = a.Replace("This is", "I am");
            Console.WriteLine(a);
            //Outputs "I am some text"

            if(a.Contains("some"))
                Console.WriteLine("found");
            //Outputs "found"

            a = a.Remove(4);
            Console.WriteLine(a);
            //Outputs "I am"

            a = a.Substring(2);
            Console.WriteLine(a);
            //Outputs "am"
        }
    }
}
OUTPUT
9
5
This is some text
I am some text
found
I am
am

You can also access characters of a string by its index, just like accessing elements of an array:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string a = "some text";
            Console.WriteLine(a[2]);
        }
    }
}
OUTPUT
9
5
This is some text
I am some text
found
I am
am

Indexes in strings are similar to arrays, they start from 0.
===================================================================
Working with Strings
Let's create a program that will take a string, replace all occurrences of the word "dog" with "cat" and output the first sentence only.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string text = "This is some text about a dog. The word dog appears in this text a number of times. This is the end.";
            text = text.Replace("dog", "cat");
            text = text.Substring(0, text.IndexOf(".")+1);
            
            Console.WriteLine(text);
        }
    }
}
OUTPUT
This is some text about a cat.

The code above replaces all occurrences of "dog" with "cat". After that it takes a substring of the original string starting from the first index until the first occurrence of a period character.
We add one to the index of the period to include the period in the substring.

C# provides a solid collection of tools and methods to work and manipulate strings. You could, for example, find the number of times a specific word appears in a book with ease, using those methods.
===================================================================
++=====================++
++=====================++ More on Classes:: Destructors
Destructors
As constructors are used when a class is instantiated, destructors are automatically invoked when an object is destroyed or deleted.
Destructors have the following attributes:
- A class can only have one destructor.
- Destructors cannot be called. They are invoked automatically.
- A destructor does not take modifiers or have parameters.
- The name of a destructor is exactly the same as the class prefixed with a tilde (~).

For Example:
class Dog
{
  ~Dog() 
  {
    // code statements
  }
}
Destructors can be very useful for releasing resources before coming out of the program. This can include closing files, releasing memory, and so on.
===================================================================
Destructors
Let’s include WriteLine statements in the destructor and constructor of our class and see how the program behaves when an object of that class is created and when the program ends:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Dog
        {
            public Dog() {
                Console.WriteLine("Constructor");
            }
            ~Dog() {
                Console.WriteLine("Destructor");
            }
        }
        static void Main(string[] args)
        {
            Dog d = new Dog();
        }
    }
}
OUTPUT
Constructor
Destructor

When the program runs, it first creates the object, which calls the constructor. The object is deleted at the end of the program and the destructor is invoked when the program's execution is complete.

This can be useful, for example, if your class is working with storage or files. The constructor would initialize and open the files. Then, when the program ends, the destructor would close the files.
===================================================================
++=====================++
++=====================++ Static Members
Static
Now it's time to discuss the static keyword.
You first noticed it in the Main method's declaration:

static void Main(string[] args)
Class members (variables, properties, methods) can also be declared as static. This makes those members belong to the class itself, instead of belonging to individual objects. No matter how many objects of the class are created, there is only one copy of the static member.

For example:
class Cat {
  public static int count=0;
  public Cat() {
    count++;
  }
}
In this case, we declared a public member variable count, which is static. The constructor of the class increments the count variable by one.

No matter how many Cat objects are instantiated, there is always only one count variable that belongs to the Cat class because it was declared static.
===================================================================
Static
Because of their global nature, static members can be accessed directly using the class name without an object.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Cat {
            public static int count=0;
            public Cat() {
                count++;
            }
        }
        static void Main(string[] args)
        {
            Cat c1 = new Cat();
            Cat c2 = new Cat();
            Console.WriteLine(Cat.count);
        }
    }
}
OUTPUT
2

As you can see, we can access the static variable using the class name: Cat.count.
The count variable is shared between all Cat objects. For this class, each time an object is created, the static value is incremented. The program above demonstrates this when 2 is displayed after creating two objects of that class.

You must access static members using the class name. If you try to access them via an object of that class, you will generate an error.
===================================================================
Static Methods
The same concept applies to static methods.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Dog
        {
            public static void Bark() {
                Console.WriteLine("Woof");
            }
        }
        static void Main(string[] args)
        {
            Dog.Bark();
        }
    }
}
OUTPUT
Woof

Static methods can access only static members.

The Main method is static, as it is the starting point of any program. Therefore any method called directly from Main had to be static.
===================================================================
Static
Constant members are static by definition.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class MathClass {
            public const int ONE = 1;
        }
        static void Main(string[] args)
        {
            Console.Write(MathClass.ONE);
        }
    }
}
OUTPUT
1

As you can see, we access the property ONE using the name of the class, just like a static member. This is because all const members are static by default.

Static Constructors
Constructors can be declared static to initialize static members of the class.
The static constructor is automatically called once when we access a static member of the class.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class SomeClass {
            public static int X { get; set; }
            public static int Y { get; set; }
            
            static SomeClass() {
                X = 10;
                Y = 20;
            }
        }
        static void Main(string[] args)
        {
            Console.WriteLine(SomeClass.X);
        }
    }
}
OUTPUT
1

The constructor will get called once when we try to access SomeClass.X or SomeClass.Y.
===================================================================
++=====================++
++=====================++ Static Classes
Static Classes
An entire class can be declared as static.
A static class can contain only static members.
You cannot instantiate an object of a static class, as only one instance of the static class can exist in a program.
Static classes are useful for combining logical properties and methods. A good example of this is the Math class.
It contains various useful properties and methods for mathematical operations.

For example, the Pow method raises a number to a power:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(Math.Pow(2, 3));
        }
    }
}
OUTPUT
8

You access all members of the Math class using the class name, without declaring an object.

Tap next to learn about the available methods of the Math class.
===================================================================
Static Classes
There are a number of useful static methods and properties available in C#:

[h2]Math[/h2]
Math.PI the constant PI.
Math.E represents the natural logarithmic base e.
Math.Max() returns the larger of its two arguments.
Math.Min() returns the smaller of its two arguments.
Math.Abs() returns the absolute value of its argument.
Math.Sin() returns the sine of the specified angle.
Math.Cos() returns the cosine of the specified angle.
Math.Pow() returns a specified number raised to the specified power.
Math.Round() rounds the decimal number to its nearest integral value.
Math.Sqrt() returns the square root of a specified number.

[h2]Array[/h2]
The Array class includes some static methods for manipulating arrays:

int[] arr = {1, 2, 3, 4};

Array.Reverse(arr);
//arr = {4, 3, 2, 1}

Array.Sort(arr);
//arr = {1, 2, 3, 4}
String
string s1 = "some text";
string s2 = "another text";

String.Concat(s1, s2); // combines the two strings

String.Equals(s1, s2); // returns false
DateTime
The DateTime structure allows you to work with dates.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(DateTime.Now);
            Console.WriteLine(DateTime.Today);
            
            Console.WriteLine(DateTime.DaysInMonth(2016, 2));
        }
    }
}
OUTPUT
01/13/2025 01:41:59
01/13/2025 00:00:00
29

The Console class is also an example of a static class. We use its static WriteLine() method to output to the screen, or the static ReadLine() method to get user input.
The Convert class used to convert value types is also a static class.
===================================================================
++=====================++
++=====================++ this & readonly
The this Keyword
The this keyword is used inside the class and refers to the current instance of the class, meaning it refers to the current object.
One of the common uses of this is to distinguish class members from other data, such as local or formal parameters of a method, as shown in the following example:

class Person {
  private string name;
  public Person(string name) {
    this.name = name;
  }
}
Here, this.name represents the member of the class, whereas name represents the parameter of the constructor.

Another common use of this is for passing the current instance to a method as parameter: ShowPersonInfo(this);
===================================================================
The readonly Modifier
The readonly modifier prevents a member of a class from being modified after construction. It means that the field declared as readonly can be modified only when you declare it or from within a constructor.

For example:
class Person {
  private readonly string name = "John"; 
  public Person(string name) {
    this.name = name; 
  }
}
If we try to modify the name field anywhere else, we will get an error.
There are three major differences between readonly and const fields.
First, a constant field must be initialized when it is declared, whereas a readonly field can be declared without initialization, as in:

readonly string name; // OK
const double PI; // Error
Second, a readonly field value can be changed in a constructor, but a constant value cannot.
Third, the readonly field can be assigned a value that is a result of a calculation, but constants cannot, as in:

readonly double a = Math.Sin(60); // OK
const double b = Math.Sin(60); // Error!
The readonly modifier prevents a member of a class from being modified after construction.
===================================================================
++=====================++
++=====================++ Indexers
Indexers
An indexer allows objects to be indexed like an array.
As discussed earlier, a string variable is actually an object of the String class. Further, the String class is actually an array of Char objects. In this way, the string class implements an indexer so we can access any character (Char object) by its index:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string str = "Hello World";
            char x = str[4];
            Console.WriteLine(x);
        }
    }
}
OUTPUT
o

Arrays use integer indexes, but indexers can use any type of index, such as strings, characters, etc.
===================================================================
Indexers
Declaration of an indexer is to some extent similar to a property. The difference is that indexer accessors require an index.
Like a property, you use get and set accessors for defining an indexer. However, where properties return or set a specific data member, indexers return or set a particular value from the object instance.
Indexers are defined with the this keyword.

For example:
class Clients {
  private string[] names = new string[10];

  public string this[int index] {
    get {
      return names[index];
    }
    set {
      names[index] = value;
    }
  }
}
As you can see, the indexer definition includes the this keyword and an index, which is used to get and set the appropriate value.
Now, when we declare an object of class Clients, we use an index to refer to specific objects like the elements of an array:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Clients {
            private string[] names = new string[10];
            public string this[int index] {
                get {
                    return names[index];
                }
                set {
                    names[index] = value;
                }
            }
        }
        static void Main(string[] args)
        {
            Clients c = new Clients();
            c[0] = "Dave";
            c[1] = "Bob";
            
            Console.WriteLine(c[1]);
        }
    }
}
OUTPUT
Bob

You typically use an indexer if the class represents a list, collection, or array of objects.
===================================================================
++=====================++
++=====================++ Operator Overloading
Operator Overloading
Most operators in C# can be overloaded, meaning they can be redefined for custom actions.
For example, you can redefine the action of the plus (+) operator in a custom class.
Consider the Box class that has Height and Width properties:

class Box {
  public int Height {get; set;}
  public int Width {get; set;}
  public Box(int h, int w) {
    Height = h;
    Width = w;
  }
}
static void Main(string[] args) {
  Box b1 = new Box(14, 3);
  Box b2 = new Box(5, 7);
}
We would like to add these two Box objects, which would result in a new, bigger Box.
So, basically, we would like the following code to work:

Box b3 = b1 + b2;
The Height and Width properties of object b3 should be equal to the sum of the corresponding properties of the b1 and b2 objects.

This is achieved through operator overloading. Tap next to learn more!
===================================================================
Operator Overloading
Overloaded operators are methods with special names, where the keyword operator is followed by the symbol for the operator being defined.
Similar to any other method, an overloaded operator has a return type and a parameter list.
For example, for our Box class, we overload the + operator:

public static Box operator+ (Box a, Box b) {
  int h = a.Height + b.Height;
  int w = a.Width + b.Width;
  Box res = new Box(h, w);
  return res;
}
The method above defines an overloaded operator + with two Box object parameters and returning a new Box object whose Height and Width properties equal the sum of its parameter's corresponding properties.
Additionally, the overloaded operator must be static.

Putting it all together:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Box {
            public int Height { get; set; }
            public int Width { get; set; }
            public Box(int h, int w) {
                Height = h;
                Width = w;
            }
            public static Box operator+(Box a, Box b) {
                int h = a.Height + b.Height;
                int w = a.Width + b.Width;
                Box res = new Box(h, w);
                return res;
            }
        }
        static void Main(string[] args)
        {
            Box b1 = new Box(14, 3);
            Box b2 = new Box(5, 7);
            Box b3 = b1 + b2;
            
            Console.WriteLine(b3.Height);
            Console.WriteLine(b3.Width);
        }
    }
}
OUTPUT
19
10

All arithmetic and comparison operators can be overloaded. For instance, you could define greater than and less than operators for the boxes that would compare the Boxes and return a boolean result. Just keep in mind that when overloading the greater than operator, the less than operator should also be defined.
===================================================================
++=====================++
++=====================++ Inheritance & Polymorphism:: Inheritance
Inheritance
Inheritance allows us to define a class based on another class. This makes creating and maintaining an application easy.
The class whose properties are inherited by another class is called the Base class. The class which inherits the properties is called the Derived class.
For example, base class Animal can be used to derive Cat and Dog classes.
The derived class inherits all the features from the base class, and can have its own additional features.

img-component
Inheritance allows us to define a class based on another class.
===================================================================
Inheritance
Let's define our base class Animal:

class Animal {
  public int Legs {get; set;}
  public int Age {get; set;}
}
Now we can derive class Dog from it:

class Dog : Animal {
  public Dog() {
    Legs = 4;
  }
  public void Bark() {
    Console.Write("Woof");
  }
}
Note the syntax for a derived class. A colon and the name of the base class follow the name of the derived class.
All public members of Animal become public members of Dog. That is why we can access the Legs member in the Dog constructor.
Now we can instantiate an object of type Dog and access the inherited members as well as call its own Bark method.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Animal {
            public int Legs {get; set;}
            public int Age {get; set;}
        }
        class Dog : Animal {
            public Dog() {
                Legs = 4;
            }
            public void Bark() {
                Console.Write("Woof");
            }
        }
        static void Main(string[] args)
        {
            Dog d = new Dog();
            Console.WriteLine(d.Legs);
            
            d.Bark();
        }
    }
}
OUTPUT
4
Woof

A base class can have multiple derived classes. For example, a Cat class can inherit from Animal.

Inheritance allows the derived class to reuse the code in the base class without having to rewrite it. And the derived class can be customized by adding more members. In this manner, the derived class extends the functionality of the base class.
===================================================================
Inheritance
A derived class inherits all the members of the base class, including its methods.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person {
            public void Speak() {
                Console.WriteLine("Hi there");
            }
        }
        class Student : Person {
            int number;
        }
        static void Main(string[] args)
        {
            Student s = new Student();
            s.Speak();
        }
    }
}
OUTPUT
Hi there

We created a Student object and called the Speak method, which was declared in the base class Person.

C# does not support multiple inheritance, so you cannot inherit from multiple classes.
However, you can use interfaces to implement multiple inheritance. You will learn more about interfaces in the coming lessons.
===================================================================
++=====================++
++=====================++ Protected Members
protected
Up to this point, we have worked exclusively with public and private access modifiers.
Public members may be accessed from anywhere outside of the class, while access to private members is limited to their class.
The protected access modifier is very similar to private with one difference; it can be accessed in the derived classes. So, a protected member is accessible only from derived classes.

For example:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person {
            protected int Age {get; set;}
            protected string Name {get; set;}
        }
        class Student : Person {
            public Student(string nm) {
                Name = nm;
            }
            public void Speak() {
                Console.Write("Name: "+Name);
            }
        }
        static void Main(string[] args)
        {
            Student s = new Student("David");
            s.Speak();
        }
    }
}
OUTPUT
Name: David

As you can see, we can access and modify the Name property of the base class from the derived class.
But, if we try to access it from outside code, we will get an error:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Person {
            protected int Age {get; set;}
            protected string Name {get; set;}
        }
        class Student : Person {
            public Student(string nm) {
                Name = nm;
            }
            public void Speak() {
                Console.Write("Name: "+Name);
            }
        }
        static void Main(string[] args)
        {
            Student s = new Student("David");
            s.Name = "Bob"; 
        }
    }
}
OUTPUT
Name: David
===================================================================
sealed
A class can prevent other classes from inheriting it, or any of its members, by using the sealed modifier.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        sealed class Animal {
            //some code
        }
        class Dog : Animal { } //Error
        
        static void Main(string[] args)
        {
            
        }
    }
}

In this case, we cannot derive the Dog class from the Animal class because Animal is sealed.

The sealed keyword provides a level of protection to your class so that other classes cannot inherit from it.
===================================================================
++=====================++
++=====================++ Derived Class Constructor & Destructor
Inheritance
Constructors are called when objects of a class are created. With inheritance, the base class constructor and destructor are not inherited, so you should define constructors for the derived classes.
However, the base class constructor and destructor are being invoked automatically when an object of the derived class is created or deleted.

Consider the following example:
class Animal {
  public Animal() {
    Console.WriteLine("Animal created");
  }
  ~Animal() {
    Console.WriteLine("Animal deleted");
  }
}
class Dog: Animal {
  public Dog() {
    Console.WriteLine("Dog created");
  }
  ~Dog() {
    Console.WriteLine("Dog deleted");
  }
}
We have defined the Animal class with a constructor and destructor and a derived Dog class with its own constructor and destructor.

So what will happen when we create an object of the derived class? Tap next to find out!
===================================================================
Inheritance
Let's create a Dog object:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Animal {
            public Animal() {
                Console.WriteLine("Animal created");
            }
            ~Animal() {
                Console.WriteLine("Animal deleted");
            }
        }
        class Dog: Animal {
            public Dog() {
                Console.WriteLine("Dog created");
            }
            ~Dog() {
                Console.WriteLine("Dog deleted");
            }
        }
        static void Main(string[] args)
        {
            Dog d = new Dog();
        }
    }
}
OUTPUT
Animal created
Dog created
Dog deleted
Animal deleted

Note that the base class constructor is called first and the derived class constructor is called next.
When the object is destroyed, the derived class destructor is invoked and then the base class destructor is invoked.

You can think of it as the following: The derived class needs its base class in order to work, which is why the base class constructor is called first.
===================================================================
++=====================++
++=====================++ Polymorphism
Polymorphism
The word polymorphism means "having many forms".
Typically, polymorphism occurs when there is a hierarchy of classes and they are related through inheritance from a common base class.
Polymorphism means that a call to a member method will cause a different implementation to be executed depending on the type of object that invokes the method.

Simply, polymorphism means that a single method can have a number of different implementations.
===================================================================
Polymorphism
Consider having a program that allows users to draw different shapes. Each shape is drawn differently, and you do not know which shape the user will choose.
Here, polymorphism can be leveraged to invoke the appropriate Draw method of any derived class by overriding the same method in the base class. Such methods must be declared using the virtual keyword in the base class.

For example:
class Shape {
  public virtual void Draw() {
    Console.Write("Base Draw");
  }
}
The virtual keyword allows methods to be overridden in derived classes.

Virtual methods enable you to work with groups of related objects in a uniform way.
===================================================================
Polymorphism
Now, we can derive different shape classes that define their own Draw methods using the override keyword:

class Circle : Shape {
  public override void Draw() {
    // draw a circle...
    Console.WriteLine("Circle Draw");
  }
}
class Rectangle : Shape {
  public override void Draw() {
    // draw a rectangle...
    Console.WriteLine("Rect Draw");
  }
}
The virtual Draw method in the Shape base class can be overridden in the derived classes. In this case, Circle and Rectangle have their own Draw methods.
Now, we can create separate Shape objects for each derived type and then call their Draw methods:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Shape {
            public virtual void Draw() {
                Console.Write("Base Draw");
            }
        }
        class Circle : Shape {
            public override void Draw() {
                // draw a circle...
                Console.WriteLine("Circle Draw");
            }
        }
        class Rectangle : Shape {
            public override void Draw() {
                // draw a rectangle...
                Console.WriteLine("Rect Draw");
            }
        }
        static void Main(string[] args)
        {
            Shape c = new Circle();
            c.Draw();

            Shape r = new Rectangle();
            r.Draw();
        }
    }
}
OUTPUT
Circle Draw
Rect Draw

As you can see, each object invoked its own Draw method, thanks to polymorphism.
===================================================================
Polymorphism
To summarize, polymorphism is a way to call the same method for different objects and generate different results based on the object type. This behavior is achieved through virtual methods in the base class.
To implement this, we create objects of the base type, but instantiate them as the derived type:

Shape c = new Circle();
Shape is the base class. Circle is the derived class.
So why use polymorphism? We could just instantiate each object of its type and call its method, as in:

Circle c = new Circle();
c.Draw();
The polymorphic approach allows us to treat each object the same way. As all objects are of type Shape, it is easier to maintain and work with them. You could, for example, have a list (or array) of objects of that type and work with them dynamically, without knowing the actual derived type of each object.

Polymorphism can be useful in many cases. For example, we could create a game where we would have different Player types with each Player having a separate behavior for the Attack method.
In this case, Attack would be a virtual method of the base class Player and each derived class would override it.
===================================================================
++=====================++
++=====================++ Abstract Classes
Abstract Classes
As described in the previous example, polymorphism is used when you have different derived classes with the same method, which has different implementations in each class. This behavior is achieved through virtual methods that are overridden in the derived classes.
In some situations there is no meaningful need for the virtual method to have a separate definition in the base class.
These methods are defined using the abstract keyword and specify that the derived classes must define that method on their own.
You cannot create objects of a class containing an abstract method, which is why the class itself should be abstract.
We could use an abstract method in the Shape class:

abstract class Shape {
   public abstract void Draw();
}
As you can see, the Draw method is abstract and thus has no body. You do not even need the curly brackets; just end the statement with a semicolon.
The Shape class itself must be declared abstract because it contains an abstract method. Abstract method declarations are only permitted in abstract classes.

Remember, abstract method declarations are only permitted in abstract classes. Members marked as abstract, or included in an abstract class, must be implemented by classes that derive from the abstract class. An abstract class can have multiple abstract members.
===================================================================
Abstract Classes
An abstract class is intended to be a base class of other classes. It acts like a template for its derived classes.
Now, having the abstract class, we can derive the other classes and define their own Draw() methods:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        abstract class Shape {
            public abstract void Draw();
        }
        class Circle : Shape {
            public override void Draw() {
                Console.WriteLine("Circle Draw");
            }
        }
        class Rectangle : Shape {
            public override void Draw() {
                Console.WriteLine("Rect Draw");
            }
        }
        static void Main(string[] args)
        {
            Shape c = new Circle();
            c.Draw();
        }
    }
}
OUTPUT
Circle Draw

Abstract classes have the following features:
- An abstract class cannot be instantiated.
- An abstract class may contain abstract methods and accessors.
- A non-abstract class derived from an abstract class must include actual implementations of all inherited abstract methods and accessors.

It is not possible to modify an abstract class with the sealed modifier because the two modifiers have opposite meanings. The sealed modifier prevents a class from being inherited and the abstract modifier requires a class to be inherited.
===================================================================
++=====================++
++=====================++ Interfaces
Interfaces
An interface is a completely abstract class, which contains only abstract members.
It is declared using the interface keyword:

public interface IShape
{
  void Draw();
}
All members of the interface are by default abstract, so no need to use the abstract keyword.

Interfaces can have public (by default), private and protected members.

It is common to use the capital letter I as the starting letter for an interface name.
Interfaces can contain properties, methods, etc. but cannot contain fields (variables).
===================================================================
Interfaces
When a class implements an interface, it must also implement, or define, all of its methods.
The term implementing an interface is used (opposed to the term "inheriting from") to describe the process of creating a class based on an interface. The interface simply describes what a class should do. The class implementing the interface must define how to accomplish the behaviors.
The syntax to implement an interface is the same as that to derive a class:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        public interface IShape {
            void Draw();
        }
        class Circle : IShape {
            public void Draw() {
                Console.WriteLine("Circle Draw");
            }
        }
        static void Main(string[] args)
        {
            IShape c = new Circle();
            c.Draw();
        }
    }
}
OUTPUT
Circle Draw

Note, that the override keyword is not needed when you implement an interface.

But why use interfaces rather than abstract classes?
A class can inherit from just one base class, but it can implement multiple interfaces!
Therefore, by using interfaces you can include behavior from multiple sources in a class.
To implement multiple interfaces, use a comma separated list of interfaces when creating the class: class A: IShape, IAnimal, etc.
===================================================================
Default Implementation
Default implementation in interfaces allows to write an implementation of any method. This is useful when there is a need to provide a single implementation for common functionality.

Let's suppose we need to add new common functionality to our already existing interface, which is implemented by many classes. Without default implementation (before C# 8), this operation would create errors, because the method we have added isn't implemented in the classes, and we would need to implement the same operation one by one in each class. Default implementation in interface solves this problem.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        public interface IShape {
            void Draw();
            void Finish(){
                Console.WriteLine("Done!");
            }
        }
        class Circle : IShape {
            public void Draw() {
                Console.WriteLine("Circle Draw");
            }
        }
        static void Main(string[] args)
        {
            IShape c = new Circle();
            c.Draw();
            c.Finish();
        }
    }
}
Circle Draw
Done!

We added the Finish() method with default implementation to our IShape interface and called it without implementing it inside the Circle class.

Methods with default implementation can be freely overridden inside the class which implements that interface.
===================================================================
++=====================++
++=====================++ Nested Classes
Nested Classes
C# supports nested classes: a class that is a member of another class.

For example:
class Car {
  string name;
  public Car(string nm) {
    name = nm;
    Motor m = new Motor();
  }
  public class Motor {
    // some code
  }
}
The Motor class is nested in the Car class and can be used similar to other members of the class.
A nested class acts as a member of the class, so it can have the same access modifiers as other members (public, private, protected).

Just as in real life, objects can contain other objects. For example, a car, which has its own attributes (color, brand, etc.) contains a motor, which as a separate object, has its own attributes (volume, horsepower, etc.). Here, the Car class can have a nested Motor class as one of its members.
===================================================================
++=====================++
++=====================++ Namespaces
Namespaces
When you create a blank project, it has the following structure:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn {
  class Program {
    static void Main(string[] args) {
    }
  }
}
Note, that our whole program is inside a namespace. So, what are namespaces?
Namespaces declare a scope that contains a set of related objects. You can use a namespace to organize code elements. You can define your own namespaces and use them in your program.
The using keyword states that the program is using a given namespace.
For example, we are using the System namespace in our programs, which is where the class Console is defined:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hi");
        }
    }
}
OUTPUT
Hi

Without the using statement, we would have to specify the namespace wherever it is used:

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            System.Console.WriteLine("Hi");
        }
    }
}
OUTPUT
Hi

The .NET Framework uses namespaces to organize its many classes. System is one example of a .NET Framework namespace.
Declaring your own namespaces can help you group your class and method names in larger programming projects.
===================================================================
++=====================++
++=====================++ Structs, Enums, Exceptions & Files:: Structs
Structs
A struct type is a value type that is typically used to encapsulate small groups of related variables, such as the coordinates of a rectangle or the characteristics of an item in an inventory. The following example shows a simple struct declaration:

struct Book {
  public string title;  
  public double price;
  public string author;
}
Structs share most of the same syntax as classes, but are more limited than classes.
Unlike classes, structs can be instantiated without using a new operator.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        struct Book {
            public string title;  
            public double price;
            public string author;
        }
        static void Main(string[] args)
        {
            Book b;
            b.title = "Test";
            b.price = 5.99;
            b.author = "David";
            
            Console.WriteLine(b.title);
        }
    }
}
OUTPUT
Test

Structs do not support inheritance and cannot contain virtual methods.
===================================================================
Structs
Structs can contain methods, properties, indexers, and so on. Structs cannot contain default constructors (a constructor without parameters), but they can have constructors that take parameters. In that case the new keyword is used to instantiate a struct object, similar to class objects.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        struct Point {
            public int x;
            public int y;
            public Point(int x, int y) {
                this.x = x;
                this.y = y;
            }
        }
        static void Main(string[] args)
        {
            Point p = new Point(10, 15);
            Console.WriteLine(p.x);
        }
    }
}
OUTPUT
10

Structs vs Classes
In general, classes are used to model more complex behavior, or data, that is intended to be modified after a class object is created. Structs are best suited for small data structures that contain primarily data that is not intended to be modified after the struct is created. Consider defining a struct instead of a class if you are trying to represent a simple set of data.

All standard C# types (int, double, bool, char, etc.) are actually structs.
===================================================================
++=====================++
++=====================++ Enums
Enums
The enum keyword is used to declare an enumeration: a type that consists of a set of named constants called the enumerator list.
By default, the first enumerator has the value 0, and the value of each successive enumerator is increased by 1.
For example, in the following enumeration, Sun is 0, Mon is 1, Tue is 2, and so on:

enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};
You can also assign your own enumerator values:

enum Days {Sun, Mon, Tue=4, Wed, Thu, Fri, Sat};
In the example above, the enumeration will start from 0, then Mon is 1, Tue is 4, Wed is 5, and so on. The value of the next item in an Enum is one increment of the previous value.
Note that the values are comma separated.
You can refer to the values in the Enum with the dot syntax.
In order to assign Enum values to int variables, you have to specify the type in parentheses:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat }; 
        static void Main(string[] args)
        {
            int x = (int)Days.Tue;
            Console.WriteLine(x);
        }
    }
}
OUTPUT
2

Basically, Enums define variables that represent members of a fixed set.
Some sample Enum uses include month names, days of the week, cards in a deck, etc.
===================================================================
Enums
Enums are often used with switch statements.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        enum TrafficLights { Green, Red, Yellow };
        static void Main(string[] args)
        {
            TrafficLights x = TrafficLights.Red;
            switch (x) {
                case TrafficLights.Green:
                    Console.WriteLine("Go!");
                    break;
                case TrafficLights.Red:
                    Console.WriteLine("Stop!");
                    break;
                case TrafficLights.Yellow:
                    Console.WriteLine("Caution!");
                    break;
            }
        }
    }
}
OUTPUT
Stop!
===================================================================
++=====================++
++=====================++ Exception Handling
Exceptions
An exception is a problem that occurs during program execution. Exceptions cause abnormal termination of the program.
An exception can occur for many different reasons. Some examples:
- A user has entered invalid data.
- A file that needs to be opened cannot be found.
- A network connection has been lost in the middle of communications.
- Insufficient memory and other issues related to physical resources.

For example, the following code will produce an exception when run because we request an index which does not exist:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] arr = new int[] { 4, 5, 8 };
            Console.Write(arr[8]);
        }
    }
}

As you can see, exceptions are caused by user error, programmer error, or physical resource issues. However, a well-written program should handle all possible exceptions.
===================================================================
Handling Exceptions
C# provides a flexible mechanism called the try-catch statement to handle exceptions so that a program won't crash when an error occurs.
The try and catch blocks are used similar to:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            try {
                int[] arr = new int[] { 4, 5, 8 };
                Console.Write(arr[8]);
            }
            catch(Exception e) {
                Console.WriteLine("An error occurred");
            }
        }
    }
}
OUTPUT
An error occurred

The code that might generate an exception is placed in the try block. If an exception occurs, the catch blocks is executed without stopping the program.
The type of exception you want to catch appears in parentheses following the keyword catch.
We use the general Exception type to handle all kinds of exceptions. We can also use the exception object e to access the exception details, such as the original error message (e.Message):

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            try {
                int[] arr = new int[] { 4, 5, 8 };
                Console.Write(arr[8]);
            }
            catch(Exception e) {
                Console.WriteLine(e.Message);
            }
        }
    }
}
OUTPUT
An error occurred

You can also catch and handle different exceptions separately. Tap next to learn more!
===================================================================
Handling Multiple Exceptions
A single try block can contain multiple catch blocks that handle different exceptions separately.
Exception handling is particularly useful when dealing with user input.
For example, for a program that requests user input of two numbers and then outputs their quotient, be sure that you handle division by zero, in case your user enters 0 as the second number.

int x, y;
try {
  x = Convert.ToInt32(Console.Read());
  y = Convert.ToInt32(Console.Read());
  Console.WriteLine(x / y);
}
catch (DivideByZeroException e) {
  Console.WriteLine("Cannot divide by 0");
}
catch(Exception e) {
  Console.WriteLine("An error occurred");
}
The above code handles the DivideByZeroException separately. The last catch handles all the other exceptions that might occur. If multiple exceptions are handled, the Exception type must be defined last.
Now, if the user enters 0 for the second number, "Cannot divide by 0" will be displayed.
If, for example, the user enters non-integer values, "An error occurred" will be displayed.

The following exception types are some of the most commonly used: FileNotFoundException, FormatException, IndexOutOfRangeException, InvalidOperationException, OutOfMemoryException.
===================================================================
finally
An optional finally block can be used after the catch blocks. The finally block is used to execute a given set of statements, whether an exception is thrown or not.

For example:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            int result=0;
            int num1 = 8;
            int num2 = 4;
            try {
                result = num1 / num2;
            }
            catch (DivideByZeroException e) {
                Console.WriteLine("Error");
            }
            finally {
                Console.WriteLine(result);
            }
        }
    }
}
OUTPUT
2

The finally block can be used, for example, when you work with files or other resources. These should be closed or released in the finally block, whether an exception is raised or not.
===================================================================
++=====================++
++=====================++ Working with Files
Writing to Files
The System.IO namespace has various classes that are used for performing numerous operations with files, such as creating and deleting files, reading from or writing to a file, closing a file, and more.
The File class is one of them.

For example:
string str = "Some text";
File.WriteAllText("test.txt", str);
The WriteAllText() method creates a file with the specified path and writes the content to it. If the file already exists, it is overwritten.
The code above creates a file test.txt and writes the contents of the str string into it.

To use the File class you need to use the System.IO namespace: using System.IO;
===================================================================
Reading from Files
You can read the content of a file using the ReadAllText method of the File class:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;

namespace SoloLearn
{
    class Program
    {
        static void Main(string[] args)
        {
            string str = "Some text";
            File.WriteAllText("test.txt", str);
            
            string txt = File.ReadAllText("test.txt");
            Console.WriteLine(txt); 
        }
    }
}
OUTPUT
Some text

This will output the content of the test.txt file.
The following methods are available in the File class:
AppendAllText() - appends text to the end of the file.
Create() - creates a file in the specified location.
Delete() - deletes the specified file.
Exists() - determines whether the specified file exists.
Copy() - copies a file to a new location.
Move() - moves a specified file to a new location

All methods automatically close the file after performing the operation.
===================================================================
++=====================++
++=====================++ Generics:: Generic Methods
Generics
Generics allow the reuse of code across different types.
For example, let's declare a method that swaps the values of its two parameters:

static void Swap(ref int a, ref int b) {
  int temp = a;
  a = b;
  b = temp;
}
Our Swap method will work only for integer parameters. If we want to use it for other types, for example, doubles or strings, we have to overload it for all the types we want to use it with. Besides a lot of code repetition, it becomes harder to manage the code because changes in one method mean changes to all of the overloaded methods.
Generics provide a flexible mechanism to define a generic type.

static void Swap<T>(ref T a, ref T b) {
  T temp = a;
  a = b;
  b = temp;
}
In the code above, T is the name of our generic type. We can name it anything we want, but T is a commonly used name. Our Swap method now takes two parameters of type T. We also use the T type for our temp variable that is used to swap the values.

Note the brackets in the syntax <T>, which are used to define a generic type.
===================================================================
Generic Methods
Now, we can use our Swap method with different types, as in:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        static void Swap<T>(ref T a, ref T b) {
            T temp = a;
            a = b;
            b = temp;
        }
        static void Main(string[] args)
        {
            int a = 4, b = 9;
            Swap<int>(ref a, ref b);
            Console.WriteLine(a+" "+b);
            
            string x = "Hello";
            string y = "World";
            Swap<string>(ref x, ref y);
            Console.WriteLine(x+" "+y);
        }
    }
}
OUTPUT
9 4
World Hello

When calling a generic method, we need to specify the type it will work with by using brackets. So, when Swap<int> is called, the T type is replaced by int. For Swap<string>, T is replaced by string.
If you omit specifying the type when calling a generic method, the compiler will use the type based on the arguments passed to the method.

Multiple generic parameters can be used with a single method.
For example: Func<T, U> takes two different generic types.
===================================================================
++=====================++
++=====================++ Generic Classes
Generic Classes
Generic types can also be used with classes.
The most common use for generic classes is with collections of items, where operations such as adding and removing items from the collection are performed in basically the same way regardless of the type of data being stored. One type of collection is called a stack. Items are "pushed", or added to the collection, and "popped", or removed from the collection. A stack is sometimes called a Last In First Out (LIFO) data structure.

For example:
class Stack<T> {
  int index=0;
  T[] innerArray = new T[100];
  public void Push(T item) {
    innerArray[index++] = item; 
  }
  public T Pop() {
    return innerArray[--index]; 
  }
  public T Get(int k) { return innerArray[k]; }
}
The generic class stores elements in an array. As you can see, the generic type T is used as the type of the array, the parameter type for the Push method, and the return type for the Pop and Get methods.

Now we can create objects of our generic class:
Stack<int> intStack = new Stack<int>();
Stack<string> strStack = new Stack<string>();
Stack<Person> PersonStack = new Stack<Person>();
We can also use the generic class with custom types, such as the custom defined Person type.

In a generic class we do not need to define the generic type for its methods, because the generic type is already defined on the class level.
===================================================================
Generic Classes
Generic class methods are called the same as for any other object:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
{
    class Program
    {
        class Stack<T> {
            int index=0;
            T[] innerArray = new T[100];
            public void Push(T item) {
                innerArray[index++] = item; 
            }
            public T Pop() {
                return innerArray[--index]; 
            }
            public T Get(int k) { return innerArray[k]; }
        }
        static void Main(string[] args)
        {
            Stack<int> intStack = new Stack<int>();
            intStack.Push(3);
            intStack.Push(6);
            intStack.Push(7);
            
            Console.WriteLine(intStack.Get(1));
        }
    }
}
OUTPUT
6
===================================================================
++=====================++
++=====================++ Collections
C# Collections
A collection is used to group related objects. Unlike an array, it is dynamic and can also group objects. A collection can grow and shrink to accommodate any number of objects. Collection classes are organized into namespaces and contain built in methods for processing elements within the collection.

A collection organizes related data in a computer so that it can be used efficiently.
Different kinds of collections are suited to different kinds of applications, and some are highly specialized to specific tasks. For example, Dictionaries are used to represent connections on social websites (such as Twitter, Facebook), queues can be used to create task schedulers, HashSets are used in searching algorithms, etc.

A collection typically includes methods to add, remove, and count objects. The for statement and the foreach statement are used to iterate through collections. Since a collection is a class you must first declare an instance of the class before you can add elements to that collection.

For example:
List<int> li = new List<int>();
Collections provide a more flexible way to work with groups of objects. Unlike arrays, the group of objects you work with can grow and shrink dynamically as the needs of the application change.
===================================================================
Generic Collections
Generic collections are the preferred type to use as long as every element in the collection is of the same data type. Only desired data types can be added to a generic collection and this is enforced by using strong typing which reduces the possibility of errors.
The .NET Framework provides a number of generic collection classes, useful for storing and manipulating data.
The System.Collections.Generic namespace includes the following generic collections:
- List<T>
- Dictionary<TKey, TValue>
- SortedList<TKey, TValue>
- Stack<T>
- Queue<T>
- Hashset<T>

To access a generic collection in your code, you will need to include the statement: using Systems.Collections.Generic;

[h2]Non-Generic Collections[/h2]
Non-generic collections can store items that are of type Object. Since an Object data type can refer to any data type, you run the risk of unexpected outcomes. Non-generic collections may also be slower to access as well as execute.
The System.Collections namespace includes the following non-generic collections:
- ArrayList
- SortedList
- Stack
- Queue
- Hashtable
- BitArray

Because non-generic collections are error prone and less performant, it is recommended to always use generic collections from the System.Collections.Generic namespace if available and to avoid using legacy collections from the System.Collections namespace.
===================================================================
++=====================++
++=====================++ Lists and BitArray
List<T>
A list is similar to an array, but the elements in a list can be inserted and removed dynamically.
The C# generic collection List<T> class requires all elements be of the same type T.

List<T> properties and methods include:
Count A property that gets the number of elements contained in the list.
Item[int i] Gets or sets the element in the list at the index i. Item is the indexer and is not required when accessing an element. You only need to use the brackets [] and the index value inside the brackets.
Add(T t) Adds an element t to the end of the list.
RemoveAt(int index) Removes the element at the specified position (index) from the list.
Sort() Sorts elements in the list.

Now let's try List<T>:

using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
		    List<int> li = new List<int>();
            li.Add(59);
            li.Add(72);
            li.Add(95);
            li.Add(5);
            li.Add(9);
            li.RemoveAt(1); // remove 72
            
            Console.Write("\nList: ");
            for (int x = 0; x < li.Count; x++)
                Console.Write(li[x] + " "); // 59  95  5  9
            li.Sort();
            Console.Write("\nSorted: ");
            for (int x = 0; x < li.Count; x++)
                Console.Write(li[x] + " "); // 5  9  59  95
		}
	}
}
OUTPUT
List: 59 95 5 9 
Sorted: 5 9 59 95 

Additional List<T> properties and methods are listed below. Try them out by adding them to the List<T> example code above.
Capacity - A property that gets the number of elements the list can hold before needing to be resized.
Clear() - Removes all the elements from the list.
TrimExcess() - Sets the capacity to the actual number of elements in the list. This is useful when trying to reduce memory overhead.
AddRange(IEnumerable coll) - Adds the elements of collection coll with elements of the same type as List<T> to the end of the list. IEnumerable is the collections interface that supports simple iteration over the collection.
Insert(int i, T t) - Inserts an element t at a specific index i in the list.
InsertRange(int i, IEnumerable coll) - Inserts the elements of a collection coll at a specified index i in the list. IEnumerable is the collections interface that supports simple iteration over the collection.
Remove(T t) - Removes the first occurrence of the object t from the list.
RemoveRange(int i, int count) - Removes a specified number of elements count from the list starting at a specified index i.
Contains(T t) - Returns true if the specified element t is present in the list.
IndexOf(T t) - Returns the index of the first occurrence of the element t in the list.
Reverse() - Reverses the order of the elements in the list.
ToArray() - Copies the elements of the list into a new array.

Run the code and see how it works!
Remember, you need to include the statement: using Systems.Collections.Generic; to use List<T>.
===================================================================
SortedList<K, V>
A sorted list is a collection of key/value pairs that are sorted by key. A key can be used to access its corresponding value in the sorted list.

The C# generic collection SortedList<K, V> class requires all element key/value pairs to be of the same type K, V. Duplicate keys are not permitted, which ensures that every key/value pair is unique.

SortedList<K, V> properties include:
Count - Gets the number of key/value pairs contained in the sorted list.
Item[K key] - Gets or sets the value associated the specified key contained in the sorted list. Item is the indexer and is not required when accessing an element. You only need to use the brackets [] and the key, value.
Keys - Gets a sorted and indexed collection containing only the keys in the sorted list.

SortedList<K, V> methods include:
Add(K key, V value) - Adds an element with a specific key, value pair into the sorted list.
Remove(K key) - Removes the element with the specific key, value pair associated with the specified key from the sorted list.

Now let's try SortedList<K, V>:

using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
		    SortedList<string, int> sl = new SortedList<string, int>();

		    sl.Add("Solo", 59);
		    sl.Add("A", 95);
		    sl.Add("Learn", 72);
		    sl.Remove("A");
            
		    Console.WriteLine("Sorted List: ");
		    foreach (string s in sl.Keys)
		        Console.WriteLine(s + ": " + sl[s]);  // Learn: 72  Solo: 59
		    Console.WriteLine("\nCount: " + sl.Count);  // 2
		}
	}
}
Sorted List: 
Learn: 72
Solo: 59

Count: 2

Here are additional SortedList<K, V> properties and methods:
Values - Gets a sorted and indexed collection of the values in the sorted list.
Clear() - Removes all the elements from the sorted list.
ContainsKey(K key) - Returns true when the specified key is present in the sorted list.
ContainsValue(V value) - Returns true when a specified value is present in the sorted list.
IndexOfKey(K key) - Returns the index of the specified key within the sorted list.
IndexOfValue(V value) - Returns the index of the specified value within the sorted list.
===================================================================
BitArray
A bit array is a collection of bits. The value of a bit can be either 0 (off/false) or 1 (on/true).
Bit arrays compactly store bits. Most commonly, they are used to represent a simple group of boolean flags or an ordered sequence of boolean values.

BitArray properties include:
Count - Gets the number of bits in the bit array.
IsReadOnly - Gets a value indicating if the bit array is read only or not.

BitArray methods include:
Get(int i) - Gets the value of the bit at a specified position i in the bit array.
Set(int i, bool value) - Sets the bit at a specified position i to a specified value in the bit array.
SetAll(bool value) - Sets all the bits to a specified value in the bit array.
And(BitArray ba) - Performs the bitwise AND operation on the elements of the bit array object with a specified bit array ba.
Or(BitArray ba) - Performs the bitwise OR operation on the elements of the bit array and the specified bit array ba.
Not() - Inverts the bit values of the bit array.
Xor(BitArray ba) - Performs the bitwise XOR operation on the elements of the current bit array object and the elements in the specified bit array ba.

This example demonstrates some properties and methods of the BitArray class:

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoloLearn
 {
    class Program
    {
        // Printing BitArray
        public static void PrintBarr(string name, BitArray ba)
        {
            Console.Write(name + " : ");
            for (int x = 0; x < ba.Length; x++)
                Console.Write(ba.Get(x) + " ");
            Console.WriteLine();
        }
        
        public static void Main(string[] args)
        {
            BitArray ba1 = new BitArray(4);
            BitArray ba2 = new BitArray(4);
            
            ba1.SetAll(true);
            ba2.SetAll(false);
            
            ba1.Set(2, false);
            ba2.Set(3, true);
            
            PrintBarr("ba1", ba1);
            PrintBarr("ba2", ba2);
            Console.WriteLine();
            
            PrintBarr("ba1 AND ba2", ba1.And(ba2));
            PrintBarr("    NOT ba2", ba2.Not());
        }
    }
}
OUTPUT
ba1 : True True False True 
ba2 : False False False True 

ba1 AND ba2 : False False False True 
    NOT ba2 : True True True False 

For example, BitArrays can be used in image processing to store the individual bits of a gray-scale image.
===================================================================
++=====================++
++=====================++ Stack & Queue
Stack<T>
A stack is a Last In, First Out (LIFO) collection of elements where the last element that goes into the stack will be the first element that comes out.

Inserting an element onto a stack is called pushing. Deleting an element from a stack is called popping. Pushing and popping can be performed only at the top of the stack.

Stacks can be used to create undo-redo functionalities, parsing expressions (infix to postfix/prefix conversion), and much more.

The C# generic collection Stack<T> class requires all elements to be of the same type T.

Stack<T> properties include:
Count - Returns the number of elements in the stack.

Stack<T> methods include:
Peek() - Returns the element at the top of the stack without removing it.
Pop() - Returns the element at the top of the stack and removes it from the stack.
Push(T t) - Inserts an element t at the top of the stack.

Now let's try Stack<T>:

using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
		    Stack<int> s = new Stack<int>();
            
		    s.Push(59);
		    s.Push(72);
		    s.Push(65);

		    Console.Write("Stack: ");
		    foreach (int i in s)
		        Console.Write(i + " ");  // 65  72  59
		    Console.Write("\nCount: " + s.Count);  // 3
            
		    Console.Write("\nTop: " + s.Peek());  // 65
		    Console.Write("\nPop: " + s.Pop());  // 65
            
		    Console.Write("\nStack: ");
		    foreach (int i in s)
		        Console.Write(i + " ");  // 72  59
		    Console.Write("\nCount: " + s.Count);  // 2
		}
	}
}
Stack: 65 72 59 
Count: 3
Top: 65
Pop: 65
Stack: 72 59 
Count: 2

Here are additional Stack<T> methods:
Clear() - Removes all the elements from the stack.
Contains(T t) - Returns true when the element t is present in the stack.
ToArray() - Copies the stack into a new array.
===================================================================
Queue<T>
A queue is a First In, First Out (FIFO) collection of elements where the first element that goes into a queue is also the first element that comes out.

Inserting an element into a queue is referred to as Enqueue. Deleting an element from a queue is referred to as Dequeue.

Queues are used whenever we need to manage objects in order starting with the first one in.
Scenarios include printing documents on a printer, call center systems answering people on hold people, and so on.

The C# generic collection Queue<T> class requires that all elements be of the same type T.

Queue<T> properties include:
Count - Gets the number of elements in the queue.

And methods include:
Dequeue() - Returns the object at the beginning of the queue and also removes it.
Enqueue(T t) - Adds the object t to the end of the queue.

Now let's try Queue<T>:

using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
            Queue<int> q = new Queue<int>();
            
            q.Enqueue(5);
            q.Enqueue(10);
            q.Enqueue(15);
            Console.Write("Queue: ");
            foreach (int i in q)
                Console.Write(i + " ");  // 5  10  15
            Console.Write("\nCount: " + q.Count);  // 3
            
            Console.Write("\nDequeue: " + q.Dequeue()); // 5
            
            Console.Write("\nQueue: ");
            foreach (int i in q)
                Console.Write(i + " ");  // 10  15
            Console.Write("\nCount: " + q.Count);  // 2
		}
	}
}
OUTPUT
Queue: 5 10 15 
Count: 3
Dequeue: 5
Queue: 10 15 
Count: 2

Here are additional Queue<T> methods:
Clear() - Removes all objects from the queue.
Contains(T t) - Returns true when the element t is present in the queue.
Peek() - Returns the object at the beginning of the queue without removing it.
ToArray() - Copies the queue into a new array.
===================================================================
++=====================++
++=====================++ Dictionary & HashSet
Dictionary<K, V>
A dictionary is a collection of unique key/value pairs where a key is used to access the corresponding value. Dictionaries are used in database indexing, cache implementations, and so on.

The C# generic collection Dictionary<K, V> class requires all key/value pairs be of the same type K, V. Duplicate keys are not permitted to ensure that every key/value pair is unique.

Dictionary<K, V> properties include:
Count - Gets the number of key/value pairs contained in the dictionary.
Item[K key] - Gets the value associated with the specified key in the dictionary. Item is the indexer and is not required when accessing an element. You only need to use the brackets [] and key value.
Keys - Gets an indexed collection containing only the keys contained in the dictionary.

Dictionary<K, V> methods include:
Add(K key, V value) - Adds the key, value pair to the dictionary.
Remove(K key) - Removes the key/value pair related to the specified key from the dictionary.

Now let's try Dictionary<K, V>:

using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
		    Dictionary<string, int> d = new Dictionary<string, int>();
            d.Add("Uno", 1);
            d.Add("One", 1);
            d.Add("Dos", 2);
            d.Add("Deux", 2);
            d.Remove("One");  // Remove key-value pair One, 1
            d.Remove("Dos");  // Remove key-value pair Dos, 2
            
            Console.WriteLine("Dictionary: ");
            foreach (string s in d.Keys)
                Console.WriteLine(s + ": " + d[s]);  // Uno: 1  Deux: 2
            Console.WriteLine("\nCount: {0}", d.Count); // 2 
		}
	}
}
OUTPUT
Dictionary: 
Uno: 1
Deux: 2

Count: 2

In the above example, the dictionary d uses strings as it's keys and integers as the values.

Here are the additional Dictionary<K, V> properties and methods:
Values - Gets an indexed collection containing only the values in the dictionary.
Clear() - Removes all the key/value pairs from the dictionary.
ContainsKey(K key) - Returns true if the specified key is present in the dictionary.
ContainsValue(V value) - Returns true if the specified value is present in the dictionary.
===================================================================
HashSet<T>
A hash set is a set of unique values where duplicates are not allowed.

C# includes the HashSet<T> class in the generic collections namespace. All HashSet<T> elements are required to be of the same type T.
Hash sets are different from other collections because they are simply a set of values. They do not have index positions and elements cannot be ordered.

The HashSet<T> class provides high-performance set operations. HashSets allow fast lookup, addition, and removal of items, and can be used to implement either dynamic sets of items or lookup tables that allow finding an item by its key (e.g., finding the phone number of a person by the last name).

HashSet<T> properties include:
Count Returns the number of values in the hash set.

And methods include:
Add(T t) Adds a value (t) to the hash set.
IsSubsetOf(ICollection c) Returns true if the hash set is a subset of the specified collection (c).

Now let's try HashSet<T>:

using System;
using System.Collections.Generic;

namespace SoloLearn
{
	class Program
	{
		static void Main(string[] args)
		{
            HashSet<int> hs = new HashSet<int>();
            
            hs.Add(5);
            hs.Add(10);
            hs.Add(15);
            hs.Add(20);
            Console.Write("\nHashSet: ");
            foreach (int i in hs)
                Console.Write(i + " ");  // 5  10  15  20  *elements may be in any order
            Console.Write("\nCount: " + hs.Count);  // 4
            
            HashSet<int> hs2 = new HashSet<int>();
            hs2.Add(15);
            hs2.Add(20);
            Console.Write("\n{15, 20} is a subset of {5, 10, 15, 20}: " + hs2.IsSubsetOf(hs)); // True 
		}
	}
}
OUTPUT

HashSet: 5 10 15 20 
Count: 4
{15, 20} is a subset of {5, 10, 15, 20}: True

Here are additional HashSet<T> methods:
Remove(T t) Removes the value (t) from the hash set.
Clear() Removes all the elements form the hash set.
Contains(T t) Returns true when a value (t) is present in the hash set.
ToString() Creates a string from the hash set.
IsSupersetOf(ICollection c) Returns true if the hash set is a superset of the specified collection.
UnionWith(ICollection c) Applies set union operation on the hash set and the specified collection (c).
IntersectWith(ICollection c) Applies set intersection operation on the hash set and the specified collection (c).
ExceptWith(ICollection c) Applies set difference operation on the hash set and the specified collection (c).
===================================================================