What is an Object
What is a Class
Example of a Class
Abstraction
Encapsulation
Example of Encapsulation
Constructors
Quiz
C++ 2 Module 1 Quiz
Code Project
Queue Management Part 1
More On Classes
Separate Files for Classes
Destructors
Selection Operator
Constant Objects
Member Initializers
Composition, Part 1
Composition, Part 2
The Friend Keyword
The This Keyword
Operator Overloading
C++ 2 Module 2 Quiz
Code Project
Queue Management Part 2
Inheritance & Polymorphism
Inheritance
Protected Members
Derived Class Constructor & Destructor
Polymorphism
Virtual Functions
Abstract Classes
Quiz
C++ 2 Module 3 Quiz
Code Project
Queue Management Part 3
Templates, Exceptions, and Files
Function Templates
Function Templates with Multiple Parameters
Class Templates
Template Specialization
Exceptions
More on Exceptions
Working with Files
More on Files
Quiz
C++ 2 Module 4 Quiz

######################################################################################
######################################################################################
##	endroughxfer-urldump #1#
##	<EOF><EOF> Intermediate C++ (SoloLearn) Volume 1
######################################################################################
######################################################################################

++=====================++
++=====================++ Classes & Objects:: What is an object?

What is an Object

Object Oriented Programming is a programming style that is intended to make thinking about programming closer to thinking about the real world.

In programming, objects are independent units, and each has its own identity, just as objects in the real world do.

An apple is an object; so is a mug. Each has its unique identity. It's possible to have two mugs that look identical, but they are still separate, unique objects.
===================================================================
Objects 

An object might contain other objects but they're still different objects.

Objects also have characteristics that are used to describe them. For example, a car can be red or blue, a mug can be full or empty, and so on. These characteristics are also called attributes. An attribute describes the current state of an object.

Objects can have multiple attributes (the mug can be empty, red and large).

An object's state is independent of its type; a cup might be full of water, another might be empty.
===================================================================
Objects 

In the real world, each object behaves in its own way. The car moves, the phone rings, and so on.

The same applies to objects - behavior is specific to the object's type.

So, the following three dimensions describe any object in object oriented programming: identity, attributes, behavior.
===================================================================
Objects 

In programming, an object is self-contained, with its own identity. It is separate from other objects.

Each object has its own attributes, which describe its current state. Each exhibits its own behavior, which demonstrates what they can do. 
img-component

In computing, objects aren't always representative of physical items.

For example, a programming object can represent a date, a time, a bank account. A bank account is not tangible; you can't see it or touch it, but it's still a well-defined object - it has its own identity, attributes, and behavior.

Tap Continue to dive right into Object Oriented Programming (OOP) with C++!

++=====================++
++=====================++ What is a Class?

===================================================================
What is a Class 

Objects are created using classes, which are actually the focal point of OOP.

The class describes what the object will be, but is separate from the object itself.

In other words, a class can be described as an object's blueprint, description, or definition.

You can use the same class as a blueprint for creating multiple different objects. For example, in preparation to creating a new building, the architect creates a blueprint, which is used as a basis for actually building the structure. That same blueprint can be used to create multiple buildings.

Programming works in the same fashion. We first define a class, which becomes the blueprint for creating objects.

Each class has a name, and describes attributes and behavior.

In programming, the term type is used to refer to a class name: We're creating an object of a particular type.

Attributes are also referred to as properties or data.
===================================================================
Methods 

Method is another term for a class' behavior. A method is basically a function that belongs to a class.

Methods are similar to functions - they are blocks of code that are called, and they can also perform actions and return values.
===================================================================
A Class Example 

For example, if we are creating a banking program, we can give our class the following characteristics:

name: BankAccount

attributes: accountNumber, balance, dateOpened

behavior: open(), close(), deposit()

The class specifies that each object should have the defined attributes and behavior. However, it doesn't specify what the actual data is; it only provides a definition.

Once we've written the class, we can move on to create objects that are based on that class.

Each object is called an instance of a class. The process of creating objects is called instantiation.

Each object has its own identity, data, and behavior.

++=====================++
++=====================++ Example of a Class

===================================================================
Declaring a Class 

Begin your class definition with the keyword class. Follow the keyword with the class name and the class body, enclosed in a set of curly braces. 

The following code declares a class called BankAccount: 

class BankAccount {

};
C++

A class definition must be followed by a semicolon.
===================================================================
Declaring a Class 

Define all attributes and behavior (or members) in the body of the class, within curly braces.

You can also define an access specifier for members of the class.

A member that has been defined using the public keyword can be accessed from outside the class, as long as it's anywhere within the scope of the class object.

You can also designate a class' members as private or protected. This will be discussed in greater detail later in the course.
===================================================================
Creating a Class 

Let's create a class with one public method, and have it print out "Hi". 

class BankAccount {
  public:
    void sayHi() {
      cout << "Hi" << endl;
    }
};
C++

The next step is to instantiate an object of our BankAccount class, in the same way we define variables of a type, the difference being that our object's type will be BankAccount.
#include <iostream>
using namespace std;

class BankAccount {
    public:
        void sayHi() {
            cout << "Hi" << endl;
        }
};

int main() 
{
    BankAccount test;
    test.sayHi();
}
Our object named test has all the members of the class defined.

Notice the dot separator (.) that is used to access and call the method of the object.

We must declare a class before using it, as we do with functions.

++=====================++
++=====================++ Abstraction

===================================================================
##Abstraction

Abstraction

Data abstraction is the concept of providing only essential information to the outside world. It's a process of representing essential features without including implementation details.

A good real-world example is a book: When you hear the term book, you don't know the exact specifics, i.e.: the page count, the color, the size, but you understand the idea of a book - the abstraction of the book.

The concept of abstraction is that we focus on essential qualities, rather than the specific characteristics of one particular example.
===================================================================
Abstraction 

Abstraction means, that we can have an idea or a concept that is completely separate from any specific instance.

It is one of the fundamental building blocks of object oriented programming.

For example, when you use cout, you're actually using the cout object of the class ostream. This streams data to result in standard output.

cout << "Hello!" << endl;
C++

In this example, there is no need to understand how cout will display the text on the user's screen. The only thing you need to know to be able to use it is the public interface.
===================================================================
Abstraction 

Abstraction allows us to write a single bank account class, and then create different objects based on the class, for individual bank accounts, rather than creating a separate class for each bank account. 
img-component

Abstraction acts as a foundation for the other object orientation fundamentals, such as inheritance and polymorphism. These will be discussed later in the course.

++=====================++
++=====================++ Encapsulation 
===================================================================
Encapsulation 

Part of the meaning of the word encapsulation is the idea of "surrounding" an entity, not just to keep what's inside together, but also to protect it.

In object orientation, encapsulation means more than simply combining attributes and behavior together within a class; it also means restricting access to the inner workings of that class.

The key principle here is that an object only reveals what the other application components require to effectively run the application. All else is kept out of view. 

This is called data hiding.

===================================================================
Encapsulation  

For example, if we take our BankAccount class, we do not want some other part of our program to reach in and change the balance of any object, without going through the deposit() or withdraw() behaviors.

We should hide that attribute, control access to it, so it is accessible only by the object itself.

This way, the balance cannot be directly changed from outside of the object and is accessible only using its methods.

This is also known as "black boxing", which refers to closing the inner working zones of the object, except of the pieces that we want to make public.

This allows us to change attributes and implementation of methods without altering the overall program. For example, we can come back later and change the data type of the balance attribute.

In summary the benefits of encapsulation are:

- Control the way data is accessed or modified.

- Code is more flexible and easy to change with new requirements.

- Change one part of code without affecting other part of code.

++=====================++
++=====================++ Example of Encapsulation
===================================================================
Access Specifiers
Access specifiers are used to set access levels to particular members of the class.

The three levels of access specifiers are public, protected, and private.

A public member is accessible from outside the class, and anywhere within the scope of the class object.

For example: #include <iostream>
#include <string>
using namespace std;

class myClass {
    public:
        string name;
};

int main() {
    myClass myObj;
    myObj.name = "SoloLearn";
    cout << myObj.name;

    return 0;
}
The name attribute is public; it can be accessed and modified from outside the code.

Access modifiers only need to be declared once; multiple members can follow a single access modifier.

Notice the colon (:) that follows the public keyword.

===================================================================
Private 

A private member cannot be accessed, or even viewed, from outside the class; it can be accessed only from within the class.

A public member function may be used to access the private members. For example: 
===================================================================
#include <iostream>
#include <string>
using namespace std;

class myClass {
    public:
        void setName(string x) {
            name = x;
        }
    private:
        string name;
};

int main() {
    myClass myObj;
    myObj.setName("John");

    return 0;
}
===================================================================
The name attribute is private and not accessible from the outside.

The public setName() method is used to set the name attribute.

If no access specifier is defined, all members of a class are set to private by default.
===================================================================
++=====================++
++=====================++

Access Specifiers 

We can add another public method in order to get the value of the attribute.
class myClass {
  public:
    void setName(string x) {
      name = x;
    }
    string getName() {
      return name;
    }
  private:
    string name;
};

The getName() method returns the value of the private name attribute.
===================================================================
Access Specifiers 

Putting it all together:
#include <iostream>
#include <string>
using namespace std;

class myClass {
    public:
        void setName(string x) {
            name = x;
        }
        string getName() {
            return name;
        }
    private:
        string name;
};

int main() {
    myClass myObj;
    myObj.setName("John");
    cout << myObj.getName();

    return 0;
}

We used encapsulation to hide the name attribute from the outside code. Then we provided access to it using public methods. Our class data can be read and modified only through those methods.

This allows for changes to the implementation of the methods and attributes, without affecting the outside code.

++=====================++
++=====================++ Abstraction
===================================================================
Abstraction

Data abstraction is the concept of providing only essential information to the outside world. It's a process of representing essential features without including implementation details.

A good real-world example is a book: When you hear the term book, you don't know the exact specifics, i.e.: the page count, the color, the size, but you understand the idea of a book - the abstraction of the book.

The concept of abstraction is that we focus on essential qualities, rather than the specific characteristics of one particular example.
===================================================================
Abstraction 

Abstraction means, that we can have an idea or a concept that is completely separate from any specific instance.

It is one of the fundamental building blocks of object oriented programming.

For example, when you use cout, you're actually using the cout object of the class ostream. This streams data to result in standard output.

cout << "Hello!" << endl;
C++

In this example, there is no need to understand how cout will display the text on the user's screen. The only thing you need to know to be able to use it is the public interface.
===================================================================
Abstraction 

Abstraction allows us to write a single bank account class, and then create different objects based on the class, for individual bank accounts, rather than creating a separate class for each bank account. 
img-component

Abstraction acts as a foundation for the other object orientation fundamentals, such as inheritance and polymorphism. These will be discussed later in the course.
===================================================================
++=====================++
++=====================++ Constructors

Constructors 
Class constructors are special member functions of a class. They are executed whenever new objects are created within that class.

The constructor's name is identical to that of the class. It has no return type, not even void.

For example:
#include <iostream>
using namespace std;

class myClass {
    public:
        myClass() {
            cout <<"Hey";
        }
        void setName(string x) {
            name = x;
        }
        string getName() {
            return name;
        }
    private:
        string name;
};

int main() {
    myClass myObj;

    return 0;
}

Now, upon the creation of an object of type myClass, the constructor is automatically called.

===================================================================
Constructors 
Constructors can be very useful for setting initial values for certain member variables.

A default constructor has no parameters. However, when needed, parameters can be added to a constructor. This makes it possible to assign an initial value to an object when it's created, as shown in the following example:

class myClass {
  public:
    myClass(string nm) {
      setName(nm);
    }
    void setName(string x) {
      name = x;
    }
    string getName() {
      return name;
    }
  private:
    string name;
};
C++
We defined a constructor, that takes one parameter and assigns it to the name attribute using the setName() method.
++=====================++
++=====================++ Separate files for Deletion
Creating a New Class 
It is generally a good practice to define your new classes in separate files. This makes maintaining and reading the code easier.

To do this, use the following steps in CodeBlocks:

Click File->New->Class... 

Give your new class a name, uncheck "Has destructor" and check "Header and implementation file shall be in same folder", then click the "Create" button. 

img-component
Note that two new files have been added to your project:

img-component
The new files act as templates for our new class.

- MyClass.h is the header file.

- MyClass.cpp is the source file.
++=====================++
++=====================++
Source & Header 
The header file (.h) holds the function declarations (prototypes) and variable declarations. 

It currently includes a template for our new MyClass class, with one default constructor.

MyClass.h

#ifndef MYCLASS_H
#define MYCLASS_H

class MyClass
{
  public:
    MyClass();
  protected:
  private:
};

#endif // MYCLASS_H
C++
The implementation of the class and its methods go into the source file (.cpp).

Currently it includes just an empty constructor.

MyClass.cpp

#include "MyClass.h"

MyClass::MyClass()
{
   //ctor
}
C++
The #ifndef and #define statements in the header file will be discussed in the upcoming lessons.
===================================================================
Scope Resolution Operator 
The double colon in the source file (.cpp) is called the scope resolution operator, and it's used for the constructor definition:

#include "MyClass.h"

MyClass::MyClass()
{
   //ctor
}
C++
The scope resolution operator is used to define a particular class' member functions, which have already been declared. Remember that we defined the constructor prototype in the header file.

So, basically, MyClass::MyClass() refers to the MyClass() member function - or, in this case, constructor - of the MyClass class.


===================================================================
Source & Header 
To use our classes in our main, we need to include the header file. 

For example, to use our newly created MyClass in main: 

#include <iostream>
#include "MyClass.h"
using namespace std;

int main() {
  MyClass obj;
}
C++
The header declares "what" a class (or whatever is being implemented) will do, while the cpp source file defines "how" it will perform those features.
===================================================================
++=====================++
++=====================++ Destructors
Destructors 
Remember constructors? They're special member functions that are automatically called when an object is created.

Destructors are special functions, as well. They're called when an object is destroyed or deleted.

Objects are destroyed when they go out of scope, or whenever the delete expression is applied to a pointer directed at an object of a class.

===================================================================
Destructors 
The name of a destructor will be exactly the same as the class, only prefixed with a tilde (~). A destructor can't return a value or take any parameters.

class MyClass {
  public: 
    ~MyClass() {
     // some code
    }
};
C++
Destructors can be very useful for releasing resources before coming out of the program. This can include closing files, releasing memory, and so on.
===================================================================
Destructors 
For example, let's declare a destructor for our MyClass class, in its header file MyClass.h: 

class MyClass
{
  public:
   MyClass();
   ~MyClass();
};
C++
Declare a destructor for our MyClass class.
===================================================================
Destructors 
After declaring the destructor in the header file, we can write the implementation in the source file MyClass.cpp: 

#include "MyClass.h"
#include <iostream>
using namespace std;

MyClass::MyClass()
{
  cout<<"Constructor"<<endl;
}

MyClass::~MyClass()
{
  cout<<"Destructor"<<endl;
}

Note that we included the <iostream> header, so that we can use cout.
===================================================================
Destructors 
Since destructors can't take parameters, they also can't be overloaded. 

Each class will have just one destructor.

Defining a destructor is not mandatory; if you don't need one, you don't have to define one.
===================================================================
Destructors 
Let's return to our main.
#include <iostream>
using namespace std;

class MyClass
{
    public:
        MyClass();
        ~MyClass();
};

MyClass::MyClass()
{
    cout<<"Constructor"<<endl;
}

MyClass::~MyClass()
{
    cout<<"Destructor"<<endl;
}

int main() {
    MyClass obj;
}

We included the class' header file and then created an object of that type.

This returns the following output:

Constructor
Destructor
C++
When the program runs, it first creates the object and calls the constructor. The object is deleted and the destructor is called when the program's execution is completed.

Remember that we printed "Constructor" from the constructor and "Destructor" from the destructor.
===================================================================
++=====================++
++=====================++ Selection Operator
#ifndef & #define 
We created separate header and source files for our class, which resulted in this header file.

#ifndef MYCLASS_H
#define MYCLASS_H

class MyClass
{
  public:
  MyClass();
  protected:
  private:
};

#endif // MYCLASS_H 
C++
ifndef stands for "if not defined". The first pair of statements tells the program to define the MyClass header file if it has not been defined already.

endif ends the condition.

This prevents a header file from being included more than once within one file.
===================================================================
Member Functions 
Let's create a sample function called myPrint() in our class. 

MyClass.h

 

class MyClass
{
  public:
   MyClass();
   void myPrint();
};
C++
MyClass.cpp

#include "MyClass.h"
#include <iostream>
using namespace std;

MyClass::MyClass() {
}

void MyClass::myPrint() {
  cout <<"Hello"<<endl;
}
C++
Since myPrint() is a regular member function, it's necessary to specify its return type in both the declaration and the definition.
===================================================================
Dot Operator 
Next, we'll create an object of the type MyClass, and call its myPrint() function using the dot (.) operator:
#include <iostream>
using namespace std;

class MyClass
{
    public:
        MyClass();
        void myPrint();
};

MyClass::MyClass() {
}
void MyClass::myPrint() {
    cout <<"Hello"<<endl;
}

int main() {
    MyClass obj;
    obj.myPrint();
}

Run the code and see how it works!
OUTPUT
Hello
===================================================================
Pointers  
We can also use a pointer to access the object's members. 

The following pointer points to the obj object:

MyClass obj;
MyClass *ptr = &obj;
C++
The type of the pointer is MyClass, as it points to an object of that type.
===================================================================
Selection Operator 
The arrow member selection operator (->) is used to access an object's members with a pointer.
#include <iostream>
using namespace std;

class MyClass
{
    public:
        MyClass();
        void myPrint();
};

MyClass::MyClass() {
}
void MyClass::myPrint() {
    cout <<"Hello"<<endl;
}

int main() {
    MyClass obj;
    MyClass *ptr = &obj;
    ptr->myPrint();
}
When working with an object, use the dot member selection operator (.).

When working with a pointer to the object, use the arrow member selection operator (->).
===================================================================
++=====================++
++=====================++ Constant Objects
Constants 
A constant is an expression with a fixed value. It cannot be changed while the program is running.

Use the const keyword to define a constant variable. 

const int x = 42;
C++
All constant variables must be initialized at the time of their creation.
===================================================================
Constant Objects 
As with the built-in data types, we can make class objects constant by using the const keyword.

const MyClass obj;
C++
All const variables must be initialized when they're created. In the case of classes, this initialization is done via constructors. If a class is not initialized using a parameterized constructor, a public default constructor must be provided - if no public default constructor is provided, a compiler error will occur.

Once a const class object has been initialized via the constructor, you cannot modify the object's member variables. This includes both directly making changes to public member variables and calling member functions that set the value of member variables.

When you've used const to declare an object, you can't change its data members during the object's lifetime.
===================================================================
Constant Objects 
Only non-const objects can call non-const functions.

A constant object can't call regular functions. Hence, for a constant object to work you need a constant function. 

To specify a function as a const member, the const keyword must follow the function prototype, outside of its parameters' closing parenthesis. For const member functions that are defined outside of the class definition, the const keyword must be used on both the function prototype and definition. For example:

MyClass.h 

class MyClass
{
public:
void myPrint() const;
};
C++
MyClass.cpp

#include "MyClass.h"
#include <iostream>
using namespace std;

void MyClass::myPrint() const {
cout <<"Hello"<<endl;
}
C++
Now the myPrint() function is a constant member function. As such, it can be called by our constant object:
#include <iostream>
using namespace std;

class MyClass
{
    public:
        void myPrint() const;
};

void MyClass::myPrint() const {
    cout <<"Hello"<<endl;
}

int main() {
    const MyClass obj;
    obj.myPrint();
}
OUTPUT
Hello
===================================================================
Constant Objects
Attempting to call a regular function from a constant object results in an error.

In addition, a compiler error is generated when any const member function attempts to change a member variable or to call a non-const member function.

Defining constant objects and functions ensures that corresponding data members cannot be unexpectedly modified.
===================================================================
++=====================++
++=====================++ Member Initializers
Member Initializers 
Recall that constants are variables that cannot be changed, and that all const variables must be initialized at time of creation.

C++ provides a handy syntax for initializing members of the class called the member initializer list (also called a constructor initializer).
===================================================================
Member Initializers  
Consider the following class: 

class MyClass {
  public:
   MyClass(int a, int b) {
    regVar = a;
    constVar = b;
   }
  private:
    int regVar;
    const int constVar;
};
C++
This class has two member variables, regVar and constVar. It also has a constructor that takes two parameters, which are used to initialize the member variables.

Running this code returns an error, because one of its member variables is a constant, which cannot be assigned a value after declaration.

In cases like this one, a member initialization list can be used to assign values to the member variables.

class MyClass {
 public:
  MyClass(int a, int b)
  : regVar(a), constVar(b)
  {
  }
 private:
  int regVar;
  const int constVar;
};
C++
Note that in the syntax, the initialization list follows the constructor parameters. The list begins with a colon (:), and then lists each variable to be initialized, along with the value for that variable, with a comma to separate them.

Use the syntax variable(value) to assign values.

The initialization list eliminates the need to place explicit assignments in the constructor body. Also, the initialization list does not end with a semicolon.
===================================================================
Member Initializers 
Let's write the previous example using separate header and source files.

MyClass.h

 

class MyClass {
  public:
   MyClass(int a, int b);
  private:
   int regVar;
   const int constVar;
};
C++
MyClass.cpp

MyClass::MyClass(int a, int b)
: regVar(a), constVar(b)
{
  cout << regVar << endl;
  cout << constVar << endl;
}
C++
We have added cout statements in the constructor to print the values of the member variables.

Our next step is to create an object of our class in main, and use the constructor to assign values.

#include <iostream>
using namespace std;

class MyClass {
    public:
        MyClass(int a, int b);
    private:
        int regVar;
        const int constVar;
};

MyClass::MyClass(int a, int b)
: regVar(a), constVar(b)
{
    cout << regVar << endl;
    cout << constVar << endl;
}

int main() {
    MyClass obj(42, 33);
}

OUTPUT
42
33

The constructor is used to create the object, assigning two parameters to the member variables via the member initialization list.
===================================================================
Member Initializers 
The member initialization list may be used for regular variables, and must be used for constant variables.

Even in cases in which member variables are not constant, it makes good sense to use the member initializer syntax.
===================================================================
++=====================++
++=====================++ Composition Part 1

Composition 
In the real world, complex objects are typically built using smaller, simpler objects. For example, a car is assembled using a metal frame, an engine, tires, and a large number of other parts. This process is called composition.

In C++, object composition involves using classes as member variables in other classes.

This sample program demonstrates composition in action. It contains Person and Birthday classes, and each Person will have a Birthday object as its member.

Birthday:

class Birthday {
 public:
  Birthday(int m, int d, int y)
  : month(m), day(d), year(y)
  { 
  }
 private:
   int month;
   int day;
   int year;
};
C++
Our Birthday class has three member variables. It also has a constructor that initializes the members using a member initialization list.

The class was declared in a single file for the sake of simplicity. Alternatively, you could use header and source files.
===================================================================
Composition 
Let's also add a printDate() function to our Birthday class: 

class Birthday {
 public:
  Birthday(int m, int d, int y)
  : month(m), day(d), year(y)
  {
  }
  void printDate()
  {
   cout<<month<<"/"<<day
   <<"/"<<year<<endl;
  }
 private:
  int month;
  int day;
  int year;
};
C++
Add a printDate() function to our Birthday class.
===================================================================
Composition 
Next, we can create the Person class, which includes the Birthday class.

#include <string>
#include "Birthday.h"

class Person {
 public:
  Person(string n, Birthday b)
  : name(n),
   bd(b)
  {
  }
 private:
  string name;
  Birthday bd;
};
C++
The Person class has a name and a Birthday member, and a constructor to initialize them.

Ensure that the corresponding header files are included.

More on Composition coming up in the next lesson!
===================================================================
++=====================++
++=====================++ Composition Part 2

Composition 
Now, our Person class has a member of type Birthday:

class Person {
 public:
  Person(string n, Birthday b)
  : name(n),
    bd(b)
  {
  }
 private:
  string name;
  Birthday bd;
};
C++
Composition is used for objects that share a has-a relationship, as in "A Person has a Birthday".
===================================================================
Composition 
Let's add a printInfo() function to our Person class, that prints the data of the object: 

class Person {
 public:
  Person(string n, Birthday b)
  : name(n),
  bd(b)
  {
  }
  void printInfo()
  {
   cout << name << endl;
   bd.printDate();
  }
 private:
  string name;
  Birthday bd;
};
C++
Notice that we can call the bd member's printDate() function, since it's of type Birthday, which has that function defined.
===================================================================
Composition 
Now that we've defined our Birthday and Person classes, we can go to our main, create a Birthday object, and then pass it to a Person object.

#include <iostream>
using namespace std;

class Birthday {
    public:
        Birthday(int m, int d, int y)
        : month(m), day(d), year(y)
        {  }
        void printDate()
        {
            cout<<month<<"/"<<day <<"/"<<year<<endl;
        }
    private:
        int month;
        int day;
        int year;
};

class Person {
    public:
        Person(string n, Birthday b)
        : name(n), bd(b)
        {  }
        void printInfo()
        {
            cout << name << endl;
            bd.printDate();
        }
    private:
        string name;
        Birthday bd;
};

int main() {
    Birthday bd(2, 21, 1985);
    Person p("David", bd);
    p.printInfo();
}

OUTPUT
David
2/21/1985

We've created a Birthday object for the date of 2/21/1985. Next, we created a Person object and passed the Birthday object to its constructor. Finally, we used the Person object's printInfo() function to print its data.

In general, composition serves to keep each individual class relatively simple, straightforward, and focused on performing one task. It also enables each sub-object to be self-contained, allowing for reusability (we can use the Birthday class within various other classes).
===================================================================
++=====================++
++=====================++ The Friend Keyword

Friend Functions 
Normally, private members of a class cannot be accessed from outside of that class.

However, declaring a non-member function as a friend of a class allows it to access the class' private members. This is accomplished by including a declaration of this external function within the class, and preceding it with the keyword friend. 

In the example below, someFunc(), which is not a member function of the class, is a friend of MyClass and can access its private members. 

class MyClass {
 public:
  MyClass() {
   regVar = 0;
  }
 private:
  int regVar;
    
  friend void someFunc(MyClass &obj);
};
C++
Note that when passing an object to the function, we need to pass it by reference, using the & operator.
===================================================================
Friend Functions 
The function someFunc() is defined as a regular function outside the class. It takes an object of type MyClass as its parameter, and is able to access the private data members of that object.

class MyClass {
 public:
  MyClass() {
   regVar = 0;
  }
 private:
  int regVar;
    
 friend void someFunc(MyClass &obj);
};

void someFunc(MyClass &obj) {
  obj.regVar = 42;
  cout << obj.regVar;
}
C++
The someFunc() function changes the private member of the object and prints its value.

To make its members accessible, the class has to declare the function as a friend in its definition. You cannot "make" a function a friend to a class without the class "giving away" its friendship to that function.
===================================================================
Friend Functions 
Now we can create an object in main and call the someFunc() function:
#include <iostream>
using namespace std;

class MyClass {
    public:
        MyClass() {
            regVar = 0;
        }
    private:
        int regVar;

    friend void someFunc(MyClass &obj);
};

void someFunc(MyClass &obj) {
    obj.regVar = 42;
    cout << obj.regVar;
}

int main() {
    MyClass obj;
    someFunc(obj);
}

OUTPUT
42

someFunc() had the ability to modify the private member of the object and print its value.

Typical use cases of friend functions are operations that are conducted between two different classes accessing private members of both.

You can declare a function friend across any number of classes.

Similar to friend functions, you can define a friend class, which has access to the private members of another class.
===================================================================
++=====================++
++=====================++ The This Keyword

This 
Every object in C++ has access to its own address through an important pointer called the this pointer.

Inside a member function this may be used to refer to the invoking object.

Let's create a sample class: 

class MyClass {
 public:
  MyClass(int a) : var(a)
  { }
 private:
  int var;
};
C++
Friend functions do not have a this pointer, because friends are not members of a class.
===================================================================
This 
The printInfo() method offers three alternatives for printing the member variable of the class. 

class MyClass {
 public:
  MyClass(int a) : var(a)
  { }
  void printInfo() {
   cout << var<<endl;
   cout << this->var<<endl;
   cout << (*this).var<<endl; 
  }
 private:
  int var;
};
C++
All three alternatives will produce the same result.

this is a pointer to the object, so the arrow selection operator is used to select the member variable.
===================================================================
This 
To see the result, we can create an object of our class and call the member function.
#include <iostream>
using namespace std;

class MyClass {
    public:
        MyClass(int a) : var(a)
        { }
        void printInfo() {
            cout << var <<endl;
            cout << this->var <<endl;
            cout << (*this).var <<endl; 
        }
    private:
        int var;
};

int main() {
    MyClass obj(42);
    obj.printInfo();
}
OUTPUT
42
42
42

All three of the ways to access the member variable work.

Note that only member functions have a this pointer.
===================================================================
This 
You may be wondering why it's necessary to use the this keyword, when you have the option of directly specifying the variable.

The this keyword has an important role in operator overloading, which will be covered in the following lesson.
===================================================================
++=====================++
++=====================++ Operator Overloading

Operator Overloading 
Most of the C++ built-in operators can be redefined or overloaded.  

Thus, operators can be used with user-defined types as well (for example, allowing you to add two objects together).

This chart shows the operators that can be overloaded.  

img-component
Operators that can't be overloaded include :: | .* | . | ?:
===================================================================
Operator Overloading 
Let's declare a sample class to demonstrate operator overloading: 

class MyClass {
 public:
  int var;
  MyClass() {}
  MyClass(int a)
  : var(a) { }
};
C++
Our class has two constructors and one member variable.

We will be overloading the + operator, to enable adding two objects of our class together.
===================================================================
Operator Overloading 
Overloaded operators are functions, defined by the keyword operator followed by the symbol for the operator being defined.

An overloaded operator is similar to other functions in that it has a return type and a parameter list.

In our example we will be overloading the + operator. It will return an object of our class and take an object of our class as its parameter. 

class MyClass {
 public:
  int var;
  MyClass() {}
  MyClass(int a)
  : var(a) { }

  MyClass operator+(MyClass &obj) {
  }
};
C++
Now, we need to define what the function does.
===================================================================
Operator Overloading 
We need our + operator to return a new MyClass object with a member variable equal to the sum of the two objects' member variables.

class MyClass {
 public:
  int var;
  MyClass() {}
  MyClass(int a)
  : var(a) { }

  MyClass operator+(MyClass &obj) {
   MyClass res;
   res.var= this->var+obj.var;
   return res; 
  }
};
C++
Here, we declared a new res object. We then assigned the sum of the member variables of the current object (this) and the parameter object (obj) to the res object's var member variable. The res object is returned as the result.

This gives us the ability to create objects in main and use the overloaded + operator to add them together.
#include <iostream>
using namespace std;

class MyClass {
    public:
        int var;
        MyClass() { }
        MyClass(int a)
        : var(a) { }

        MyClass operator+(MyClass &obj) {
            MyClass res;
            res.var= this->var+obj.var;
            return res; 
        }
};

int main() {
    MyClass obj1(12), obj2(55);
    MyClass res = obj1+obj2;

    cout << res.var;
}
OUTPUT
67

With overloaded operators, you can use any custom logic needed. However, it's not possible to alter the operators' precedence, grouping, or number of operands.
===================================================================
++=====================++
++=====================++ Inheritance

Inheritance 
Inheritance is one of the most important concepts of object-oriented programming.

Inheritance allows us to define a class based on another class. This facilitates greater ease in creating and maintaining an application.  

The class whose properties are inherited by another class is called the Base class. The class which inherits the properties is called the Derived class. For example, the Daughter class (derived) can be inherited from the Mother class (base).

The derived class inherits all feature from the base class, and can have its own additional features.  

img-component
The idea of inheritance implements the is a relationship. For example, mammal IS-A animal, dog IS-A mammal, hence dog IS-A animal as well.
===================================================================
Inheritance 
To demonstrate inheritance, let's create a Mother class and a Daughter class: 

class Mother
{
 public:
  Mother() {};
  void sayHi() {
    cout << "Hi";
  } 
};

class Daughter 
{
 public: 
  Daughter() {};
};
C++
The Mother class has a public method called sayHi().

The next step is to inherit (derive) the Daughter from the Mother.
===================================================================
Inheritance
This syntax derives the Daughter class from the Mother class.

class Daughter : public Mother
{
 public: 
  Daughter() {};
};
C++
The Base class is specified using a colon and an access specifier: public means that all public members of the base class are public in the derived class.

In other words, all public members of the Mother class become public members of the Daughter class.
===================================================================
Inheritance 
As all public members of the Mother class become public members for the Daughter class, we can create an object of type Daughter and call the sayHi() function of the Mother class for that object: 

#include <iostream>
using namespace std;

class Mother
{
    public:
        Mother() {};
        void sayHi() {
            cout << "Hi";
        }
};

class Daughter: public Mother
{
    public:
        Daughter() {};
};

int main() {
    Daughter d;
    d.sayHi();
}
OUTPUT
Hi
===================================================================
++=====================++
++=====================++ Protected Members

Access Specifiers 
Up to this point, we have worked exclusively with public and private access specifiers. 

Public members may be accessed from anywhere outside of the class, while access to private members is limited to their class and friend functions.

As we've seen previously, it's a good practice to use public methods to access private class variables.
===================================================================
Protected
There is one more access specifier - protected.

A protected member variable or function is very similar to a private member, with one difference - it can be accessed in the derived classes.

class Mother {
 public:
  void sayHi() {
   cout << var;
  }

 private:
  int var=0;

 protected:
 int someVar;
};
C++
Now someVar can be accessed by any class that is derived from the Mother class.
===================================================================
Type of Inheritance
Access specifiers are also used to specify the type of inheritance. 

Remember, we used public to inherit the Daughter class: 

class Daughter: public Mother
C++
private and protected access specifiers can also be used here.

Public Inheritance: public members of the base class become public members of the derived class and protected members of the base class become protected members of the derived class. A base class' private members are never accessible directly from a derived class, but can be accessed through calls to the public and protected members of the base class.

Protected Inheritance: public and protected members of the base class become protected members of the derived class.

Private Inheritance: public and protected members of the base class become private members of the derived class.

Public inheritance is the most commonly used inheritance type.

If no access specifier is used when inheriting classes, the type becomes private by default.
===================================================================
++=====================++
++=====================++ Derived Class Constructor & Destructor

Inheritance
When inheriting classes, the base class' constructor and destructor are not inherited.

However, they are being called when an object of the derived class is created or deleted.

To further explain this behavior, let's create a sample class that includes a constructor and a destructor:

class Mother {
 public:
 Mother() 
 {
  cout <<"Mother ctor"<<endl;
 }
 ~Mother()
 {
  cout <<"Mother dtor"<<endl;
 }
};


Creating an object in main results in the following output:
#include <iostream>
using namespace std;

class Mother {
    public:
        Mother() 
        {
            cout <<"Mother ctor"<<endl;
        }
        ~Mother()

Click to Edit

The object is created and then deleted, when the program finishes to run.
===================================================================
Inheritance
Next, let's create a Daughter class, with its own constructor and destructor, and make it a derived class of the Mother:

class Daughter: public Mother {
public:
 Daughter()
 {
  cout <<"Daughter ctor"<<endl;
 }
 ~Daughter()
 {
  cout <<"Daughter dtor"<<endl;
 }
};
C++
Create a Daughter class, with its own constructor and destructor.
===================================================================
Inheritance
Now, what happens when we create a Daughter object?
#include <iostream>
using namespace std;

class Mother {
    public:
        Mother() 
        {
            cout <<"Mother ctor"<<endl;
        }
        ~Mother()
        {
            cout <<"Mother dtor"<<endl;
        }
};

class Daughter: public Mother {
    public:
        Daughter()
        {
            cout <<"Daughter ctor"<<endl;
        }
        ~Daughter()
        {
            cout <<"Daughter dtor"<<endl;
        }
};

int main() {
    Daughter m;
}
OUTPUT
Mother ctor
Daughter ctor
Daughter dtor
Mother dtor

Note that the base class' constructor is called first, and the derived class' constructor is called next.

When the object is destroyed, the derived class' destructor is called, and then the base class' destructor is called.

You can think of it as the following: The derived class needs its base class in order to work - that is why the base class is set up first.
===================================================================
Summary
Constructors

The base class constructor is called first.

Destructors 

The derived class destructor is called first, and then the base class destructor gets called. 

This sequence makes it possible to specify initialization and de-initialization scenarios for your derived classes.
===================================================================
++=====================++
++=====================++ Polymorphism

Polymorphism
The word polymorphism means "having many forms".

Typically, polymorphism occurs when there is a hierarchy of classes and they are related by inheritance.

C++ polymorphism means that a call to a member function will cause a different implementation to be executed depending on the type of object that invokes the function.

Simply, polymorphism means that a single function can have a number of different implementations.
===================================================================
Polymorphism
Polymorphism can be demonstrated more clearly using an example:

Suppose you want to make a simple game, which includes different enemies: monsters, ninjas, etc. All enemies have one function in common: an attack function. However, they each attack in a different way. In this situation, polymorphism allows for calling the same attack function on different objects, but resulting in different behaviors. 

The first step is to create the Enemy class.

class Enemy {
 protected: 
  int attackPower;
 public:
  void setAttackPower(int a){
   attackPower = a;
  }
};
C++
Our Enemy class has a public method called setAttackPower, which sets the protected attackPower member variable.
===================================================================
Polymorphism
Our second step is to create classes for two different types of enemies, Ninjas and Monsters. Both of these new classes inherit from the Enemy class, so each has an attack power. At the same time, each has a specific attack function. 

class Ninja: public Enemy {
 public:
  void attack() {
   cout << "Ninja! - "<<attackPower<<endl;
  }
};

class Monster: public Enemy {
 public:
  void attack() {
   cout << "Monster! - "<<attackPower<<endl;
  }
};
C++
As you can see, their individual attack functions differ.

Now we can create our Ninja and Monster objects in main.

int main() {   
 Ninja n;
 Monster m;  
}
C++
Ninja and Monster inherit from Enemy, so all Ninja and Monster objects are Enemy objects. This allows us to do the following:

Enemy *e1 = &n;
Enemy *e2 = &m;
C++
We've now created two pointers of type Enemy, pointing them to the Ninja and Monster objects.
===================================================================
Polymorphism
Now, we can call the corresponding functions: 
#include <iostream>
using namespace std;

class Enemy {
    protected: 
        int attackPower;
    public:
        void setAttackPower(int a){
            attackPower = a;
        }
};

class Ninja: public Enemy {
    public:
        void attack() {
            cout << "Ninja! - "<<attackPower<<endl;
        }
};

class Monster: public Enemy {
    public:
        void attack() {
            cout << "Monster! - "<<attackPower<<endl;
        }
};

int main() {
    Ninja n;
    Monster m;
    Enemy *e1 = &n;
    Enemy *e2 = &m;

    e1->setAttackPower(20);
    e2->setAttackPower(80);

    n.attack();
    m.attack();
}
OUTPUT
Ninja! - 20
Monster! - 80

We would have achieved the same result by calling the functions directly on the objects. However, it's faster and more efficient to use pointers.

Also, the pointer demonstrates, that you can use the Enemy pointer without actually knowing that it contains an object of the subclass.
===================================================================
++=====================++
++=====================++ Virtual Functions
Virtual Functions
The previous example demonstrates the use of base class pointers to the derived classes. Why is that useful? Continuing on with our game example, we want every Enemy to have an attack() function. 

To be able to call the corresponding attack() function for each of the derived classes using Enemy pointers, we need to declare the base class function as virtual.

Defining a virtual function in the base class, with a corresponding version in a derived class, allows polymorphism to use Enemy pointers to call the derived classes' functions.

Every derived class will override the attack() function and have a separate implementation:

class Enemy {
 public:
  virtual void attack() {
  }
};

class Ninja: public Enemy {
 public:
  void attack() {
   cout << "Ninja!"<<endl;
  }
};

class Monster: public Enemy {
 public:
  void attack() {
   cout << "Monster!"<<endl;
 }
};
C++
A virtual function is a base class function that is declared using the keyword virtual.
===================================================================
Virtual Functions
Now, we can use Enemy pointers to call the attack() function.
#include <iostream>
using namespace std;

class Enemy {
    public:
        virtual void attack() { }
};

class Ninja: public Enemy {
    public:
        void attack() {
            cout << "Ninja!"<<endl;
  }
};

class Monster: public Enemy {
    public:
        void attack() {
            cout << "Monster!"<<endl;
        }
};

int main() {
    Ninja n;
    Monster m;
    Enemy *e1 = &n;
    Enemy *e2 = &m;

    e1->attack();
    e2->attack();
}
OUTPUT
Ninja!
Monster!

As the attack() function is declared virtual, it works like a template, telling that the derived class might have an attack() function of its own.
===================================================================
Virtual Functions
Our game example serves to demonstrate the concept of polymorphism; we are using Enemy pointers to call the same attack() function, and generating different results.

e1->attack();
e2->attack();
C++
If a function in the base class is virtual, the function's implementation in the derived class is called according to the actual type of the object referred to, regardless of the declared type of the pointer.

A class that declares or inherits a virtual function is called a polymorphic class.
===================================================================
++=====================++
++=====================++ Abstract Classes

Virtual Functions
Virtual functions can also have their implementation in the base class: 

class Enemy {
 public:
  virtual void attack() {
   cout << "Enemy!"<<endl;
  }
};

class Ninja: public Enemy {
 public:
  void attack() {
   cout << "Ninja!"<<endl;
  }
};

class Monster: public Enemy {
 public:
  void attack() {
   cout << "Monster!"<<endl;
  }
};
C++
Now, when you create an Enemy pointer, and call the attack() function, the compiler will call the function, which corresponds to the object's type, to which the pointer points:
#include <iostream>
using namespace std;

class Enemy {
    public:
        virtual void attack() {
            cout << "Enemy!"<<endl;
        }
};

class Ninja: public Enemy {
    public:
        void attack() {
            cout << "Ninja!"<<endl;
        }
};

class Monster: public Enemy {
    public:
        void attack() {
            cout << "Monster!"<<endl;
        }
};

int main() {
    Ninja n;
    Monster m;
    Enemy e;

    Enemy *e1 = &n;
    Enemy *e2 = &m;
    Enemy *e3 = &e;

    e1->attack();
    // Outputs "Ninja!"

    e2->attack();
    // Outputs "Monster!"

    e3->attack();
    // Outputs "Enemy!"
}
OUTPUT
Ninja!
Monster!
Enemy!

This is how polymorphism is generally used. You have different classes with a function of the same name, and even the same parameters, but with different implementations.
===================================================================
Pure Virtual Function
In some situations you'd want to include a virtual function in a base class so that it may be redefined in a derived class to suit the objects of that class, but that there is no meaningful definition you could give for the function in the base class.

The virtual member functions without definition are known as pure virtual functions. They basically specify that the derived classes define that function on their own.

The syntax is to replace their definition by =0 (an equal sign and a zero): 

class Enemy {
 public:
  virtual void attack() = 0;
};
C++
The = 0 tells the compiler that the function has no body.
===================================================================
Pure Virtual Functions
A pure virtual function basically defines, that the derived classes will have that function defined on their own.

Every derived class inheriting from a class with a pure virtual function must override that function. 

If the pure virtual function is not overridden in the derived class, the code fails to compile and results in an error when you try to instantiate an object of the derived class.
===================================================================
Pure Virtual Functions
The pure virtual function in the Enemy class must be overridden in its derived classes.
#include <iostream>
using namespace std;

class Enemy {
 public:
  virtual void attack() = 0;
};

class Ninja: public Enemy {
 public:
  void attack() {
   cout << "Ninja!"<<endl;
  }
};

class Monster: public Enemy {
 public:
  void attack() {
   cout << "Monster!"<<endl;
  }
};

int main() {
    Ninja n;
    Monster m;
    Enemy *e1 = &n;
    Enemy *e2 = &m;

    e1->attack();
    e2->attack();
}
OUTPUT
Ninja!
Monster!
===================================================================
Abstract Classes
You cannot create objects of the base class with a pure virtual function.

Running the following code will return an error:
#include <iostream>
using namespace std;

class Enemy {
    public:
        virtual void attack() = 0;
};

class Ninja: public Enemy {
    public:
        void attack() {
            cout << "Ninja!"<<endl;
        }
};

class Monster: public Enemy {
    public:
        void attack() {
            cout << "Monster!"<<endl;
        }
};


int main()
{
    Enemy e;
    return 0;
}

These classes are called abstract. They are classes that can only be used as base classes, and thus are allowed to have pure virtual functions.

You might think that an abstract base class is useless, but it isn't. It can be used to create pointers and take advantage of all its polymorphic abilities.

For example, you could write:
#include <iostream>
using namespace std;

class Enemy {
    public:
        virtual void attack() = 0;
};

class Ninja: public Enemy {
    public:
        void attack() {
            cout << "Ninja!"<<endl;
        }
};

class Monster: public Enemy {
    public:
        void attack() {
            cout << "Monster!"<<endl;
        }
};


int main()
{
    Ninja n;
    Monster m;
    Enemy *e1 = &n;
    Enemy *e2 = &m;

    e1->attack();
    e2->attack();

    return 0;
}

In this example, objects of different but related types are referred to using a unique type of pointer (Enemy*), and the proper member function is called every time, just because they are virtual.
===================================================================
++=====================++
++=====================++ Function Templates
Function Templates
Functions and classes help to make programs easier to write, safer, and more maintainable. 

However, while functions and classes do have all of those advantages, in certain cases they can also be somewhat limited by C++'s requirement that you specify types for all of your parameters.

For example, you might want to write a function that calculates the sum of two numbers, similar to this:

int sum(int a, int b) {
  return a+b;
}
C++
You can use templates to define functions as well as classes. Let's see how they work.
===================================================================
Function Templates
We can now call the function for two integers in our main.
#include <iostream>
using namespace std;

int sum(int a, int b) {
    return a+b;
}

int main () {
    int x=7, y=15;
    cout << sum(x, y) << endl;
}
OUTPUT
22

The function works as expected, but is limited solely to integers.
===================================================================
Function Templates
It becomes necessary to write a new function for each new type, such as doubles.

double sum(double a, double b) {
  return a+b;
}
C++
Wouldn't it be much more efficient to be able to write one version of sum() to work with parameters of any type?

Function templates give us the ability to do that!

With function templates, the basic idea is to avoid the necessity of specifying an exact type for each variable. Instead, C++ provides us with the capability of defining functions using placeholder types, called template type parameters.

To define a function template, use the keyword template, followed by the template type definition:

template <class T>
C++
We named our template type T, which is a generic data type.
===================================================================
Function Templates
Now we can use our generic data type T in the function: 
#include <iostream>
using namespace std;

template <class T>
T sum(T a, T b) {
    return a+b;
}

int main () {
    int x=7, y=15;
    cout << sum(x, y) << endl;
}
OUTPUT
22

The function returns a value of the generic type T, taking two parameters, also of type T.

Our new function worked exactly as the previous one for integer values did.
===================================================================
Function Templates
The same function can be used with other data types, for example doubles: 
#include <iostream>
using namespace std;

template <class T>
T sum(T a, T b) {
    return a+b;
}

int main () {
    double x=7.15, y=15.54;
    cout << sum(x, y) << endl;
}
OUTPUT
22.69

The compiler automatically calls the function for the corresponding type.

When creating a template type parameter, the keyword typename may be used as an alternative to the keyword class: template <typename T>.

In this context, the keywords are identical, but throughout this course, we'll use the keyword class.
===================================================================
Function Templates
Template functions can save a lot of time, because they are written only once, and work with different types. 

Template functions reduce code maintenance, because duplicate code is reduced significantly. 

Enhanced safety is another advantage in using template functions, since it's not necessary to manually copy functions and change types.
===================================================================
++=====================++
++=====================++ Function Templates with Multiple Parameters
Function Templates
Function templates also make it possible to work with multiple generic data types. Define the data types using a comma-separated list.

Let's create a function that compares arguments of varying data types (an int and a double), and prints the smaller one.

template <class T, class U>
C++
As you can see, this template declares two different generic data types, T and U.
===================================================================
Function Templates
Now we can continue with our function declaration: 

template <class T, class U>
T smaller(T a, U b) {
  return (a < b ? a : b);
}
C++
The ternary operator checks the a<b condition and returns the corresponding result. The expression (a < b ? a : b) is equivalent to the expression if a is smaller than b, return a, else, return b.
===================================================================
Function Templates
In our main, we can use the function for different data types:
#include <iostream>
using namespace std;

template <class T, class U>
T smaller(T a, U b) {
    return (a < b ? a : b);
}

int main () {
    int x=72;
    double y=15.34;
    cout << smaller(x, y) << endl;
}
OUTPUT
15

The output converts to an integer, because we specified the function template's return type to be of the same type as the first parameter (T), which is an integer.
===================================================================
Function Templates
T is short for Type, and is a widely used name for type parameters. 

It's not necessary to use T, however, you can declare your type parameters using any identifiers that work for you. The only terms you need to avoid are C++ keywords.

Remember that when you declare a template parameter, you absolutely must use it in your function definition. Otherwise, the compiler will complain!
===================================================================
++=====================++
++=====================++ Class Templates
Class Templates
Just as we can define function templates, we can also define class templates, allowing classes to have members that use template parameters as types.

The same syntax is used to define the class template: 

template <class T>
class MyClass {

};
C++
Just as with function templates, you can define more than one generic data type by using a comma-separated list.
===================================================================
Class Templates
As an example, let's create a class Pair, that will be holding a pair of values of a generic type. 

template <class T>
class Pair {
 private:
  T first, second;
 public:
  Pair (T a, T b):
   first(a), second(b) {
  }
};
C++
The code above declares a class template Pair, with two private variables of a generic type, and one constructor to initialize the variables.
===================================================================
Class Templates
A specific syntax is required in case you define your member functions outside of your class - for example in a separate source file.

You need to specify the generic type in angle brackets after the class name. 

For example, to have a member function bigger() defined outside of the class, the following syntax is used: 

template <class T>
class Pair {
 private:
  T first, second;
 public:
  Pair (T a, T b):
   first(a), second(b){
  }
  T bigger();
};

template <class T>
T Pair<T>::bigger() {
  // some code
}
C++
A specific syntax is required in case you define your member functions outside of your class.
===================================================================
Class Templates
The bigger function returns the greater value of the two member variables.

template <class T>
class Pair {
 private:
  T first, second;
 public:
  Pair (T a, T b):
   first(a), second(b){
  }
  T bigger();
};

template <class T>
T Pair<T>::bigger() {
  return (first>second ? first : second);
}
C++
The ternary operator compares the two variables, returning the greater one.
===================================================================
Class Templates
To create objects of the template class for different types, specify the data type in angle brackets, as we did when defining the function outside of the class.

Here, we create a Pair object for integers.
#include <iostream>
using namespace std;

template <class T>
class Pair {
    private:
        T first, second;
    public:
        Pair (T a, T b):
        first(a), second(b) { }
        T bigger();
};

template <class T>
T Pair<T>::bigger() {
    return (first>second ? first : second);
}

int main()
{
    Pair <int> obj(11, 22);
    cout << obj.bigger();

    return 0;
}
OUTPUT
22
===================================================================
++=====================++
++=====================++ Template Specialization
Template Specialization
In case of regular class templates, the way the class handles different data types is the same; the same code runs for all data types.

Template specialization allows for the definition of a different implementation of a template when a specific type is passed as a template argument.

For example, we might need to handle the character data type in a different manner than we do numeric data types.

To demonstrate how this works, we can first create a regular template.

template <class T>
class MyClass {
 public:
  MyClass (T x) {
   cout <<x<<" -  not a char"<<endl;
  }
};
C++
As a regular class template, MyClass treats all of the various data types in the same way.
===================================================================
Template Specialization
To specify different behavior for the data type char, we would create a template specialization.

template <class T>
class MyClass {
 public:
  MyClass (T x) {
   cout <<x<<" -  not a char"<<endl;
  }
};

template < >
class MyClass<char> {
 public:
  MyClass (char x) {
   cout <<x<<" is a char!"<<endl;
  }
};
C++
First of all, notice that we precede the class name with template<>, including an empty parameter list. This is because all types are known and no template arguments are required for this specialization, but still, it is the specialization of a class template, and thus it requires to be noted as such.

But more important than this prefix, is the <char> specialization parameter after the class template name. This specialization parameter itself identifies the type for which the template class is being specialized (char).

In the example above, the first class is the generic template, while the second is the specialization.

If necessary, your specialization can indicate a completely different behavior from the behavior of the generic template.
===================================================================
Template Specialization
The next step is to declare objects of different types and check the result:
#include <iostream>
using namespace std;

template <class T>
class MyClass {
    public:
        MyClass (T x) {
            cout <<x<<" -  not a char"<<endl;
        }
};

template < >
class MyClass<char> {
    public:
        MyClass (char x) {
            cout <<x<<" is a char!"<<endl;
        }
};

int main () {
    MyClass<int> ob1(42);
    MyClass<double> ob2(5.47);
    MyClass<char> ob3('s');
}
OUTPUT
42 -  not a char
5.47 -  not a char
s is a char!

As you can see, the generic template worked for int and double. However, our template specialization was invoked for the char data type.

Keep in mind that there is no member "inheritance" from the generic template to the specialization, so all members of the template class specializations must be defined on their own.
===================================================================
++=====================++
++=====================++ Exceptions
Exceptions
Problems that occur during program execution are called exceptions.

In C++ exceptions are responses to anomalies that arise while the program is running, such as an attempt to divide by zero.

Tap Continue to learn about C++ mechanisms for handling exceptions.
===================================================================
Throwing Exceptions
C++ exception handling is built upon three keywords: try, catch, and throw.

throw is used to throw an exception when a problem shows up.

For example:

int motherAge = 29;
int sonAge = 36;
if (sonAge > motherAge) {
  throw "Wrong age values";
}
C++
The code looks at sonAge and motherAge, and throws an exception if sonAge is found to be the greater of the two.

In the throw statement, the operand determines a type for the exception. This can be any expression. The type of the expression's result will determine the type of the exception thrown.
===================================================================
Catching Exceptions
A try block identifies a block of code that will activate specific exceptions. It's followed by one or more catch blocks. The catch keyword represents a block of code that executes when a particular exception is thrown. 

Code that could generate an exception is surrounded with the try/catch block.

You can specify what type of exception you want to catch  by the exception declaration that appears in parentheses following the keyword catch.

For example:
#include <iostream>
using namespace std;

int main()
{
    try {
        int motherAge = 29;
        int sonAge = 36;
        if (sonAge > motherAge) {
            throw 99;
        }
    }
    catch (int x) {
        cout<<"Wrong age values - Error "<<x;
    }

    return 0;
}
OUTPUT
Wrong age values - Error 99


The try block throws the exception, and the catch block then handles it.

The error code 99, which is an integer, appears in the throw statement, so it results in an exception of type int.

Multiple catch statements may be listed to handle various exceptions in case multiple exceptions are thrown by the try block.
===================================================================
++=====================++
++=====================++ More on Exceptions
Exception Handling
Exception handling is particularly useful when dealing with user input.

For example, for a program that requests user input of two numbers, and then outputs their division, be sure that you handle division by zero, in case your user enters 0 as the second number.
#include <iostream>
using namespace std;

int main() {
    int num1;
    cout <<"Enter the first number:";
    cin >> num1;
    
    int num2;
    cout <<"Enter the second number:";
    cin >> num2;
    
    cout <<"Result:"<<num1 / num2;
}
This program works perfectly if the user enters any number besides 0.

In case of 0 the program crashes, so we need to handle that input.
===================================================================
Exception Handling
In the event that the second number is equal to 0, we need to throw an exception.
#include <iostream>
using namespace std;

int main() {
    int num1;
    cout <<"Enter the first number:";
    cin >> num1;
    
    int num2;
    cout <<"Enter the second number:";
    cin >> num2;
    
    if(num2 == 0) {
        throw 0;
    }
    
    cout <<"Result:"<<num1 / num2;  
}

This code throws an exception with the code 0 of type integer.

Next stop: Using the try/catch block to handle the exception!
===================================================================
Exception Handling
Now we need to handle the thrown exception using a try/catch block.
#include <iostream>
using namespace std;

int main() {
    try {
        int num1;
        cout <<"Enter the first number:";
        cin >> num1;
        
        int num2;
        cout <<"Enter the second number:";
        cin >> num2;
        
        if(num2 == 0) {
            throw 0;
        }
        
        cout <<"Result:"<<num1 / num2; 
    }
    catch(int x) {
        cout <<"Division by zero!";
    }
}

This results in the output of "Division by zero!" as an alternative to a program crash, when 0 is entered as the second number.

In our case, we catch exceptions of type integer only. It's possible to specify that your catch block handles any type of exception thrown in a try block. To accomplish this, add an ellipsis (...) between the parentheses of catch:

try {
  // code
} catch(...) {
  // code to handle exceptions
}
C++
===================================================================
++=====================++
++=====================++ Working with Files
Working with Files
Another useful C++ feature is the ability to read and write to files. That requires the standard C++ library called fstream.

Three new data types are defined in fstream:

ofstream: Output file stream that creates and writes information to files.

ifstream: Input file stream that reads information from files.

fstream: General file stream, with both ofstream and ifstream capabilities that allow it to create, read, and write information to files.

To perform file processing in C++, header files <iostream> and <fstream> must be included in the C++ source file.

#include <iostream>
#include <fstream>
C++
These classes are derived directly or indirectly from the classes istream and ostream. We have already used objects whose types were these classes: cin is an object of class istream and cout is an object of class ostream.
===================================================================
Opening a File
A file must be opened before you can read from it or write to it. 

Either the ofstream or fstream object may be used to open a file for writing.

Let's open a file called "test.txt" and write some content to it: 

#include <iostream>
#include <fstream>
using namespace std;

int main() {
  ofstream MyFile;
  MyFile.open("test.txt");

  MyFile << "Some text. \n";
}
C++
The above code creates an ofstream object called MyFile, and uses the open() function to open the "test.txt" file on the file system. As you can see, the same stream output operator is used to write into the file.

If the specified file does not exist, the open function will create it automatically.
===================================================================
Closing a File
When you've finished working with a file, close it using the member function close().

#include <iostream>
#include <fstream>
using namespace std;

int main() {
  ofstream MyFile;
  MyFile.open("test.txt");

  MyFile << "Some text! \n";
  MyFile.close();
}
C++
Running this code will cause a "test.txt" file to be created in the directory of your project with "Some text!" written in it.

You also have the option of specifying a path for your file in the open function, since it can be in a location other than that of your project.
===================================================================
++=====================++
++=====================++ More on Files
Working with Files
You can also provide the path to your file using the ofstream object's constructor, instead of calling the open function.

#include <fstream>
using namespace std;

int main() {
  ofstream MyFile("test.txt");

  MyFile << "This is awesome! \n";
  MyFile.close();
}
C++
As with the open function, you can provide a full path to your file located in a different directory.
===================================================================
Working with Files
Under certain circumstances, such as when you don't have file permissions, the open function can fail. 

The is_open() member function checks whether the file is open and ready to be accessed.

#include <iostream>
#include <fstream>
using namespace std;

int main() {
  ofstream MyFile("test.txt");

  if (MyFile.is_open()) {
   MyFile << "This is awesome! \n";
  }
  else {
   cout << "Something went wrong";
  }
  MyFile.close();
}
C++
The is_open() member function checks whether the file is open and ready to be accessed.
===================================================================
File Opening Modes
An optional second parameter of the open function defines the mode in which the file is opened. This list shows the supported modes.

img-component
All these flags can be combined using the bitwise operator OR (|).

For example, to open a file in write mode and truncate it, in case it already exists, use the following syntax:

ofstream outfile;
outfile.open("file.dat", ios::out | ios::trunc );
C++
Reading from a File 

You can read information from a file using an ifstream or fstream object.
#include <iostream>
#include <fstream>
using namespace std;

int main () {
    ofstream MyFile1("test.txt");
    
    MyFile1 << "This is awesome! \n";
    MyFile1.close();

    string line;
    ifstream MyFile("test.txt");
    while ( getline (MyFile, line) ) {
        cout << line << '\n';
    }
    MyFile.close();
}
OUTPUT
This is awesome! 

The getline function reads characters from an input stream and places them into a string.

The example above reads a text file and prints the contents to the screen.

Our while loop uses the getline function to read the file line by line.
===================================================================

######################################################################################
######################################################################################
##	endroughxfer-urldump #1#
##	<EOF><EOF> Introduction to C++ (SoloLearn) Volume 2
######################################################################################
######################################################################################

Basic Concepts
Welcome to C++
Headers and namespaces
New Lines
Comments
Variables
Working with Variables
More on Variables
Basic Arithmetic
Assignment and Increment Operators
Module 1 Quiz
Code Project
Transportation
Conditionals and Loops
The if Statement
The else Statement
The while Loop
Using a while Loop
The for Loop
The do... while Loop
The switch Statement
Logical Operators
Module 2 Quiz
Code Project
Countdown
Data Types, Arrays, Pointers
Introduction to Data Types
int, float, double
string, char, bool
Variable Naming Rules
Arrays
Using Arrays in Loops
Arrays in Calculations
Multi-Dimensional Arrays
Introduction to Pointers
More on Pointers
Dynamic Memory
The sizeof() Operator
Module 3 Quiz
Code Project
Ticket Office
Functions
Introduction to Functions
Function Parameters
Functions with Multiple Parameters
The rand() Function
Default Arguments
Function Overloading
Recursion
Passing Arrays to Functions
Pass by Reference with Pointers
Module 4 Quiz
Code Project
Palindrome Numbers
Classes and Objects
What is an Object
What is a Class
Example of a Class
Abstraction
Encapsulation
Example of Encapsulation
Constructors
Module 5 Quiz
Code Project
Queue Management Part 1
More On Classes
Separate Files for Classes
Destructors
Selection Operator
Const Objects
Member Initializers
Composition, Part 1
Composition, Part 2
The Friend Keyword
The This Keyword
Operator Overloading
Module 6 Quiz
Code Project
Queue Management Part 2
Inheritance & Polymorphism
Inheritance
Protected Members
Derived Class Constructor & Destructor
Polymorphism
Virtual Functions
Abstract Classes
Module 7 Quiz
Code Project
Queue Management Part 3
Templates, Exceptions, and Files
Function Templates
Function Templates with Multiple Parameters
Class Templates
Template Specialization
Exceptions
More on Exceptions
Working with Files
More on Files
Module 8 Quiz
Code Project
Queue Management Part 4

===================================================================
++=====================++
++=====================++ Basic Concepts:: Welcome to C++
Welcome to C++
C++ is a popular cross-platform language that can be used to create high-performance applications - operating systems, browsers, video-games, art applications and so on.

C++ was derived from C, and is largely based on it.
===================================================================
Welcome to C++
A C++ program is a collection of commands or statements.

Below is a simple program template.

#include <iostream>
using namespace std;

int main()
{

  return 0;
}
You will learn what each of the statements does in the upcoming lessons.
For now, remember that the entry point of every C++ program is the main() function, irrespective of what the program does.

Curly brackets { } indicate the beginning and end of a function, which can also be called the function's body. The information inside the brackets indicates what the function does when executed.
===================================================================
Your First C++ Program
Let's output "Hello world!" to the screen!
To do that, we will add cout << "Hello world!"; line to our main() function body:
#include <iostream>
using namespace std;

int main()
{
  cout << "Hello world!";
  cout << " This " << "is " << "awesome!";
  return 0;
}
OUTPUT
Hello world! This is awesome!

cout is used to perform output on the standard output device which is usually the display screen.
cout is used in combination with the insertion operator <<.
Note that you can add multiple insertion operators after cout.

In C++, the semicolon is used to terminate a statement. Each statement must end with a semicolon. It indicates the end of one logical expression.
===================================================================
++=====================++
++=====================++ Headers and Namespaces
Headers
C++ offers various headers, each of which contains information needed for programs to work properly.
We have already seen the standard <iostream> header on our first C++ program:

#include <iostream>
using namespace std;

int main()
{
cout << "Hello world!";
return 0;
}
#include is used for adding a standard or user-defined header files to the program.

The <iostream> header defines the standard stream objects that input and output data.
===================================================================
Namespaces
A namespace is a declarative region that provides a scope to the identifiers (names of elements) inside it.
In our code, the line using namespace std; tells the compiler to use the std (standard) namespace:

#include <iostream>
using namespace std;

int main()
{
cout << "Hello world!";
return 0;
}
The std namespace includes features of the C++ Standard Library.
===================================================================
++=====================++
++=====================++ New Lines
New Line
The cout object does not insert a line break at the end of the output.
One way to print two lines is to use the endl manipulator, which will put in a line break.

#include <iostream>
using namespace std;

int main()
{
    cout << "Hello world!" << endl;
    cout << "I love programming!";
    return 0;
}
OUTPUT
Hello world!
I love programming!
===================================================================
New Lines
The new line character \n can be used as an alternative to endl.
Using a single cout statement with as many instances of \n as your program requires will print out multiple lines of text.

Example:
#include <iostream>
using namespace std;

int main()
{
    cout << "Hello world! \n";
    cout << "I love programming!";
    return 0;
}
OUTPUT
Hello world! 
I love programming!

The backslash (\) is called an escape character, and indicates a "special" character.
===================================================================
++=====================++
++=====================++ Comments
Comments
Comments are explanatory statements that you can include in the C++ code to explain what the code is doing.
The compiler ignores everything that appears in the comment, so none of that information shows in the result.

A comment beginning with two slashes (//) is called a single-line comment. The slashes tell the compiler to ignore everything that follows, until the end of the line.

For example:
#include <iostream>
using namespace std;

int main()
{
    // prints "Hello world"
    cout << "Hello world!";
    return 0;
}
OUTPUT
Hello world!

When the above code is compiled, it will ignore the // prints "Hello world" statement.

Adding comments to your code is a good practice. It facilitates a clear understanding of the code for you and for others who read it.
===================================================================
++=====================++
++=====================++ Comments
Multi-Line Comments
Comments that require multiple lines begin with /* and end with */
You can place them on the same line or insert one or more lines between them.
#include <iostream>
using namespace std;

int main()
{
    /*We are going to
    print "Hello world!" */

    cout << "Hello world!"; // prints Hello world!

    return 0;
}
OUTPUT
Hello world!

Comments can be written anywhere, and can be repeated any number of times throughout the code.
===================================================================
++=====================++
++=====================++ Variables
Variables
Creating a variable reserves a memory location, or a space in memory for storing values. The compiler requires that you provide a data type for each variable you declare.
C++ offer a rich assortment of built-in as well as user defined data types.

Integer, a built-in type, represents a whole number value. Define integer using the keyword int.
C++ requires that you specify the type and the identifier for each variable defined.
An identifier is a name for a variable, function, class, module, or any other user-defined item. An identifier starts with a letter (A-Z or a-z) or an underscore (_), followed by additional letters, underscores, and digits (0 to 9).
For example, define a variable called myVariable that can hold integer values as follows:

int myVariable = 10;
Different operating systems can reserve different sizes of memory for the same data type.
===================================================================
Variables
Now, let's assign a value to the variable and print it.
#include <iostream>
using namespace std;

int main()
{
    int myVariable = 10;
    cout << myVariable;
    return 0;
}
OUTPUT
10

The C++ programming language is case-sensitive, so myVariable and myvariable are two different identifiers.
===================================================================
Variables
Define all variables with a name and a data type before using them in a program. In cases in which you have multiple variables of the same type, it's possible to define them in one declaration, separating them with commas.

int a, b;
// defines two variables of type int
A variable can be assigned a value, and can be used to perform operations.
For example, we can create an additional variable called sum, and add two variables together.

int a = 30; 
int b = 15; 
int sum = a + b;
// Now sum equals 45
Use the + operator to add two numbers.
===================================================================
Variables
Let's create a program to calculate and print the sum of two integers.
#include <iostream>
using namespace std;

int main()
{
    int a = 30;
    int b = 12;
    int sum = a + b;

    cout << sum;

     return 0;
}
OUTPUT
42

Always keep in mind that all variables must be defined with a name and a data type before they can be used.
===================================================================
++=====================++
++=====================++ Working with Variables
Declaring Variables
You have the option to assign a value to the variable at the time you declare the variable or to declare it and assign a value later.
You can also change the value of a variable.

Some examples:
int a; 
int b = 42;

a = 10;
b = 3;
You can assign a value to a variable only in a declared data type.
===================================================================
User Input
To enable the user to input a value, use cin in combination with the extraction operator (>>). The variable containing the extracted data follows the operator.
The following example shows how to accept user input and store it in the num variable:

int num;
cin >> num;
As with cout, extractions on cin can be chained to request more than one input in a single statement: cin >> a >> b;
===================================================================
Accepting User Input
The following program prompts the user to input a number and stores it in the variable a:
#include <iostream>
using namespace std;

int main()
{
    int a;
    cout << "Please enter a number \n";
    cin >> a;

    cout << a;

    return 0;
}

When the program runs, it displays the message "Please enter a number", and then waits for the user to enter a number and press Enter, or Return.
The entered number is stored in the variable a.

The program will wait for as long as the user needs to type in a number.
===================================================================
Accepting User Input
You can accept user input multiple times throughout the program:
#include <iostream>
using namespace std;

int main()
{
    int a, b;
    cout << "Enter a number \n";
    cin >> a;
    cout << "Enter another number \n";
    cin >> b;

    cout << a << " "<< b;

    return 0;
}
===================================================================
Accepting User Input
Let's create a program that accepts the input of two numbers and prints their sum.
#include <iostream>
using namespace std;

int main() 
{
    int a, b;
    int sum;
    cout << "Enter a number \n";
    cin >> a;
    cout << "Enter another number \n";
    cin >> b;
    sum = a + b;
    cout << "Sum is: " << sum << endl;

  return 0;
}
===================================================================
++=====================++
++=====================++ More on Variables
Variables
Specifying the data type is required just once, at the time when the variable is declared.
After that, the variable may be used without referring to the data type.

int a;
a = 10;
Specifying the data type for a given variable more than once results in a syntax error.
===================================================================
Variables
A variable's value may be changed as many times as necessary throughout the program.

For example:
#include <iostream>
using namespace std;

int main()
{
    int a = 100;
    a = 50;
    cout << a;
    return 0;
}
OUTPUT
50
===================================================================
auto Keyword
The auto keyword allows you to automatically deduct the type of the variable being declared. It infers the data type of the variable from its value.

For example:
auto x = 4; //integer
    auto y = 3.37; //float
    auto z = "hello"; //string
Any variable declared with the auto keyword should be initialized at the time of its declaration or there will be an error.
===================================================================
++=====================++
++=====================++ Basic Arithmetic
Arithmetic Operators
C++ supports these arithmetic operators.

img-component
The addition operator adds its operands together.
#include <iostream>
using namespace std;

int main()
{
    int x = 40 + 60;
    cout << x;
    return 0;
}
OUTPUT
100

You can use multiple arithmetic operators in one line.
===================================================================
Subtraction
The subtraction operator subtracts one operand from the other.
#include <iostream>
using namespace std;

int main()
{
    int x = 100 - 60;
    cout << x;
    return 0;
}
OUTPUT
40
===================================================================
Multiplication
The multiplication operator multiplies its operands.
#include <iostream>
using namespace std;

int main()
{
    int x = 5 * 6;
    cout << x;
    return 0;
}
OUTPUT
30
===================================================================
Division
The division operator divides the first operand by the second. Any remainder is dropped in order to return an integer value.

Example:
#include <iostream>
using namespace std;

int main()
{
    int x = 10 / 3;
    cout << x;
    return 0;
}
OUTPUT
3

If one or both of the operands are floating point values, the division operator performs floating point division.

Dividing by 0 will crash your program.
===================================================================
Modulus
The modulus operator (%) is informally known as the remainder operator because it returns the remainder after an integer division.

For example:
#include <iostream>
using namespace std;

int main()
{
    int x = 25 % 7;
    cout << x;
    return 0;
}
OUTPUT
4
===================================================================
Operator Precedence
Operator precedence determines the grouping of terms in an expression, which affects how an expression is evaluated. Certain operators take higher precedence over others; for example, the multiplication operator has higher precedence over the addition operator.

For example:
#include <iostream>
using namespace std;

int main()
{
    int x = 5+2*2;
    cout << x;
    return 0;
}
OUTPUT
9

The program above evaluates 2*2 first, and then adds the result to 5.

As in mathematics, using parentheses alters operator precedence.
#include <iostream>
using namespace std;

int main()
{
    int x = (5 + 2) *2;
    cout << x;
    return 0;
}
OUTPUT
9
===================================================================
Operator Precedence
Parentheses force the operations to have higher precedence. If there are parenthetical expressions nested within one another, the expression within the innermost parentheses is evaluated first.

If none of the expressions are in parentheses, multiplicative (multiplication, division, modulus) operators will be evaluated before additive (addition, subtraction) operators.
===================================================================
++=====================++
++=====================++ Assignment and Increment Operators
Assignment Operators
The simple assignment operator (=) assigns the right side to the left side.

C++ provides shorthand operators that have the capability of performing an operation and an assignment at the same time.

For example:
int x = 10;
x += 4; // equivalent to x = x + 4
x -= 5; // equivalent to x = x - 5
Assignment operator (=) assigns the right side to the left side.
===================================================================
Assignment Operators
The same shorthand syntax applies to the multiplication, division, and modulus operators.

x *= 3; // equivalent to x = x * 3
x /= 2; // equivalent to x = x / 2
x %= 4; // equivalent to x = x % 4
The same shorthand syntax applies to the multiplication, division, and modulus operators.
===================================================================
Increment Operator
The increment operator is used to increase an integer's value by one, and is a commonly used C++ operator.

x++; //equivalent to x = x + 1
The increment operator is used to increase an integer's value by one.
===================================================================
Increment Operator
For example:
#include <iostream>
using namespace std;

int main()
{
    int x = 11;
    x++;
    cout << x;
    return 0;
}
OUTPUT
12

Increment Operator
The increment operator has two forms, prefix and postfix.

++x; // prefix
x++; // postfix
Prefix increments the value, and then proceeds with the expression.
Postfix evaluates the expression and then performs the incrementing.

Prefix example:
x = 5;
y = ++x;
// x is 6, y is 6
Postfix example:
x = 5;
y = x++;
// x is 6, y is 5
The prefix example increments the value of x, and then assigns it to y.
The postfix example assigns the value of x to y, and then increments it.
===================================================================
Decrement Operator
The decrement operator (--) works in much the same way as the increment operator, but instead of increasing the value, it decreases it by one.

--x; // prefix
x--; // postfix
The decrement operator (--) works in much the same way as the increment operator.
===================================================================
++=====================++
++=====================++ Conditions and Loops: The if Statement
Decision Making
The if statement is used to execute some code if a condition is true.

Syntax:
if (condition) {
   statements
}
The condition specifies which expression is to be evaluated. If the condition is true, the statements in the curly brackets are executed.

If the condition is false, the statements are simply ignored, and the program continues to run after the if statements body.
===================================================================
The if Statement
Use relational operators to evaluate conditions.

For example:
#include <iostream>
using namespace std;

int main()
{
    if (7 > 4) {
        cout <<  "Yes"; 
    }

    return 0;
}
OUTPUT
Yes

The if statement evaluates the condition (7>4), finds it to be true, and then executes the cout statement.
If we change the greater operator to a less than operator (7<4), the statement will not be executed and nothing will be printed out.

A condition specified in an if statement does not require a semicolon.
===================================================================
Relational Operators
Additional relational operators:

img-component
Example:
#include <iostream>
using namespace std;

int main()
{
    if (10 == 10) {
        cout <<  "Yes";
    }

    return 0;
}
OUTPUT
Yes
===================================================================
Relational Operators
The not equal to operator evaluates the operands, determines whether or not they are equal. If the operands are not equal, the condition is evaluated to true.

For example:
#include <iostream>
using namespace std;

int main()
{
    if (10 != 10) {
        cout <<  "Yes";
    }

    return 0;
}
OUTPUT
No output.

The above condition evaluates to false and the block of code is not executed.
===================================================================
Relational Operators
You can use relational operators to compare variables in the if statement.

For example:
#include <iostream>
using namespace std;

int main()
{
    int a = 55;
    int b = 33;
    if (a > b) {
        cout << "a is greater than b";
    }

    return 0;
}
OUTPUT
a is greater than b
===================================================================
++=====================++
++=====================++ The else Statement
The else Statement
An if statement can be followed by an optional else statement, which executes when the condition is false.

Syntax:
if (condition) {
  //statements
}
else {
 //statements
}
The code above will test the condition:
- If it evaluates to true, then the code inside the if statement will be executed.
- If it evaluates to false, then the code inside the else statement will be executed.

When only one statement is used inside the if/else, then the curly braces can be omitted.
===================================================================
The else Statement
For example:
#include <iostream>
using namespace std;

int main()
{
    int mark = 90;

    if (mark < 50) {
        cout << "You failed." << endl;
    }
    else {
        cout << "You passed." << endl;
    }

    return 0;
}
OUTPUT
You passed.
===================================================================
The else Statement
In all previous examples only one statement was used inside the if/else statement, but you may include as many statements as you want.

For example:
#include <iostream>
using namespace std;

int main()
{
    int mark = 90;

    if (mark < 50) {
        cout << "You failed." << endl;
        cout << "Sorry" << endl;
    }
    else {
        cout << "Congratulations!" << endl;
        cout << "You passed." << endl;
        cout << "You are awesome!" << endl;
    }

    return 0;
}
OUTPUT
Congratulations!
You passed.
You are awesome!
===================================================================
Nested if Statements
You can also include, or nest, if statements within another if statement.

For example:
#include <iostream>
using namespace std;

int main()
{
    int mark = 100;

    if (mark >= 50) {
        cout << "You passed." << endl;
        if (mark == 100) {
            cout <<"Perfect!" << endl;
        }
    }
    else {
        cout << "You failed." << endl;
    }

    return 0;
}
OUTPUT
You passed.
Perfect!
===================================================================
Nested if else Statements
C++ provides the option of nesting an unlimited number of if/else statements.

For example:
#include <iostream>
using namespace std;

int main()
{
    int age = 18;
    if (age > 14) {
        if(age >= 18) {
            cout << "Adult";
        }
        else {
            cout << "Teenager";
        }
    }
    else {
        if (age > 0) {
            cout << "Child";
        }
        else {
            cout << "Something's wrong";
        }
    }

    return 0;
}
OUTPUT
Adult

Remember that all else statements must have corresponding if statements.
===================================================================
The if else Statement
In if/else statements, a single statement can be included without enclosing it into curly braces.
#include <iostream>
using namespace std;

int main()
{
    int a = 10;
    if (a > 4)
        cout << "Yes";
    else
        cout << "No";

    return 0;
}
OUTPUT
Yes

Including the curly braces anyway is a good practice, as they clarify the code and make it easier to read.
===================================================================
++=====================++
++=====================++ The while Loop
Loops
A loop repeatedly executes a set of statements until a particular condition is satisfied.

A while loop statement repeatedly executes a target statement as long as a given condition remains true.

Syntax:
while (condition) {
   statement(s);
}
The loop iterates while the condition is true.

At the point when the condition becomes false, program control is shifted to the line that immediately follows the loop.
===================================================================
The while Loop
The loop's body is the block of statements within curly braces.

For example:
#include <iostream>
using namespace std;

int main()
{
    int num = 1;
    while (num < 6) {
        cout << "Number: " << num << endl;
        num = num + 1;
    }

    return 0;
}
OUTPUT
Number: 1
Number: 2
Number: 3
Number: 4
Number: 5

The example above declares a variable equal to 1 (int num = 1).
The while loop checks the condition (num < 6), and executes the statements in its body, which increment the value of num by one each time the loop runs.

After the 5th iteration, num becomes 6, and the condition is evaluated to false, and the loop stops running.
===================================================================
The while Loop
The increment value can be changed. If changed, the number of times the loop is run will change, as well.
#include <iostream>
using namespace std;

int main()
{
    int num = 1;
    while (num < 6) {
        cout << "Number: " << num << endl;
        num = num + 3;
    }

    return 0;
}
OUTPUT
Number: 1
Number: 4

Without a statement that eventually evaluates the loop condition to false, the loop will continue indefinitely.
===================================================================
++=====================++
++=====================++ Using a while Loop
Using Increment or Decrement
The increment or decrement operators can be used to change values in the loop.

For example:
#include <iostream>
using namespace std;

int main()
{
    int num = 1;
    while (num < 6) {
        cout << "Number: " << num << endl;
        num++;
    }
    
    return 0;
}
OUTPUT
Number: 1
Number: 2
Number: 3
Number: 4
Number: 5

num++ is equivalent to num = num + 1.
===================================================================
Using a while Loop
A loop can be used to obtain multiple inputs from the user.
Let's create a program that allows the user to enter a number 5 times, each time storing the input in a variable.

int num = 1;
int number;

while (num <= 5) {
  cin >> number;
  num++;
}
The above code asks for user input 5 times, and each time saves the input in the number variable.
===================================================================
Using a while Loop
Now let's modify our code to calculate the sum of the numbers the user has entered.
#include <iostream>
using namespace std;

int main()
{
    int num = 1;
    int number;
    int total = 0;

    while (num <= 5) {
        cin >> number;
        total += number;
        num++;
    }
    cout << total << endl;

    return 0;
}

The code above adds the number entered by the user to the total variable with each loop iteration.
Once the loop stops executing, the value of total is printed. This value is the sum of all of the numbers the user entered.

Note that the variable total has an initial value of 0.
===================================================================
++=====================++
++=====================++ The for Loop
The for loop
A for loop is a repetition control structure that allows you to efficiently write a loop that executes a specific number of times.

Syntax:
for ( init; condition; increment ) {
  statement(s);
}
The init step is executed first, and does not repeat.
Next, the condition is evaluated, and the body of the loop is executed if the condition is true.
In the next step, the increment statement updates the loop control variable.
Then, the loop's body repeats itself, only stopping when the condition becomes false.

For example:
for (int x = 1; x < 10; x++) {
 // some code
 }
The init and increment statements may be left out, if not needed, but remember that the semicolons are mandatory.
===================================================================
The for Loop
The example below uses a for loop to print numbers from 0 to 9.
#include <iostream>
using namespace std;

int main()
{
    for (int a = 0; a < 10; a++) {
        cout << a << endl;
    }

    return 0;
}
OUTPUT
0
1
2
3
4
5
6
7
8
9

In the init step, we declared a variable a and set it to equal 0.
a < 10 is the condition.
After each iteration, the a++ increment statement is executed.

When a increments to 10, the condition evaluates to false, and the loop stops.
===================================================================
The for Loop
It's possible to change the increment statement.
#include <iostream>
using namespace std;

int main()
{
    for (int a = 0; a < 50; a+=10) {
        cout << a << endl;
    }

    return 0;
}
OUTPUT
0
10
20
30
40

You can also use decrement in the statement.
#include <iostream>
using namespace std;

int main()
{
    for (int a = 10; a >= 0; a -= 3) {
        cout << a << endl;
    }

    return 0;
}
OUTPUT
0
10
20
30
40

When using the for loop, don't forget the semicolon after the init and condition statements.
===================================================================
++=====================++
++=====================++ The do... while Loop
The do...while Loop
Unlike for and while loops, which test the loop condition at the top of the loop, the do...while loop checks its condition at the bottom of the loop.
A do...while loop is similar to a while loop. The one difference is that the do...while loop is guaranteed to execute at least one time.

Syntax:
do {
   statement(s);
} while (condition);
For example, you can take input from the user, then check it. If the input is wrong, you can take it again.
===================================================================
The do...while Loop
Here is an example:
#include <iostream>
using namespace std;

int main()
{
    int a = 0;
    do {
        cout << a << endl;
        a++;
    } while(a < 5);

    return 0;
}
OUTPUT
0
1
2
3
4

Don't forget the semicolon after the while statement.
===================================================================
while vs. do...while
If the condition evaluated to false, the statements in the do would still run once:
#include <iostream>
using namespace std;

int main()
{
    int a = 42;
    do {
        cout << a << endl;
        a++;
    } while(a < 5);

    return 0;
}
OUTPUT
42

The do...while loop executes the statements at least once, and then tests the condition.
The while loop executes the statement after testing condition.
===================================================================
The do...while Loop
As with other loops, if the condition in the loop never evaluates to false, the loop will run forever.

For example:
#include <iostream>
using namespace std;

int main()
{
    int a = 42;
    do {
        cout << a << endl;
    } while (a > 0);

    return 0;
}

This will print 42 to the screen forever.

Always test your loops, so you know that they operate in the manner you expect.
===================================================================
++=====================++
++=====================++ The switch Statement
Multiple Conditions
Sometimes there is a need to test a variable for equality against multiple values. That can be achieved using multiple if statements.

For example:
#include <iostream>
using namespace std;

int main()
{
    int age = 42;
    if (age == 16) {
        cout <<"Too young";
    }
    if (age == 42) {
        cout << "Adult";
    }
    if (age == 70) {
        cout << "Senior";
    }

    return 0;
}
OUTPUT
Adult

The switch statement is a more elegant solution in this scenario.
===================================================================
The switch Statement
The switch statement tests a variable against a list of values, which are called cases, to determine whether it is equal to any of them.

switch (expression) {
  case value1:
    statement(s);
    break;
  case value2:
    statement(s);
    break;
    ...
  case valueN:
    statement(s);
    break;
}
Switch evaluates the expression to determine whether it's equal to the value in the case statement. If a match is found, it executes the statements in that case.

A switch can contain any number of case statements, which are followed by the value in question and a colon.
===================================================================
The switch Statement
Here is the previous example written using a single switch statement:
#include <iostream>
using namespace std;

int main()
{
    int age = 42;
    switch (age) {
        case 16:
            cout << "Too young";
            break;
        case 42:
            cout << "Adult";
            break;
        case 70:
            cout << "Senior";
            break;
    }

    return 0;
}
OUTPUT
Adult

The code above is equivalent to three if statements.

Notice the keyword break; that follows each case. That will be covered shortly.
===================================================================
The default Case
In a switch statement, the optional default case can be used to perform a task when none of the cases is determined to be true.

Example:
#include <iostream>
using namespace std;

int main()
{
    int age = 25;
    switch (age) {
        case 16:
            cout << "Too young";
            break;
        case 42:
            cout << "Adult";
            break;
        case 70:
            cout << "Senior";
            break;
        default:
            cout << "This is the default case";
    }

    return 0;
}
OUTPUT
This is the default case

The default statement's code executes when none of the cases matches the switch expression.

The default case must appear at the end of the switch.
===================================================================
The break Statement
The break statement's role is to terminate the switch statement.
In instances in which the variable is equal to a case, the statements that come after the case continue to execute until they encounter a break statement. In other words, leaving out a break statement results in the execution of all of the statements in the following cases, even those that don't match the expression.

For example:
#include <iostream>
using namespace std;

int main()
{
    int age = 42;
    switch (age) {
        case 16:
            cout << "Too young" << endl;
        case 42:
            cout << "Adult" << endl;
        case 70:
            cout << "Senior" << endl;
        default:
            cout <<"This is the default case" << endl;
    }

    return 0;
}
OUTPUT
Adult
Senior
This is the default case

As you can see, the program executed the matching case statement, printing "Adult" to the screen. With no specified break statement, the statements continued to run after the matching case. Thus, all the other case statements printed. This type of behavior is called fall-through.

As the switch statement's final case, the default case requires no break statement.
The break statement can also be used to break out of a loop.
===================================================================
++=====================++
++=====================++ Logical Operators
Logical Operators
Use logical operators to combine conditional statements and return true or false.

img-component
The AND operator works the following way:

img-component
In the AND operator, both operands must be true for the entire expression to be true.
===================================================================
The AND Operator
For example:
#include <iostream>
using namespace std;

int main()
{
    int age = 20;
    if (age > 16 && age < 60) {
        cout << "Accepted!" << endl;
    }

    return 0;
}
OUTPUT
Accepted!

In the example above, the logical AND operator was used to combine both expressions.

The expression in the if statement evaluates to true only if both expressions are true.
===================================================================
The AND Operator
Within a single if statement, logical operators can be used to combine multiple conditions.
#include <iostream>
using namespace std;

int main()
{
    int age = 20;
    int grade = 80;

    if (age > 16 && age < 60 && grade > 50) {
        cout << "Accepted!" << endl;
    }

    return 0;
}
OUTPUT
Accepted!

The entire expression evaluates to true only if all of the conditions are true.
===================================================================
The OR Operator
The OR (||) operator returns true if any one of its operands is true.

img-component
Example:
#include <iostream>
using namespace std;

int main()
{
    int age = 16;
    int score = 90;
    if (age > 20 || score > 50) {
        cout << "Accepted!" << endl;
    }

    return 0;
}
OUTPUT
Accepted!

You can combine any number of logical OR statements you want.
In addition, multiple OR and AND statements may be chained together.
===================================================================
Logical NOT
The logical NOT (!) operator works with just a single operand, reversing its logical state. Thus, if a condition is true, the NOT operator makes it false, and vice versa.

img-component
#include <iostream>
using namespace std;

int main()
{
    int age = 10;
    if ( !(age > 16) ) {
        cout << "Your age is less than 16" << endl;
    }

    return 0;
}
OUTPUT
Your age is less than 16
Be careful using this, because !false means true.
===================================================================
++=====================++
++=====================++ Data Types, Arrays, Pointers:: Introduction to Data Types
Data Types
The operating system allocates memory and selects what will be stored in the reserved memory based on the variable's data type.
The data type defines the proper use of an identifier, what kind of data can be stored, and which types of operations can be performed.

There are a number of built-in types in C++.
===================================================================
Expressions
The examples below show legal and illegal C++ expressions.

55+15 //  legal C++ expression
//Both operands of the + operator are integers

55 + "John" // illegal
// The + operator is not defined for integer and string
You can implement some logic for illegal expressions by overloading operators. You'll learn about it later.
===================================================================
Numeric Data Types
Numeric data types include:
Integers (whole numbers), such as -7, 42.
Floating point numbers, such as 3.14, -42.67.

We'll explain more about data types in the lessons to come.
===================================================================
Strings & Characters
A string is composed of numbers, characters, or symbols. String literals are placed in double quotation marks; some examples are "Hello", "My name is David", and similar.

Characters are single letters or symbols, and must be enclosed between single quotes, like 'a', 'b', etc.

In C++, single quotation marks indicate a character; double quotes create a string literal. While 'a' is a single a character literal, "a" is a string literal.
===================================================================
Booleans
The Boolean data type returns just two possible values: true (1) and false (0).

Conditional expressions are an example of Boolean data type.
===================================================================
++=====================++
++=====================++ int, float, double
Integers
The integer type holds non-fractional numbers, which can be positive or negative. Examples of integers would include 42, -42, and similar numbers.

The size of the integer type varies according to the architecture of the system on which the program runs, although 4 bytes is the minimum size in most modern system architectures.
===================================================================
Integers
Use the int keyword to define the integer data type.

int a = 42;
Several of the basic types, including integers, can be modified using one or more of these type modifiers:
signed: A signed integer can hold both negative and positive numbers.
unsigned: An unsigned integer can hold only positive values.
short: Half of the default size.
long: Twice the default size.

For example:
unsigned long int a;
The integer data type reserves 4-8 bytes depending on the operating system.
===================================================================
Floating Point Numbers
A floating point type variable can hold a real number, such as 420.0, -3.33, or 0.03325.
The words floating point refer to the fact that a varying number of digits can appear before and after the decimal point. You could say that the decimal has the ability to "float".

There are three different floating point data types: float, double, and long double.

In most modern architectures, a float is 4 bytes, a double is 8, and a long double can be equivalent to a double (8 bytes), or 16 bytes.

For example:
double temp = 4.21;
Floating point data types are always signed, which means that they have the capability to hold both positive and negative values.
===================================================================
++=====================++
++=====================++ string, char, bool
Strings
A string is an ordered sequence of characters, enclosed in double quotation marks.
It is part of the Standard Library.
You need to include the <string> library to use the string data type. Alternatively, you can use a library that includes the string library.
#include <string>
using namespace std;

int main() {
    string a = "I am learning C++";
    return 0;
}
OUTPUT
No output.

The <string> library is included in the <iostream> library, so you don't need to include <string> separately, if you already use <iostream>.
===================================================================
Characters
A char variable holds a 1-byte integer. However, instead of interpreting the value of the char as an integer, the value of a char variable is typically interpreted as an ASCII character.

A character is enclosed between single quotes (such as 'a', 'b', etc).

For example:
char test = 'S';
American Standard Code for Information Interchange (ASCII) is a character-encoding scheme that is used to represent text in computers.
===================================================================
Booleans
Boolean variables only have two possible values: true (1) and false (0).
To declare a boolean variable, we use the keyword bool.

bool online = false;
bool logged_in = true;
If a Boolean value is assigned to an integer, true becomes 1 and false becomes 0.
If an integer value is assigned to a Boolean, 0 becomes false and any value that has a non-zero value becomes true.
===================================================================
++=====================++
++=====================++ Variable Naming Rules
Variable Naming Rules
Use the following rules when naming variables:
- All variable names must begin with a letter of the alphabet or an underscore( _ ).
- After the initial letter, variable names can contain additional letters, as well as numbers. Blank spaces or special characters are not allowed in variable names.

There are two known naming conventions:
Pascal case: The first letter in the identifier and the first letter of each subsequent concatenated word are capitalized. For example: BackColor
Camel case: The first letter of an identifier is lowercase and the first letter of each subsequent concatenated word is capitalized. For example: backColor
===================================================================
Case-Sensitivity
C++ is case-sensitive, which means that an identifier written in uppercase is not equivalent to another one with the same name in lowercase.
For example, myvariable is not the same as MYVARIABLE and not the same as MyVariable.
These are three different variables.

Choose variable names that suggest the usage, for example: firstName, lastName.
===================================================================
Variable Naming Rules
C++ keyword (reserved word) cannot be used as variable names.
For example, int, float, double, cout cannot be used as a variable name.

There is no real limit on the length of the variable name (depends on the environment), but try to keep your variable names practical and meaningful.
===================================================================
++=====================++
++=====================++ Arrays
Arrays
An array is used to store a collection of data, but it may be useful to think of an array as a collection of variables that are all of the same type.
Instead of declaring multiple variables and storing individual values, you can declare a single array to store all the values.
When declaring an array, specify its element types, as well as the number of elements it will hold.

For example:
int a[5];
In the example above, variable a was declared as an array of five integer values [specified in square brackets].
You can initialize the array by specifying the values it holds:

int b[5] = {11, 45, 62, 70, 88};
The values are provided in a comma separated list, enclosed in {curly braces}.

The number of values between braces { } must not exceed the number of the elements declared within the square brackets [ ].
===================================================================
Initializing Arrays
If you omit the size of the array, an array just big enough to hold the initialization is created.

For example:
int b[] = {11, 45, 62, 70, 88};
This creates an identical array to the one created in the previous example.

Each element, or member, of the array has an index, which pinpoints the element's specific position.
The array's first member has the index of 0, the second has the index of 1.
So, for the array b that we declared above:

img-component
To access array elements, index the array name by placing the element's index in square brackets following the array name.

For example:
#include <iostream>
using namespace std;

int main()
{
    int b[] = {11, 45, 62, 70, 88};

    cout << b[0] << endl;
    // Outputs 11
    
    cout<< b[3] << endl;
    // Outputs 70

    return 0;
}
OUTPUT
11
70
===================================================================
Accessing Array Elements
Index numbers may also be used to assign a new value to an element.

int b[] = {11, 45, 62, 70, 88};
b[2] = 42;
This assigns a value of 42 to the array's third element.

Always remember that the list of elements always begins with the index of 0.
===================================================================
++=====================++
++=====================++ Using Arrays in Loops
Arrays in Loops
It's occasionally necessary to iterate over the elements of an array, assigning the elements values based on certain calculations.

Usually, this is accomplished using a loop.
===================================================================
Arrays in Loops
Let's declare an array, that is going to store 5 integers, and assign a value to each element using the for loop:

int myArr[5];

for(int x=0; x<5; x++) {
  myArr[x] = 42;
}
Each element in the array is assigned the value of 42.
The x variable in the for loop is used as the index for the array.

The last index in the array is 4, so the for loop condition is x<5.
===================================================================
Arrays in Loops
Let's output each index and corresponding value in the array.
#include <iostream>
using namespace std;

int main()
{
    int myArr[5];

    for(int x=0; x<5; x++) {
        myArr[x] = 42;
 
        cout << x << ": " << myArr[x] << endl;
    }

    return 0;
}
OUTPUT
0: 42
1: 42
2: 42
3: 42
4: 42
===================================================================
++=====================++
++=====================++ Arrays in Calculations
Arrays in Calculations
The following code creates a program that uses a for loop to calculate the sum of all elements of an array.
#include <iostream>
using namespace std;

int main()
{
    int arr[] = {11, 35, 62, 555, 989};
    int sum = 0; 

    for (int x = 0; x < 5; x++) {
        sum += arr[x];
    }

    cout << sum << endl;

    return 0;
}
OUTPUT
1652

To review, we declared an array and a variable sum that will hold the sum of the elements.
Next, we utilized a for loop to iterate through each element of the array, and added the corresponding element's value to our sum variable.

In the array, the first element's index is 0, so the for loop initializes the x variable to 0.
===================================================================
++=====================++
++=====================++ Multi-Dimensional Arrays
Multi-Dimensional Arrays
A multi-dimensional array holds one or more arrays. Declare a multidimensional array as follows.

type name[size1][size2]...[sizeN];
Here, we've created a two-dimensional 3x4 integer array:

int x[3][4];
Visualize this array as a table composed of 3 rows, and 4 columns.

img-component
Remember element counting always starts from 0.
===================================================================
Two-Dimensional Arrays
Multi-dimensional arrays may be initialized by specifying bracketed values for each row.
Following is an array with 2 rows and 3 columns:

int x[2][3] = {
  {2, 3, 4}, // 1st row
  {8, 9, 10} // 2nd row
};
You can also write the same initialization using just one row.

int x[2][3] = {{2, 3, 4}, {8, 9, 10}};
The elements are accessed by using the row index and column index of the array.

For example:
#include <iostream>
using namespace std;

int main()
{
    int x[2][3] = {{2, 3, 4}, {8, 9, 10}};
    cout << x[0][2] << endl;

    return 0;
}
OUTPUT
4

The first index 0 refers to the first row. The second index 2 refers to the 3rd element of the first row, which is 4.
===================================================================
Multi-Dimensional Arrays
Arrays can contain an unlimited number of dimensions.

string threeD[42][8][3];
The example above declares a three-dimensional array of strings. As we did previously, it's possible to use index numbers to access and modify the elements.

Arrays more than three dimensions are harder to manage.
===================================================================
++=====================++
++=====================++ Introduction to Pointers
Pointers
Every variable is a memory location, which has its address defined.
That address can be accessed using the ampersand (&) operator (also called the address-of operator), which denotes an address in memory.

For example:
#include <iostream>
using namespace std;

int main()
{
    int score = 5;
    cout << &score << endl;

    return 0;
}
OUTPUT
0x7ffd3beea2ec

This outputs the memory address, which stores the variable score.
===================================================================
Pointers
A pointer is a variable, with the address of another variable as its value.
In C++, pointers help make certain tasks easier to perform. Other tasks, such as dynamic memory allocation, cannot be performed without using pointers.

All pointers share the same data type - a long hexadecimal number that represents a memory address.

The only difference between pointers of different data types is the data type of the variable that the pointer points to.
===================================================================
Pointers
A pointer is a variable, and like any other variable, it must be declared before you can work with it.
The asterisk sign is used to declare a pointer (the same asterisk that you use for multiplication), however, in this statement the asterisk is being used to designate a variable as a pointer.
Following are valid pointer declarations:

int *ip;  // pointer to an integer
double *dp;   // pointer to a double
float *fp;  // pointer to a float
char *ch;  // pointer to a character
Just like with variables, we give the pointers a name and define the type, to which the pointer points to.

The asterisk sign can be placed next to the data type, or the variable name, or in the middle.
===================================================================
Using Pointers
Here, we assign the address of a variable to the pointer.
#include <iostream>
using namespace std;

int main()
{
    int score = 5;
    int *scorePtr;
    scorePtr = &score;

    cout << scorePtr << endl;

    return 0;
}
OUTPUT
0x7ffdba6a4f14

The code above declares a pointer to an integer called scorePtr, and assigns to it the memory location of the score variable using the ampersand (address-of) operator.

Now, scorePtr's value is the memory location of score.
===================================================================
++=====================++
++=====================++ More on Pointers
Pointer Operations
There are two operators for pointers:
Address-of operator (&): returns the memory address of its operand.
Contents-of (or dereference) operator (*): returns the value of the variable located at the address specified by its operand.

For example:
#include <iostream>
using namespace std;

int main()
{
    int var = 50;
    int  *p;
    p = &var;

    cout << var << endl;
    // Outputs 50 (the value of var)

    cout << p << endl;
    // Outputs 0x29fee8 (var's memory location)

    cout << *p << endl;
    /* Outputs 50 (the value of the variable
     stored in the pointer p) */

    return 0;
}
OUTPUT
50
0x7ffe1f2b2c24
50

The asterisk (*) is used in declaring a pointer for the simple purpose of indicating that it is a pointer (The asterisk is part of its type compound specifier). Don't confuse this with the dereference operator, which is used to obtain the value located at the specified address. They are simply two different things represented with the same sign.
===================================================================
Dereferencing
The dereference operator (*) is basically an alias for the variable the pointer points to.

For example:
int x = 5;
int *p = &x;

x = x + 4;
x = *p + 4;
*p = *p + 4;
All three of the preceding statements are equivalent, and return the same result. We can access the variable by dereferencing the variable's pointer.

As p is pointing to the variable x, dereferencing the pointer (*p) is representing exactly the same as the variable x.
===================================================================
++=====================++
++=====================++ Dynamic Memory
Static & Dynamic Memory
To be successful as a C++ programmer, it's essential to have a good understanding of how dynamic memory works.
In a C++ program, memory is divided into two parts:
The stack: All of your local variables take up memory from the stack.
The heap: Unused program memory that can be used when the program runs to dynamically allocate the memory.

Many times, you are not aware in advance how much memory you will need to store particular information in a defined variable and the size of required memory can be determined at run time.
You can allocate memory at run time within the heap for the variable of a given type using the new operator, which returns the address of the space allocated.

new int;
This allocates the memory size necessary for storing an integer on the heap, and returns that address.
===================================================================
Dynamic Memory
The allocated address can be stored in a pointer, which can then be dereferenced to access the variable.

Example:
int *p = new int;
*p = 5;
We have dynamically allocated memory for an integer, and assigned it a value of 5.

The pointer p is stored in the stack as a local variable, and holds the heap's allocated address as its value. The value of 5 is stored at that address in the heap.
===================================================================
Dynamic Memory
For local variables on the stack, managing memory is carried out automatically.
On the heap, it's necessary to manually handle the dynamically allocated memory, and use the delete operator to free up the memory when it's no longer needed.

delete pointer;
This statement releases the memory pointed to by pointer.

For example:
#include <iostream>
using namespace std;

int main()
{
    int *p = new int; // request memory
    *p = 5; // store value

    cout << *p << endl; // use value

    delete p; // free up the memory

    return 0;
}
OUTPUT
5

Forgetting to free up memory that has been allocated with the new keyword will result in memory leaks, because that memory will stay allocated until the program shuts down.
===================================================================
Dangling Pointers
The delete operator frees up the memory allocated for the variable, but does not delete the pointer itself, as the pointer is stored on the stack.

Pointers that are left pointing to non-existent memory locations are called dangling pointers.

For example:
#include <iostream>
using namespace std;

int main()
{
    int *p = new int; // request memory
    *p = 5; // store value

    delete p; // free up the memory
    // now p is a dangling pointer

    p = new int; // reuse for a new address

    return 0;
}
OUTPUT
No output.

The NULL pointer is a constant with a value of zero that is defined in several of the standard libraries, including iostream.
It's a good practice to assign NULL to a pointer variable when you declare it, in case you do not have exact address to be assigned. A pointer assigned NULL is called a null pointer. For example: int *ptr = NULL;
===================================================================
Dynamic Memory
Dynamic memory can also be allocated for arrays.

For example:
#include <iostream>
using namespace std;

int main()
{
    int *p = NULL; // Pointer initialized with null
    p = new int[20]; // Request memory
    delete [] p; // Delete array pointed to by p

    return 0;
}
OUTPUT
No output.

Note the brackets in the syntax.

Dynamic memory allocation is useful in many situations, such as when your program depends on input. As an example, when your program needs to read an image file, it doesn't know in advance the size of the image file and the memory necessary to store the image.
===================================================================
++=====================++
++=====================++ The sizeof() Operator
sizeof
While the size allocated for varying data types depends on the architecture of the computer you use to run your programs, C++ does guarantee a minimum size for the basic data types:

img-component
The sizeof operator can be used to get a variable or data type's size, in bytes.

Syntax:
sizeof (data type)
The sizeof operator determines and returns the size of either a type or a variable in bytes.

For example:
#include <iostream>
using namespace std;

int main()
{
    cout << "char: " << sizeof(char) << endl;
    cout << "int: " << sizeof(int) << endl;
    cout << "float: " << sizeof(float) << endl;
    cout << "double: " << sizeof(double) << endl;
    int var = 50;
    cout << "var: " << sizeof(var) << endl;

    return 0;
}
OUTPUT
char: 1
int: 4
float: 4
double: 8
var: 4

Output values may vary, according to the computer and compiler used.
===================================================================
Size of an Array
The C++ sizeof operator is also used to determine the size of an array.

For example:
#include <iostream>
using namespace std;

int main()
{
    double myArr[10];
    cout << sizeof(myArr) << endl;

    return 0;
}
OUTPUT
80
===================================================================
++=====================++
++=====================++ Introduction to Functions
Functions
A function is a group of statements that perform a particular task.
You may define your own functions in C++.

Using functions can have many advantages, including the following:
- You can reuse the code within a function.
- You can easily test individual functions.
- If it's necessary to make any code modifications, you can make modifications within a single function, without altering the program structure.
- You can use the same function for different inputs.

Every valid C++ program has at least one function - the main() function.
===================================================================
The Return Type
The main function takes the following general form:

int main()
{
  // some code
  return 0;
}
A function's return type is declared before its name. In the example above, the return type is int, which indicates that the function returns an integer value.
Occasionally, a function will perform the desired operations without returning a value. Such functions are defined with the keyword void.

void is a basic data type that defines a valueless state.
===================================================================
Defining a Function
Define a C++ function using the following syntax:

return_type function_name( parameter list )
{
   body of the function
}
return-type: Data type of the value returned by the function.
function name: Name of the function.
parameters: When a function is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of the parameters of a function.
body of the function: A collection of statements defining what the function does.

Parameters are optional; that is, you can have a function with no parameters.
===================================================================
Defining a Function
As an example, let's define a function that does not return a value, and just prints a line of text to the screen.

void printSomething() 
{
  cout << "Hi there!";
}
Our function, entitled printSomething, returns void, and has no parameters.
Now, we can use our function in main().
#include <iostream>
using namespace std;

void printSomething() 
{
    cout << "Hi there!";
}

int main() 
{
    printSomething();
   
   return 0;
}
OUTPUT
Hi there!

To call a function, you simply need to pass the required parameters along with the function name.
===================================================================
Functions
You must declare a function prior to calling it.

For example:
#include <iostream>
using namespace std;

void printSomething() {
    cout << "Hi there!";
}

int main() {
    printSomething();
}
OUTPUT
Hi there!

Putting the declaration after the main() function results in an error.
===================================================================
Functions
A function declaration, or function prototype, tells the compiler about a function name and how to call the function. The actual body of the function can be defined separately.

For example:
#include <iostream>
using namespace std;

//Function declaration
void printSomething();

int main() {
    printSomething();
}

//Function definition
void printSomething() {
    cout << "Hi there!";
}
OUTPUT
Hi there!

Function declaration is required when you define a function in one source file and you call that function in another file. In such case, you should declare the function at the top of the file calling the function.
===================================================================
++=====================++
++=====================++ Function Parameters
Function Parameters
For a function to use arguments, it must declare formal parameters, which are variables that accept the argument's values.

For example:
void printSomething(int x) 
{
   cout << x;
}
This defines a function that takes one integer parameter and prints its value.

Formal parameters behave within the function similarly to other local variables. They are created upon entering the function, and are destroyed upon exiting the function.
===================================================================
Function Parameters
Once parameters have been defined, you can pass the corresponding arguments when the function is called.

For example:
#include <iostream>
using namespace std;

void printSomething(int x) {
    cout << x;
}

int main() {
    printSomething(42);
}
OUTPUT
42

The value 42 is passed to the function as an argument, and is assigned to the formal parameter of the function: x.

Making changes to the parameter within the function does not alter the argument.
===================================================================
Function Parameters
You can pass different arguments to the same function.

For example:
int timesTwo(int x) {
   return x*2;
}
The function defined above takes one integer parameter and returns its value, multiplied by 2.

We can now use that function with different arguments.
#include <iostream>
using namespace std;

int timesTwo(int x) {
    return x*2;
}

int main() {
    cout << timesTwo(8) << endl;

    cout <<timesTwo(5) << endl;

    cout <<timesTwo(42) << endl;
}
OUTPUT
16
10
84
===================================================================
++=====================++
++=====================++ Functions with Multiple Parameters
Multiple Parameters
You can define as many parameters as you want for your functions, by separating them with commas.

Let's create a simple function that returns the sum of two parameters.

int addNumbers(int x, int y) {
 // code goes here
}
As defined, the addNumbers function takes two parameters of type int, and returns int.

Data type and name should be defined for each parameter.
===================================================================
Multiple Parameters
Now let's calculate the sum of the two parameters and return the result:
#include <iostream>
using namespace std;

int addNumbers(int x, int y) {
    int result = x + y;
    return result;
}

int main() {
    cout << addNumbers(4, 5);
}
OUTPUT
9
===================================================================
Multiple Parameters
Now we can call the function.
#include <iostream>
using namespace std;

int addNumbers(int x, int y) {
    int result = x + y;
    return result;
}

int main() {
    cout << addNumbers(50, 25);
}
OUTPUT
75

You can also assign the returned value to a variable.
#include <iostream>
using namespace std;

int addNumbers(int x, int y) {
    int result = x + y;
    return result;
}

int main() {
    int x = addNumbers(35, 7);
    cout << x;
}
OUTPUT
75
===================================================================
Multiple Parameters
You can add as many parameters to a single function as you want.

For example:
#include <iostream>
using namespace std;

int addNumbers(int x, int y, int z, int a) {
  int result = x + y + z + a;
  return result;
}

int main()
{
    cout << addNumbers(1, 7, 8, 3);

    return 0;
}
OUTPUT
19

If you have multiple parameters, remember to separate them with commas, both when declaring them and when passing the arguments.
===================================================================
++=====================++
++=====================++ The rand() Function
Random Numbers
Being able to generate random numbers is helpful in a number of situations, including when creating games, statistical modeling programs, and similar end products.

In the C++ standard library, you can access a pseudo random number generator function that's called rand(). When used, we are required to include the header <cstdlib>.
#include <iostream>
#include <cstdlib>
using namespace std;

int main() {
  cout << rand();
}
OUTPUT
1804289383

This will output a random number.
===================================================================
Random Numbers
A for loop can be used to generate multiple random numbers.
#include <iostream>
#include <cstdlib>
using namespace std;

int main() {
    for (int x = 1; x <= 10; x++) {
        cout << rand() << endl;
    }
}
OUTPUT
1804289383
846930886
1681692777
1714636915
1957747793
424238335
719885386
1649760492
596516649
1189641421
===================================================================
Random Numbers
Use the modulo (%) operator to generate random numbers within a specific range.
The example below generates whole numbers within a range of 1 to 6.
#include <iostream>
#include <cstdlib>
using namespace std;

int main () {
    for (int x = 1; x <= 10; x++) {
        cout << 1 + (rand() % 6) << endl;
    }
}

However, the rand() function will only return a pseudo random number. This means that each time the code is run, it generates the same numbers.
===================================================================
The srand() Function
The srand() function is used to generate truly random numbers.
This function allows to specify a seed value as its parameter, which is used for the rand() function's algorithm.

#include <iostream>
#include <cstdlib>
using namespace std;

int main () {
    srand(98);

    for (int x = 1; x <= 10; x++) {
        cout << 1 + (rand() % 6) << endl;
    }
}
OUTPUT
2
2
4
4
2
1
2
5
4
3

Changing the seed value changes the return of rand(). However, the same argument will result in the same output.
===================================================================
Truly Random Numbers
A solution to generate truly random numbers, is to use the current time as a seed value for the srand() function.
This example makes use of the time() function to get the number of seconds on your system time, and randomly seed the rand() function (we need to include the <ctime> header for it):

#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;

int main () {
    srand(time(0));
    for (int x = 1; x <= 10; x++) {
        cout << 1 + (rand() % 6) << endl;
    }
}
OUTPUT
1
5
2
2
3
2
5
6
3
1

time(0) will return the current second count, prompting the srand() function to set a different seed for the rand() function each time the program runs.

Using this seed value will create a different output each time we run the program.
===================================================================
++=====================++
++=====================++ Default Arguments
Default Values for Parameters
When defining a function, you can specify a default value for each of the last parameters. If the corresponding argument is missing when you call a function, it uses the default value.

To do this, use the assignment operator to assign values to the arguments in the function definition, as shown in this example.

int sum(int a, int b=42) {
  int result = a + b;
  return (result);
}

This assigns a default value of 42 to the b parameter. If we call the function without passing the value for the b parameter, the default value will be used.
#include <iostream>
using namespace std;

int sum(int a, int b=42) {
    int result = a + b;
    return (result);
}

int main() {
    int x = 24;
    int y = 36;

    //calling the function with both parameters
    int result = sum(x, y);
    cout << result << endl;

    //calling the function without b
    result = sum(x);
    cout <<  result << endl;

  return 0;
} 
OUTPUT
60
66

The second call to the function does not pass a value for the second parameter, and the default value of 42 is used, instead.
===================================================================
Using Default Arguments
Another example:
#include <iostream>
using namespace std;

int volume(int l=1, int w=1, int h=1) {
    return l*w*h;
}

int main() {
    cout << volume() << endl;
    cout << volume(5) << endl;
    cout << volume(2, 3) << endl;
    cout << volume(3, 7, 6) << endl;
}
OUTPUT
1
5
6
126

As you can see, default parameter values can be used for calling the same function in different situations, when one or more of its parameters are not used.
===================================================================
++=====================++
++=====================++ Function Overloading
Overloading
Function overloading allows to create multiple functions with the same name, so long as they have different parameters.

For example, you might need a printNumber() function that prints the value of its parameter.

void printNumber(int a) { 
  cout << a;
}
This is effective with integer arguments only. Overloading it will make it available for other types, such as floats.

void printNumber(float a) { 
  cout << a;
}
Now, the same printNumber() function name will work for both integers and floats.
===================================================================
Function Overloading
When overloading functions, the definition of the function must differ from each other by the types and/or the number of arguments in the argument list.

For example:
#include <iostream>
using namespace std;

void printNumber(int x) {
    cout << "Prints an integer: " << x << endl;
}
void printNumber(float x) {
    cout << "Prints a float: " << x << endl;
}

int main() {
    int a = 16;
    float b = 54.541;
    printNumber(a);
    printNumber(b);
}
OUTPUT
Prints an integer: 16
Prints a float: 54.541

As you can see, the function call is based on the argument provided. An integer argument will call the function implementation that takes an integer parameter. A float argument will call the implementation taking a float parameter.
===================================================================
Function Overloading
You can not overload function declarations that differ only by return type.
The following declaration results in an error.

#include <iostream>
using namespace std;

int printName(int a) { }
float printName(int b) { }
double printName(int c) { }

int main()
{
    
    return 0;
}

Although each function uses the same name, the only difference from one to the other is the return type, which is not allowed.
===================================================================
++=====================++
++=====================++ Recursion
Recursion
A recursive function in C++ is a function that calls itself.

To avoid having the recursion run indefinitely, you must include a termination condition.
===================================================================
Recursion
To demonstrate recursion, let's create a program to calculate a number's factorial.
In mathematics, the term factorial refers to the product of all positive integers that are less than or equal to a specific non-negative integer (n). The factorial of n is denoted as n!

For example:
4! = 4 * 3 * 2 * 1 = 24
Recursion is a method of solving a problem where the solution depends on the solutions to smaller instances of the same problem.
===================================================================
Recursion
Let's define our function:

int factorial(int n) {
  if (n==1) {
    return 1;
  }
  else {
    return n * factorial(n-1);
  }
}
The if statement defines the exit condition. In this case, it's when n equals one, return 1 (the factorial of one is one).
We placed the recursive function call in the else statement, which returns n multiplied by the factorial of n-1.
For example, if you call the factorial function with the argument 4, it will execute as follows:
return 4 * factorial(3), which is 4*3*factorial(2), which is 4*3*2*factorial(1), which is 4*3*2*1.

The factorial function calls itself, and then continues to do so, until the argument equals 1.
===================================================================
Recursion
We're now at the point where we can call our factorial function.

#include <iostream>
using namespace std;

int factorial(int n) {
    if (n==1) {
        return 1;
    }
    else {
        return n * factorial(n-1);
    }
}

int main() {
    cout << factorial(5);
}
OUTPUT
120

Another name for the exit condition is the base case.

Keep in mind that a base case is necessary for real recursion. Without it, the recursion will keep running forever.
===================================================================
++=====================++
++=====================++ Passing Arrays to Functions
Arrays and Functions
An array can also be passed to a function as an argument.
The parameter should be defined as an array using square brackets, when declaring the function.

For example:
#include <iostream>
using namespace std;

void printArray(int arr[], int size) {
  for(int x = 0; x < size; x++) {
    cout << arr[x];
  }
}

int main() {
  int arr[] = {1, 2, 3, 4, 5};
  printArray(arr, 5);
}
OUTPUT
12345
===================================================================
Arrays and Functions
We can use our function in main(), and call it for our sample array:
#include <iostream>
using namespace std;

void printArray(int arr[], int size) {
    for(int x=0; x<size; x++) {
        cout <<arr[x]<< endl;
    }
}

int main() {
    int myArr[3]= {42, 33, 88};
    printArray(myArr, 3);
}
OUTPUT
42
33
88

The printArray function takes an array as its parameter (int arr[]), and iterates over the array using a for loop.
We call the function in main(), which is where we pass the myArr array to the function, which prints its elements.

Remember to specify the array's name without square brackets when passing it as an argument to a function.
===================================================================
++=====================++
++=====================++ Pass by Reference with Pointers
Function Arguments
There are two ways to pass arguments to a function as the function is being called.

By value: This method copies the argument's actual value into the function's formal parameter. Here, we can make changes to the parameter within the function without having any effect on the argument.

By reference: This method copies the argument's reference into the formal parameter. Within the function, the reference is used to access the actual argument used in the call. This means that any change made to the parameter affects the argument.

By default, C++ uses call by value to pass arguments.
===================================================================
Passing by Value
By default, arguments in C++ are passed by value.
When passed by value, a copy of the argument is passed to the function.

Example:
#include <iostream>
using namespace std;

void myFunc(int x) {
    x = 100;
}

int main() {
    int var = 20;
    myFunc(var);
    cout << var;
}
OUTPUT
20

Because a copy of the argument is passed to the function, the original argument is not modified by the function.
===================================================================
Passing by Reference
Pass-by-reference copies an argument's address into the formal parameter. Inside the function, the address is used to access the actual argument used in the call. This means that changes made to the parameter affect the argument.
To pass the value by reference, argument pointers are passed to the functions just like any other value.

#include <iostream>
using namespace std;

void myFunc(int *x) {
    *x = 100;
}

int main() {
    int var = 20;
    myFunc(&var);
    cout << var;
}
OUTPUT
100

As you can see, we passed the variable directly to the function using the address-of operator &.
The function declaration says that the function takes a pointer as its parameter (defined using the * operator).

As a result, the function has actually changed the argument's value, as accessed it via the pointer.
===================================================================
Summary
Passing by value: This method copies the actual value of an argument into the formal parameter of the function. In this case, changes made to the parameter inside the function have no effect on the argument.

Passing by reference: This method copies the reference of an argument into the formal parameter. Inside the function, the reference is used to access the actual argument used in the call. So, changes made to the parameter also affect the argument.

In general, passing by value is faster and more effective. Pass by reference when your function needs to modify the argument, or when you need to pass a data type, that uses a lot of memory and is expensive to copy.
===================================================================
++=====================++
++=====================++ Classes and Objects:: What is an Object
What is an Object
Object Oriented Programming is a programming style that is intended to make thinking about programming closer to thinking about the real world.

In programming, objects are independent units, and each has its own identity, just as objects in the real world do.

An apple is an object; so is a mug. Each has its unique identity. It's possible to have two mugs that look identical, but they are still separate, unique objects.
===================================================================
Objects
An object might contain other objects but they're still different objects.

Objects also have characteristics that are used to describe them. For example, a car can be red or blue, a mug can be full or empty, and so on. These characteristics are also called attributes. An attribute describes the current state of an object.
Objects can have multiple attributes (the mug can be empty, red and large).

An object's state is independent of its type; a cup might be full of water, another might be empty.
===================================================================
Objects
In the real world, each object behaves in its own way. The car moves, the phone rings, and so on.
The same applies to objects - behavior is specific to the object's type.

So, the following three dimensions describe any object in object oriented programming: identity, attributes, behavior.
===================================================================
Objects
In programming, an object is self-contained, with its own identity. It is separate from other objects.
Each object has its own attributes, which describe its current state. Each exhibits its own behavior, which demonstrates what they can do.

img-component
In computing, objects aren't always representative of physical items.
For example, a programming object can represent a date, a time, a bank account. A bank account is not tangible; you can't see it or touch it, but it's still a well-defined object - it has its own identity, attributes, and behavior.
===================================================================
++=====================++
++=====================++ What is a Class
What is a Class
Objects are created using classes, which are actually the focal point of OOP.

The class describes what the object will be, but is separate from the object itself.
In other words, a class can be described as an object's blueprint, description, or definition.
You can use the same class as a blueprint for creating multiple different objects. For example, in preparation to creating a new building, the architect creates a blueprint, which is used as a basis for actually building the structure. That same blueprint can be used to create multiple buildings.

Programming works in the same fashion. We first define a class, which becomes the blueprint for creating objects.

Each class has a name, and describes attributes and behavior.

In programming, the term type is used to refer to a class name: We're creating an object of a particular type.

Attributes are also referred to as properties or data.
===================================================================
Methods
Method is another term for a class' behavior. A method is basically a function that belongs to a class.

Methods are similar to functions - they are blocks of code that are called, and they can also perform actions and return values.
===================================================================
A Class Example
For example, if we are creating a banking program, we can give our class the following characteristics:
name: BankAccount
attributes: accountNumber, balance, dateOpened
behavior: open(), close(), deposit()

The class specifies that each object should have the defined attributes and behavior. However, it doesn't specify what the actual data is; it only provides a definition.

Once we've written the class, we can move on to create objects that are based on that class.
Each object is called an instance of a class. The process of creating objects is called instantiation.

Each object has its own identity, data, and behavior.
===================================================================
++=====================++
++=====================++ Example of a Class
Declaring a Class
Begin your class definition with the keyword class. Follow the keyword with the class name and the class body, enclosed in a set of curly braces.
The following code declares a class called BankAccount:

class BankAccount {

};
A class definition must be followed by a semicolon.
===================================================================
Declaring a Class
Define all attributes and behavior (or members) in the body of the class, within curly braces.
You can also define an access specifier for members of the class.
A member that has been defined using the public keyword can be accessed from outside the class, as long as it's anywhere within the scope of the class object.

You can also designate a class' members as private or protected. This will be discussed in greater detail later in the course.
===================================================================
Creating a Class
Let's create a class with one public method, and have it print out "Hi".

class BankAccount {
  public:
    void sayHi() {
      cout << "Hi" << endl;
    }
};
The next step is to instantiate an object of our BankAccount class, in the same way we define variables of a type, the difference being that our object's type will be BankAccount.

#include <iostream>
using namespace std;

class BankAccount {
    public:
        void sayHi() {
            cout << "Hi" << endl;
        }
};

int main() 
{
    BankAccount test;
    test.sayHi();
}
OUTPUT
Hi

Our object named test has all the members of the class defined.
Notice the dot separator (.) that is used to access and call the method of the object.

We must declare a class before using it, as we do with functions.
===================================================================
++=====================++
++=====================++ Abstraction
Abstraction
Data abstraction is the concept of providing only essential information to the outside world. It's a process of representing essential features without including implementation details.

A good real-world example is a book: When you hear the term book, you don't know the exact specifics, i.e.: the page count, the color, the size, but you understand the idea of a book - the abstraction of the book.

The concept of abstraction is that we focus on essential qualities, rather than the specific characteristics of one particular example.
===================================================================
Abstraction
Abstraction means, that we can have an idea or a concept that is completely separate from any specific instance.
It is one of the fundamental building blocks of object oriented programming.

For example, when you use cout, you're actually using the cout object of the class ostream. This streams data to result in standard output.

cout << "Hello!" << endl;
In this example, there is no need to understand how cout will display the text on the user's screen. The only thing you need to know to be able to use it is the public interface.
===================================================================
Abstraction
Abstraction allows us to write a single bank account class, and then create different objects based on the class, for individual bank accounts, rather than creating a separate class for each bank account.

img-component
Abstraction acts as a foundation for the other object orientation fundamentals, such as inheritance and polymorphism. These will be discussed later in the course.
===================================================================
++=====================++
++=====================++ Encapsulation
Encapsulation
Part of the meaning of the word encapsulation is the idea of "surrounding" an entity, not just to keep what's inside together, but also to protect it.
In object orientation, encapsulation means more than simply combining attributes and behavior together within a class; it also means restricting access to the inner workings of that class.

The key principle here is that an object only reveals what the other application components require to effectively run the application. All else is kept out of view.

This is called data hiding.
===================================================================
Encapsulation
For example, if we take our BankAccount class, we do not want some other part of our program to reach in and change the balance of any object, without going through the deposit() or withdraw() behaviors.
We should hide that attribute, control access to it, so it is accessible only by the object itself.
This way, the balance cannot be directly changed from outside of the object and is accessible only using its methods.
This is also known as "black boxing", which refers to closing the inner working zones of the object, except of the pieces that we want to make public.
This allows us to change attributes and implementation of methods without altering the overall program. For example, we can come back later and change the data type of the balance attribute.

In summary the benefits of encapsulation are:
- Control the way data is accessed or modified.
- Code is more flexible and easy to change with new requirements.
- Change one part of code without affecting other part of code.
===================================================================
++=====================++
++=====================++ Example of Encapsulation
Access Specifiers
Access specifiers are used to set access levels to particular members of the class.
The three levels of access specifiers are public, protected, and private.

A public member is accessible from outside the class, and anywhere within the scope of the class object.

For example:

#include <iostream>
#include <string>
using namespace std;

class myClass {
    public:
        string name;
};

int main() {
    myClass myObj;
    myObj.name = "SoloLearn";
    cout << myObj.name;

    return 0;
}
OUTPUT
SoloLearn

The name attribute is public; it can be accessed and modified from outside the code.

Access modifiers only need to be declared once; multiple members can follow a single access modifier.
Notice the colon (:) that follows the public keyword.
===================================================================
Private
A private member cannot be accessed, or even viewed, from outside the class; it can be accessed only from within the class.
A public member function may be used to access the private members. For example:

#include <iostream>
#include <string>
using namespace std;

class myClass {
    public:
        void setName(string x) {
            name = x;
        }
    private:
        string name;
};

int main() {
    myClass myObj;
    myObj.setName("John");

    return 0;
}
OUTPUT
No output.

The name attribute is private and not accessible from the outside.
The public setName() method is used to set the name attribute.

If no access specifier is defined, all members of a class are set to private by default.
===================================================================
Access Specifiers
We can add another public method in order to get the value of the attribute.

class myClass {
  public:
    void setName(string x) {
      name = x;
    }
    string getName() {
      return name;
    }
  private:
    string name;
};
The getName() method returns the value of the private name attribute.
===================================================================
Access Specifiers
Putting it all together:

#include <iostream>
#include <string>
using namespace std;

class myClass {
    public:
        void setName(string x) {
            name = x;
        }
        string getName() {
            return name;
        }
    private:
        string name;
};

int main() {
    myClass myObj;
    myObj.setName("John");
    cout << myObj.getName();

    return 0;
}
OUTPUT
John

We used encapsulation to hide the name attribute from the outside code. Then we provided access to it using public methods. Our class data can be read and modified only through those methods.

This allows for changes to the implementation of the methods and attributes, without affecting the outside code.
===================================================================
++=====================++
++=====================++ Constructors
Constructors
Class constructors are special member functions of a class. They are executed whenever new objects are created within that class.

The constructor's name is identical to that of the class. It has no return type, not even void.

For example:

#include <iostream>
using namespace std;

class myClass {
    public:
        myClass() {
            cout <<"Hey";
        }
        void setName(string x) {
            name = x;
        }
        string getName() {
            return name;
        }
    private:
        string name;
};

int main() {
    myClass myObj;

    return 0;
}
OUTPUT
Hey

Now, upon the creation of an object of type myClass, the constructor is automatically called.
===================================================================
Constructors
Constructors can be very useful for setting initial values for certain member variables.
A default constructor has no parameters. However, when needed, parameters can be added to a constructor. This makes it possible to assign an initial value to an object when it's created, as shown in the following example:

class myClass {
  public:
    myClass(string nm) {
      setName(nm);
    }
    void setName(string x) {
      name = x;
    }
    string getName() {
      return name;
    }
  private:
    string name;
};
We defined a constructor, that takes one parameter and assigns it to the name attribute using the setName() method.
===================================================================
Constructors
When creating an object, you now need to pass the constructor's parameter, as you would when calling a function:

#include <iostream>
using namespace std;

class myClass {
    public:
        myClass(string nm) {
            setName(nm);
        }
        void setName(string x) {
            name = x;
        }
        string getName() {
            return name;
        }
    private:
        string name;
};

int main() {
    myClass ob1("David");
    myClass ob2("Amy");
    cout << ob1.getName();
}
OUTPUT
David

We've defined two objects, and used the constructor to pass the initial value for the name attribute for each object.

It's possible to have multiple constructors that take different numbers of parameters.
===================================================================
++=====================++
++=====================++ Separate Files for Classes
Creating a New Class
It is generally a good practice to define your new classes in separate files. This makes maintaining and reading the code easier.
To do this, use the following steps in CodeBlocks:
Click File->New->Class...
Give your new class a name, uncheck "Has destructor" and check "Header and implementation file shall be in same folder", then click the "Create" button.

img-component
Note that two new files have been added to your project:

img-component
The new files act as templates for our new class.
- MyClass.h is the header file.
- MyClass.cpp is the source file.
===================================================================
Source & Header
The header file (.h) holds the function declarations (prototypes) and variable declarations.
It currently includes a template for our new MyClass class, with one default constructor.

MyClass.h
#ifndef MYCLASS_H
#define MYCLASS_H

class MyClass
{
  public:
    MyClass();
  protected:
  private:
};

#endif // MYCLASS_H
The implementation of the class and its methods go into the source file (.cpp).
Currently it includes just an empty constructor.

MyClass.cpp
#include "MyClass.h"

MyClass::MyClass()
{
   //ctor
}
The #ifndef and #define statements in the header file will be discussed in the upcoming lessons.
===================================================================
Scope Resolution Operator
The double colon in the source file (.cpp) is called the scope resolution operator, and it's used for the constructor definition:

#include "MyClass.h"

MyClass::MyClass()
{
   //ctor
}
The scope resolution operator is used to define a particular class' member functions, which have already been declared. Remember that we defined the constructor prototype in the header file.

So, basically, MyClass::MyClass() refers to the MyClass() member function - or, in this case, constructor - of the MyClass class.
===================================================================
Source & Header
To use our classes in our main, we need to include the header file.

For example, to use our newly created MyClass in main:

#include <iostream>
#include "MyClass.h"
using namespace std;

int main() {
  MyClass obj;
}
The header declares "what" a class (or whatever is being implemented) will do, while the cpp source file defines "how" it will perform those features.
===================================================================
++=====================++
++=====================++ Destructors
Destructors
Remember constructors? They're special member functions that are automatically called when an object is created.
Destructors are special functions, as well. They're called when an object is destroyed or deleted.

Objects are destroyed when they go out of scope, or whenever the delete expression is applied to a pointer directed at an object of a class.
===================================================================
Destructors
The name of a destructor will be exactly the same as the class, only prefixed with a tilde (~). A destructor can't return a value or take any parameters.

class MyClass {
  public: 
    ~MyClass() {
     // some code
    }
};
Destructors can be very useful for releasing resources before coming out of the program. This can include closing files, releasing memory, and so on.
===================================================================
Destructors
For example, let's declare a destructor for our MyClass class, in its header file MyClass.h:

class MyClass
{
  public:
   MyClass();
   ~MyClass();
};
Declare a destructor for our MyClass class.
===================================================================
Destructors
After declaring the destructor in the header file, we can write the implementation in the source file MyClass.cpp:

#include "MyClass.h"
#include <iostream>
using namespace std;

MyClass::MyClass()
{
  cout<<"Constructor"<<endl;
}

MyClass::~MyClass()
{
  cout<<"Destructor"<<endl;
}
Note that we included the <iostream> header, so that we can use cout.
===================================================================
Destructors
Since destructors can't take parameters, they also can't be overloaded.
Each class will have just one destructor.

Defining a destructor is not mandatory; if you don't need one, you don't have to define one.
===================================================================
Destructors
Let's return to our main.

#include <iostream>
using namespace std;

class MyClass
{
    public:
        MyClass();
        ~MyClass();
};

MyClass::MyClass()
{
    cout<<"Constructor"<<endl;
}

MyClass::~MyClass()
{
    cout<<"Destructor"<<endl;
}

int main() {
    MyClass obj;
}
OUTPUT
Constructor
Destructor

We included the class' header file and then created an object of that type.
This returns the following output:

Constructor
Destructor
When the program runs, it first creates the object and calls the constructor. The object is deleted and the destructor is called when the program's execution is completed.

Remember that we printed "Constructor" from the constructor and "Destructor" from the destructor.
===================================================================
++=====================++
++=====================++ Selection Operator
#ifndef & #define
We created separate header and source files for our class, which resulted in this header file.

#ifndef MYCLASS_H
#define MYCLASS_H

class MyClass
{
  public:
  MyClass();
  protected:
  private:
};

#endif // MYCLASS_H
ifndef stands for "if not defined". The first pair of statements tells the program to define the MyClass header file if it has not been defined already.
endif ends the condition.

This prevents a header file from being included more than once within one file.
===================================================================
Member Functions
Let's create a sample function called myPrint() in our class.

MyClass.h
class MyClass
{
  public:
   MyClass();
   void myPrint();
};
MyClass.cpp
#include "MyClass.h"
#include <iostream>
using namespace std;

MyClass::MyClass() {
}

void MyClass::myPrint() {
  cout <<"Hello"<<endl;
}
Since myPrint() is a regular member function, it's necessary to specify its return type in both the declaration and the definition.
===================================================================
Dot Operator
Next, we'll create an object of the type MyClass, and call its myPrint() function using the dot (.) operator:

#include <iostream>
using namespace std;

class MyClass
{
    public:
        MyClass();
        void myPrint();
};

MyClass::MyClass() {
}
void MyClass::myPrint() {
    cout <<"Hello"<<endl;
}

int main() {
    MyClass obj;
    obj.myPrint();
}
OUTPUT
Hello
===================================================================
Pointers
We can also use a pointer to access the object's members.
The following pointer points to the obj object:

MyClass obj;
MyClass *ptr = &obj;
The type of the pointer is MyClass, as it points to an object of that type.
===================================================================
Selection Operator
The arrow member selection operator (->) is used to access an object's members with a pointer.

#include <iostream>
using namespace std;

class MyClass
{
    public:
        MyClass();
        void myPrint();
};

MyClass::MyClass() {
}
void MyClass::myPrint() {
    cout <<"Hello"<<endl;
}

int main() {
    MyClass obj;
    MyClass *ptr = &obj;
    ptr->myPrint();
}
OUTPUT
Hello

When working with an object, use the dot member selection operator (.).
When working with a pointer to the object, use the arrow member selection operator (->).
===================================================================
++=====================++
++=====================++ Const Objects
Constants
A constant is an expression with a fixed value. It cannot be changed while the program is running.
Use the const keyword to define a constant variable.

const int x = 42;
All constant variables must be initialized at the time of their creation.
===================================================================
Constant Objects
As with the built-in data types, we can make class objects constant by using the const keyword.

const MyClass obj;
All const variables must be initialized when they're created. In the case of classes, this initialization is done via constructors. If a class is not initialized using a parameterized constructor, a public default constructor must be provided - if no public default constructor is provided, a compiler error will occur.

Once a const class object has been initialized via the constructor, you cannot modify the object's member variables. This includes both directly making changes to public member variables and calling member functions that set the value of member variables.

When you've used const to declare an object, you can't change its data members during the object's lifetime.
===================================================================
Constant Objects
Only non-const objects can call non-const functions.
A constant object can't call regular functions. Hence, for a constant object to work you need a constant function.

To specify a function as a const member, the const keyword must follow the function prototype, outside of its parameters' closing parenthesis. For const member functions that are defined outside of the class definition, the const keyword must be used on both the function prototype and definition. For example:

MyClass.h
class MyClass
{
  public:
    void myPrint() const;
};
MyClass.cpp
#include "MyClass.h"
#include <iostream>
using namespace std;

void MyClass::myPrint() const {
  cout <<"Hello"<<endl;
}
Now the myPrint() function is a constant member function. As such, it can be called by our constant object:

#include <iostream>
using namespace std;

class MyClass
{
    public:
        void myPrint() const;
};

void MyClass::myPrint() const {
    cout <<"Hello"<<endl;
}

int main() {
    const MyClass obj;
    obj.myPrint();
}
OUTPUT
Hello
===================================================================
Constant Objects
Attempting to call a regular function from a constant object results in an error.
In addition, a compiler error is generated when any const member function attempts to change a member variable or to call a non-const member function.

Defining constant objects and functions ensures that corresponding data members cannot be unexpectedly modified.
===================================================================
++=====================++
++=====================++ Member Initializers
Member Initializers
Recall that constants are variables that cannot be changed, and that all const variables must be initialized at time of creation.

C++ provides a handy syntax for initializing members of the class called the member initializer list (also called a constructor initializer).
===================================================================
Member Initializers
Consider the following class:

class MyClass {
  public:
   MyClass(int a, int b) {
    regVar = a;
    constVar = b;
   }
  private:
    int regVar;
    const int constVar;
};
This class has two member variables, regVar and constVar. It also has a constructor that takes two parameters, which are used to initialize the member variables.
Running this code returns an error, because one of its member variables is a constant, which cannot be assigned a value after declaration.

In cases like this one, a member initialization list can be used to assign values to the member variables.

class MyClass {
 public:
  MyClass(int a, int b)
  : regVar(a), constVar(b)
  {
  }
 private:
  int regVar;
  const int constVar;
};
Note that in the syntax, the initialization list follows the constructor parameters. The list begins with a colon (:), and then lists each variable to be initialized, along with the value for that variable, with a comma to separate them.
Use the syntax variable(value) to assign values.

The initialization list eliminates the need to place explicit assignments in the constructor body. Also, the initialization list does not end with a semicolon.
===================================================================
Member Initializers
Let's write the previous example using separate header and source files.

MyClass.h
class MyClass {
  public:
   MyClass(int a, int b);
  private:
   int regVar;
   const int constVar;
};
MyClass.cpp
MyClass::MyClass(int a, int b)
: regVar(a), constVar(b)
{
  cout << regVar << endl;
  cout << constVar << endl;
}
We have added cout statements in the constructor to print the values of the member variables.
Our next step is to create an object of our class in main, and use the constructor to assign values.

#include <iostream>
using namespace std;

class MyClass {
    public:
        MyClass(int a, int b);
    private:
        int regVar;
        const int constVar;
};

MyClass::MyClass(int a, int b)
: regVar(a), constVar(b)
{
    cout << regVar << endl;
    cout << constVar << endl;
}

int main() {
    MyClass obj(42, 33);
}
OUTPUT
42
33

The constructor is used to create the object, assigning two parameters to the member variables via the member initialization list.
===================================================================
Member Initializers
The member initialization list may be used for regular variables, and must be used for constant variables.

Even in cases in which member variables are not constant, it makes good sense to use the member initializer syntax.
===================================================================
++=====================++
++=====================++ Composition, Part 1
Composition
In the real world, complex objects are typically built using smaller, simpler objects. For example, a car is assembled using a metal frame, an engine, tires, and a large number of other parts. This process is called composition.

In C++, object composition involves using classes as member variables in other classes.
This sample program demonstrates composition in action. It contains Person and Birthday classes, and each Person will have a Birthday object as its member.

Birthday:
class Birthday {
 public:
  Birthday(int m, int d, int y)
  : month(m), day(d), year(y)
  { 
  }
 private:
   int month;
   int day;
   int year;
};
Our Birthday class has three member variables. It also has a constructor that initializes the members using a member initialization list.

The class was declared in a single file for the sake of simplicity. Alternatively, you could use header and source files.
===================================================================
Composition
Let's also add a printDate() function to our Birthday class:

class Birthday {
 public:
  Birthday(int m, int d, int y)
  : month(m), day(d), year(y)
  {
  }
  void printDate()
  {
   cout<<month<<"/"<<day
   <<"/"<<year<<endl;
  }
 private:
  int month;
  int day;
  int year;
};
Add a printDate() function to our Birthday class.
===================================================================
Composition
Next, we can create the Person class, which includes the Birthday class.

#include <string>
#include "Birthday.h"

class Person {
 public:
  Person(string n, Birthday b)
  : name(n),
   bd(b)
  {
  }
 private:
  string name;
  Birthday bd;
};
The Person class has a name and a Birthday member, and a constructor to initialize them.
Ensure that the corresponding header files are included.

More on Composition coming up in the next lesson!
===================================================================
++=====================++
++=====================++ Composition, Part 2
Composition
Now, our Person class has a member of type Birthday:

class Person {
 public:
  Person(string n, Birthday b)
  : name(n),
    bd(b)
  {
  }
 private:
  string name;
  Birthday bd;
};
Composition is used for objects that share a has-a relationship, as in "A Person has a Birthday".
===================================================================
Composition
Let's add a printInfo() function to our Person class, that prints the data of the object:

class Person {
 public:
  Person(string n, Birthday b)
  : name(n),
  bd(b)
  {
  }
  void printInfo()
  {
   cout << name << endl;
   bd.printDate();
  }
 private:
  string name;
  Birthday bd;
};
Notice that we can call the bd member's printDate() function, since it's of type Birthday, which has that function defined.
===================================================================
Composition
Now that we've defined our Birthday and Person classes, we can go to our main, create a Birthday object, and then pass it to a Person object.

#include <iostream>
using namespace std;

class Birthday {
    public:
        Birthday(int m, int d, int y)
        : month(m), day(d), year(y)
        {  }
        void printDate()
        {
            cout<<month<<"/"<<day <<"/"<<year<<endl;
        }
    private:
        int month;
        int day;
        int year;
};

class Person {
    public:
        Person(string n, Birthday b)
        : name(n), bd(b)
        {  }
        void printInfo()
        {
            cout << name << endl;
            bd.printDate();
        }
    private:
        string name;
        Birthday bd;
};

int main() {
    Birthday bd(2, 21, 1985);
    Person p("David", bd);
    p.printInfo();
}
OUTPUT
David
2/21/1985

We've created a Birthday object for the date of 2/21/1985. Next, we created a Person object and passed the Birthday object to its constructor. Finally, we used the Person object's printInfo() function to print its data.

In general, composition serves to keep each individual class relatively simple, straightforward, and focused on performing one task. It also enables each sub-object to be self-contained, allowing for reusability (we can use the Birthday class within various other classes).
===================================================================
++=====================++
++=====================++ The Friend Keyword
Friend Functions
Normally, private members of a class cannot be accessed from outside of that class.
However, declaring a non-member function as a friend of a class allows it to access the class' private members. This is accomplished by including a declaration of this external function within the class, and preceding it with the keyword friend.
In the example below, someFunc(), which is not a member function of the class, is a friend of MyClass and can access its private members.

class MyClass {
 public:
  MyClass() {
   regVar = 0;
  }
 private:
  int regVar;
    
  friend void someFunc(MyClass &obj);
};
Note that when passing an object to the function, we need to pass it by reference, using the & operator.
===================================================================
Friend Functions
The function someFunc() is defined as a regular function outside the class. It takes an object of type MyClass as its parameter, and is able to access the private data members of that object.

class MyClass {
 public:
  MyClass() {
   regVar = 0;
  }
 private:
  int regVar;
    
 friend void someFunc(MyClass &obj);
};

void someFunc(MyClass &obj) {
  obj.regVar = 42;
  cout << obj.regVar;
}
The someFunc() function changes the private member of the object and prints its value.

To make its members accessible, the class has to declare the function as a friend in its definition. You cannot "make" a function a friend to a class without the class "giving away" its friendship to that function.
===================================================================
Friend Functions
Now we can create an object in main and call the someFunc() function:

#include <iostream>
using namespace std;

class MyClass {
    public:
        MyClass() {
            regVar = 0;
        }
    private:
        int regVar;

    friend void someFunc(MyClass &obj);
};

void someFunc(MyClass &obj) {
    obj.regVar = 42;
    cout << obj.regVar;
}

int main() {
    MyClass obj;
    someFunc(obj);
}
OUTPUT
42

someFunc() had the ability to modify the private member of the object and print its value.

Typical use cases of friend functions are operations that are conducted between two different classes accessing private members of both.

You can declare a function friend across any number of classes.
Similar to friend functions, you can define a friend class, which has access to the private members of another class.
===================================================================
++=====================++
++=====================++ The This Keyword
This
Every object in C++ has access to its own address through an important pointer called the this pointer.
Inside a member function this may be used to refer to the invoking object.
Let's create a sample class:

class MyClass {
 public:
  MyClass(int a) : var(a)
  { }
 private:
  int var;
};
Friend functions do not have a this pointer, because friends are not members of a class.
===================================================================
This
The printInfo() method offers three alternatives for printing the member variable of the class.

class MyClass {
 public:
  MyClass(int a) : var(a)
  { }
  void printInfo() {
   cout << var<<endl;
   cout << this->var<<endl;
   cout << (*this).var<<endl; 
  }
 private:
  int var;
};
All three alternatives will produce the same result.

this is a pointer to the object, so the arrow selection operator is used to select the member variable.
===================================================================
This
To see the result, we can create an object of our class and call the member function.

#include <iostream>
using namespace std;

class MyClass {
    public:
        MyClass(int a) : var(a)
        { }
        void printInfo() {
            cout << var <<endl;
            cout << this->var <<endl;
            cout << (*this).var <<endl; 
        }
    private:
        int var;
};

int main() {
    MyClass obj(42);
    obj.printInfo();
}
OUTPUT
42
42
42

All three of the ways to access the member variable work.

Note that only member functions have a this pointer.
===================================================================
This
You may be wondering why it's necessary to use the this keyword, when you have the option of directly specifying the variable.

The this keyword has an important role in operator overloading, which will be covered in the following lesson.
===================================================================
++=====================++
++=====================++ Operator Overloading
Operator Overloading
Most of the C++ built-in operators can be redefined or overloaded.
Thus, operators can be used with user-defined types as well (for example, allowing you to add two objects together).

This chart shows the operators that can be overloaded.

img-component
Operators that can't be overloaded include :: | .* | . | ?:
===================================================================
Operator Overloading
Let's declare a sample class to demonstrate operator overloading:

class MyClass {
 public:
  int var;
  MyClass() {}
  MyClass(int a)
  : var(a) { }
};
Our class has two constructors and one member variable.

We will be overloading the + operator, to enable adding two objects of our class together.
===================================================================
Operator Overloading
Overloaded operators are functions, defined by the keyword operator followed by the symbol for the operator being defined.
An overloaded operator is similar to other functions in that it has a return type and a parameter list.

In our example we will be overloading the + operator. It will return an object of our class and take an object of our class as its parameter.

class MyClass {
 public:
  int var;
  MyClass() {}
  MyClass(int a)
  : var(a) { }

  MyClass operator+(MyClass &obj) {
  }
};
Now, we need to define what the function does.
===================================================================
Operator Overloading
We need our + operator to return a new MyClass object with a member variable equal to the sum of the two objects' member variables.

class MyClass {
 public:
  int var;
  MyClass() {}
  MyClass(int a)
  : var(a) { }

  MyClass operator+(MyClass &obj) {
   MyClass res;
   res.var= this->var+obj.var;
   return res; 
  }
};
Here, we declared a new res object. We then assigned the sum of the member variables of the current object (this) and the parameter object (obj) to the res object's var member variable. The res object is returned as the result.

This gives us the ability to create objects in main and use the overloaded + operator to add them together.

#include <iostream>
using namespace std;

class MyClass {
    public:
        int var;
        MyClass() { }
        MyClass(int a)
        : var(a) { }

        MyClass operator+(MyClass &obj) {
            MyClass res;
            res.var= this->var+obj.var;
            return res; 
        }
};

int main() {
    MyClass obj1(12), obj2(55);
    MyClass res = obj1+obj2;

    cout << res.var;
}
OUTPUT
67

With overloaded operators, you can use any custom logic needed. However, it's not possible to alter the operators' precedence, grouping, or number of operands.
===================================================================
++=====================++
++=====================++ Inheritance & Polymorphism:: Inheritance
Inheritance
Inheritance is one of the most important concepts of object-oriented programming.
Inheritance allows us to define a class based on another class. This facilitates greater ease in creating and maintaining an application.

The class whose properties are inherited by another class is called the Base class. The class which inherits the properties is called the Derived class. For example, the Daughter class (derived) can be inherited from the Mother class (base).
The derived class inherits all feature from the base class, and can have its own additional features.

img-component
The idea of inheritance implements the is a relationship. For example, mammal IS-A animal, dog IS-A mammal, hence dog IS-A animal as well.
===================================================================
Inheritance
To demonstrate inheritance, let's create a Mother class and a Daughter class:

class Mother
{
 public:
  Mother() {};
  void sayHi() {
    cout << "Hi";
  } 
};

class Daughter 
{
 public: 
  Daughter() {};
};
The Mother class has a public method called sayHi().

The next step is to inherit (derive) the Daughter from the Mother.
===================================================================
Inheritance
This syntax derives the Daughter class from the Mother class.

class Daughter : public Mother
{
 public: 
  Daughter() {};
};
The Base class is specified using a colon and an access specifier: public means that all public members of the base class are public in the derived class.

In other words, all public members of the Mother class become public members of the Daughter class.
===================================================================
Inheritance
As all public members of the Mother class become public members for the Daughter class, we can create an object of type Daughter and call the sayHi() function of the Mother class for that object:

#include <iostream>
using namespace std;

class Mother
{
    public:
        Mother() {};
        void sayHi() {
            cout << "Hi";
        }
};

class Daughter: public Mother
{
    public:
        Daughter() {};
};

int main() {
    Daughter d;
    d.sayHi();
}
OUTPUT
Hi

A derived class inherits all base class methods with the following exceptions:
- Constructors, destructors
- Overloaded operators
- The friend functions

A class can be derived from multiple classes by specifying the base classes in a comma-separated list. For example: class Daughter: public Mother, public Father
===================================================================
++=====================++
++=====================++ Protected Members
Access Specifiers
Up to this point, we have worked exclusively with public and private access specifiers.
Public members may be accessed from anywhere outside of the class, while access to private members is limited to their class and friend functions.

As we've seen previously, it's a good practice to use public methods to access private class variables.
===================================================================
Protected
There is one more access specifier - protected.
A protected member variable or function is very similar to a private member, with one difference - it can be accessed in the derived classes.

class Mother {
 public:
  void sayHi() {
   cout << var;
  }

 private:
  int var=0;

 protected:
  int someVar;
};
Now someVar can be accessed by any class that is derived from the Mother class.
===================================================================
Type of Inheritance
Access specifiers are also used to specify the type of inheritance.
Remember, we used public to inherit the Daughter class:

class Daughter: public Mother
private and protected access specifiers can also be used here.

Public Inheritance: public members of the base class become public members of the derived class and protected members of the base class become protected members of the derived class. A base class's private members are never accessible directly from a derived class, but can be accessed through calls to the public and protected members of the base class.

Protected Inheritance: public and protected members of the base class become protected members of the derived class.

Private Inheritance: public and protected members of the base class become private members of the derived class.

Public inheritance is the most commonly used inheritance type.
If no access specifier is used when inheriting classes, the type becomes private by default.
===================================================================
++=====================++
++=====================++ Derived Class Constructor & Destructor
Inheritance
When inheriting classes, the base class' constructor and destructor are not inherited.
However, they are being called when an object of the derived class is created or deleted.

To further explain this behavior, let's create a sample class that includes a constructor and a destructor:

class Mother {
 public:
 Mother() 
 {
  cout <<"Mother ctor"<<endl;
 }
 ~Mother()
 {
  cout <<"Mother dtor"<<endl;
 }
};
Creating an object in main results in the following output:

#include <iostream>
using namespace std;

class Mother {
    public:
        Mother() 
        {
            cout <<"Mother ctor"<<endl;
        }
        ~Mother()
        {
            cout <<"Mother dtor"<<endl;
        }
};

int main() {
    Mother m;
}
OUTPUT
Mother ctor
Mother dtor

The object is created and then deleted, when the program finishes to run.
===================================================================
Inheritance
Next, let's create a Daughter class, with its own constructor and destructor, and make it a derived class of the Mother:

class Daughter: public Mother {
public:
 Daughter()
 {
  cout <<"Daughter ctor"<<endl;
 }
 ~Daughter()
 {
  cout <<"Daughter dtor"<<endl;
 }
};
Create a Daughter class, with its own constructor and destructor.
===================================================================
Inheritance
Now, what happens when we create a Daughter object?

#include <iostream>
using namespace std;

class Mother {
    public:
        Mother() 
        {
            cout <<"Mother ctor"<<endl;
        }
        ~Mother()
        {
            cout <<"Mother dtor"<<endl;
        }
};

class Daughter: public Mother {
    public:
        Daughter()
        {
            cout <<"Daughter ctor"<<endl;
        }
        ~Daughter()
        {
            cout <<"Daughter dtor"<<endl;
        }
};

int main() {
    Daughter m;
}
Note that the base class' constructor is called first, and the derived class' constructor is called next.
When the object is destroyed, the derived class's destructor is called, and then the base class' destructor is called.

You can think of it as the following: The derived class needs its base class in order to work - that is why the base class is set up first.
===================================================================
Summary
Constructors
The base class constructor is called first.

Destructors
The derived class destructor is called first, and then the base class destructor gets called.

This sequence makes it possible to specify initialization and de-initialization scenarios for your derived classes.
===================================================================
++=====================++
++=====================++ Polymorphism
Polymorphism
The word polymorphism means "having many forms".
Typically, polymorphism occurs when there is a hierarchy of classes and they are related by inheritance.

C++ polymorphism means that a call to a member function will cause a different implementation to be executed depending on the type of object that invokes the function.

Simply, polymorphism means that a single function can have a number of different implementations.
===================================================================
Polymorphism
Polymorphism can be demonstrated more clearly using an example:
Suppose you want to make a simple game, which includes different enemies: monsters, ninjas, etc. All enemies have one function in common: an attack function. However, they each attack in a different way. In this situation, polymorphism allows for calling the same attack function on different objects, but resulting in different behaviors.

The first step is to create the Enemy class.

class Enemy {
 protected: 
  int attackPower;
 public:
  void setAttackPower(int a){
   attackPower = a;
  }
};
Our Enemy class has a public method called setAttackPower, which sets the protected attackPower member variable.
===================================================================
Polymorphism
Our second step is to create classes for two different types of enemies, Ninjas and Monsters. Both of these new classes inherit from the Enemy class, so each has an attack power. At the same time, each has a specific attack function.

class Ninja: public Enemy {
 public:
  void attack() {
   cout << "Ninja! - "<<attackPower<<endl;
  }
};

class Monster: public Enemy {
 public:
  void attack() {
   cout << "Monster! - "<<attackPower<<endl;
  }
};
As you can see, their individual attack functions differ.
Now we can create our Ninja and Monster objects in main.

int main() {   
 Ninja n;
 Monster m;  
}
Ninja and Monster inherit from Enemy, so all Ninja and Monster objects are Enemy objects. This allows us to do the following:

Enemy *e1 = &n;
Enemy *e2 = &m;
We've now created two pointers of type Enemy, pointing them to the Ninja and Monster objects.
===================================================================
Polymorphism
Now, we can call the corresponding functions:

#include <iostream>
using namespace std;

class Enemy {
    protected: 
        int attackPower;
    public:
        void setAttackPower(int a){
            attackPower = a;
        }
};

class Ninja: public Enemy {
    public:
        void attack() {
            cout << "Ninja! - "<<attackPower<<endl;
        }
};

class Monster: public Enemy {
    public:
        void attack() {
            cout << "Monster! - "<<attackPower<<endl;
        }
};

int main() {
    Ninja n;
    Monster m;
    Enemy *e1 = &n;
    Enemy *e2 = &m;

    e1->setAttackPower(20);
    e2->setAttackPower(80);

    n.attack();
    m.attack();
}
OUTPUT
Ninja! - 20
Monster! - 80

We would have achieved the same result by calling the functions directly on the objects. However, it's faster and more efficient to use pointers.
Also, the pointer demonstrates, that you can use the Enemy pointer without actually knowing that it contains an object of the subclass.
===================================================================
++=====================++
++=====================++ Virtual Functions
Virtual Functions
The previous example demonstrates the use of base class pointers to the derived classes. Why is that useful? Continuing on with our game example, we want every Enemy to have an attack() function.
To be able to call the corresponding attack() function for each of the derived classes using Enemy pointers, we need to declare the base class function as virtual.
Defining a virtual function in the base class, with a corresponding version in a derived class, allows polymorphism to use Enemy pointers to call the derived classes' functions.
Every derived class will override the attack() function and have a separate implementation:

class Enemy {
 public:
  virtual void attack() {
  }
};

class Ninja: public Enemy {
 public:
  void attack() {
   cout << "Ninja!"<<endl;
  }
};

class Monster: public Enemy {
 public:
  void attack() {
   cout << "Monster!"<<endl;
 }
};
A virtual function is a base class function that is declared using the keyword virtual.
===================================================================
Virtual Functions
Now, we can use Enemy pointers to call the attack() function.

#include <iostream>
using namespace std;

class Enemy {
    public:
        virtual void attack() { }
};

class Ninja: public Enemy {
    public:
        void attack() {
            cout << "Ninja!"<<endl;
  }
};

class Monster: public Enemy {
    public:
        void attack() {
            cout << "Monster!"<<endl;
        }
};

int main() {
    Ninja n;
    Monster m;
    Enemy *e1 = &n;
    Enemy *e2 = &m;

    e1->attack();
    e2->attack();
}
OUTPUT
Ninja!
Monster!

As the attack() function is declared virtual, it works like a template, telling that the derived class might have an attack() function of its own.
===================================================================
Virtual Functions
Our game example serves to demonstrate the concept of polymorphism; we are using Enemy pointers to call the same attack() function, and generating different results.

e1->attack();
e2->attack();
If a function in the base class is virtual, the function's implementation in the derived class is called according to the actual type of the object referred to, regardless of the declared type of the pointer.

A class that declares or inherits a virtual function is called a polymorphic class.
===================================================================
++=====================++
++=====================++ Abstract Classes
Virtual Functions
Virtual functions can also have their implementation in the base class:

class Enemy {
 public:
  virtual void attack() {
   cout << "Enemy!"<<endl;
  }
};

class Ninja: public Enemy {
 public:
  void attack() {
   cout << "Ninja!"<<endl;
  }
};

class Monster: public Enemy {
 public:
  void attack() {
   cout << "Monster!"<<endl;
  }
};
Now, when you create an Enemy pointer, and call the attack() function, the compiler will call the function, which corresponds to the object's type, to which the pointer points:

#include <iostream>
using namespace std;

class Enemy {
    public:
        virtual void attack() {
            cout << "Enemy!"<<endl;
        }
};

class Ninja: public Enemy {
    public:
        void attack() {
            cout << "Ninja!"<<endl;
        }
};

class Monster: public Enemy {
    public:
        void attack() {
            cout << "Monster!"<<endl;
        }
};

int main() {
    Ninja n;
    Monster m;
    Enemy e;

    Enemy *e1 = &n;
    Enemy *e2 = &m;
    Enemy *e3 = &e;

    e1->attack();
    // Outputs "Ninja!"

    e2->attack();
    // Outputs "Monster!"

    e3->attack();
    // Outputs "Enemy!"
}
OUTPUT
Ninja!
Monster!
Enemy!

This is how polymorphism is generally used. You have different classes with a function of the same name, and even the same parameters, but with different implementations.
===================================================================
Pure Virtual Function
In some situations you'd want to include a virtual function in a base class so that it may be redefined in a derived class to suit the objects of that class, but that there is no meaningful definition you could give for the function in the base class.
The virtual member functions without definition are known as pure virtual functions. They basically specify that the derived classes define that function on their own.
The syntax is to replace their definition by =0 (an equal sign and a zero):

class Enemy {
 public:
  virtual void attack() = 0;
};
The = 0 tells the compiler that the function has no body.
===================================================================
Pure Virtual Functions
A pure virtual function basically defines, that the derived classes will have that function defined on their own.
Every derived class inheriting from a class with a pure virtual function must override that function.

If the pure virtual function is not overridden in the derived class, the code fails to compile and results in an error when you try to instantiate an object of the derived class.
===================================================================
Pure Virtual Functions
The pure virtual function in the Enemy class must be overridden in its derived classes.

#include <iostream>
using namespace std;

class Enemy {
 public:
  virtual void attack() = 0;
};

class Ninja: public Enemy {
 public:
  void attack() {
   cout << "Ninja!"<<endl;
  }
};

class Monster: public Enemy {
 public:
  void attack() {
   cout << "Monster!"<<endl;
  }
};

int main() {
    Ninja n;
    Monster m;
    Enemy *e1 = &n;
    Enemy *e2 = &m;

    e1->attack();
    e2->attack();
}
OUTPUT
Ninja!
Monster!
===================================================================
Abstract Classes
You cannot create objects of the base class with a pure virtual function.
Running the following code will return an error:

#include <iostream>
using namespace std;

class Enemy {
    public:
        virtual void attack() = 0;
};

class Ninja: public Enemy {
    public:
        void attack() {
            cout << "Ninja!"<<endl;
        }
};

class Monster: public Enemy {
    public:
        void attack() {
            cout << "Monster!"<<endl;
        }
};


int main()
{
    Enemy e;
    return 0;
}

These classes are called abstract. They are classes that can only be used as base classes, and thus are allowed to have pure virtual functions.

You might think that an abstract base class is useless, but it isn't. It can be used to create pointers and take advantage of all its polymorphic abilities.
For example, you could write:

#include <iostream>
using namespace std;

class Enemy {
    public:
        virtual void attack() = 0;
};

class Ninja: public Enemy {
    public:
        void attack() {
            cout << "Ninja!"<<endl;
        }
};

class Monster: public Enemy {
    public:
        void attack() {
            cout << "Monster!"<<endl;
        }
};


int main()
{
    Ninja n;
    Monster m;
    Enemy *e1 = &n;
    Enemy *e2 = &m;

    e1->attack();
    e2->attack();

    return 0;
}

In this example, objects of different but related types are referred to using a unique type of pointer (Enemy*), and the proper member function is called every time, just because they are virtual.
===================================================================
++=====================++
++=====================++ Templates, Exceptions, and Files:: Function Templates
Function Templates
Functions and classes help to make programs easier to write, safer, and more maintainable.
However, while functions and classes do have all of those advantages, in certain cases they can also be somewhat limited by C++'s requirement that you specify types for all of your parameters.

For example, you might want to write a function that calculates the sum of two numbers, similar to this:

int sum(int a, int b) {
  return a+b;
}
You can use templates to define functions as well as classes. Let's see how they work.
===================================================================
Function Templates
We can now call the function for two integers in our main.

#include <iostream>
using namespace std;

int sum(int a, int b) {
    return a+b;
}

int main () {
    int x=7, y=15;
    cout << sum(x, y) << endl;
}
OUTPUT
22

The function works as expected, but is limited solely to integers.
===================================================================
Function Templates
It becomes necessary to write a new function for each new type, such as doubles.

double sum(double a, double b) {
  return a+b;
}
Wouldn't it be much more efficient to be able to write one version of sum() to work with parameters of any type?
Function templates give us the ability to do that!
With function templates, the basic idea is to avoid the necessity of specifying an exact type for each variable. Instead, C++ provides us with the capability of defining functions using placeholder types, called template type parameters.

To define a function template, use the keyword template, followed by the template type definition:

template <class T>
We named our template type T, which is a generic data type.
===================================================================
Function Templates
Now we can use our generic data type T in the function:

#include <iostream>
using namespace std;

template <class T>
T sum(T a, T b) {
    return a+b;
}

int main () {
    int x=7, y=15;
    cout << sum(x, y) << endl;
}
OUTPUT
22

The function returns a value of the generic type T, taking two parameters, also of type T.

Our new function worked exactly as the previous one for integer values did.
===================================================================
Function Templates
The same function can be used with other data types, for example doubles:

#include <iostream>
using namespace std;

template <class T>
T sum(T a, T b) {
    return a+b;
}

int main () {
    double x=7.15, y=15.54;
    cout << sum(x, y) << endl;
}
OUTPUT
22.69

The compiler automatically calls the function for the corresponding type.

When creating a template type parameter, the keyword typename may be used as an alternative to the keyword class: template <typename T>.
In this context, the keywords are identical, but throughout this course, we'll use the keyword class.
===================================================================
Function Templates
Template functions can save a lot of time, because they are written only once, and work with different types.
Template functions reduce code maintenance, because duplicate code is reduced significantly.

Enhanced safety is another advantage in using template functions, since it's not necessary to manually copy functions and change types.
===================================================================
++=====================++
++=====================++ Function Templates with Multiple Parameters
Function Templates
Function templates also make it possible to work with multiple generic data types. Define the data types using a comma-separated list.
Let's create a function that compares arguments of varying data types (an int and a double), and prints the smaller one.

template <class T, class U>
As you can see, this template declares two different generic data types, T and U.
===================================================================
Function Templates
Now we can continue with our function declaration:

template <class T, class U>
T smaller(T a, U b) {
  return (a < b ? a : b);
}
The ternary operator checks the a<b condition and returns the corresponding result. The expression (a < b ? a : b) is equivalent to the expression if a is smaller than b, return a, else, return b.
===================================================================
Function Templates
In our main, we can use the function for different data types:

#include <iostream>
using namespace std;

template <class T, class U>
T smaller(T a, U b) {
    return (a < b ? a : b);
}

int main () {
    int x=72;
    double y=15.34;
    cout << smaller(x, y) << endl;
}
OUTPUT
15

The output converts to an integer, because we specified the function template's return type to be of the same type as the first parameter (T), which is an integer.
===================================================================
Function Templates
T is short for Type, and is a widely used name for type parameters.
It's not necessary to use T, however; you can declare your type parameters using any identifiers that work for you. The only terms you need to avoid are C++ keywords.

Remember that when you declare a template parameter, you absolutely must use it in your function definition. Otherwise, the compiler will complain!
===================================================================
++=====================++
++=====================++ Class Templates
Class Templates
Just as we can define function templates, we can also define class templates, allowing classes to have members that use template parameters as types.
The same syntax is used to define the class template:

template <class T>
class MyClass {

};
Just as with function templates, you can define more than one generic data type by using a comma-separated list.
===================================================================
Class Templates
As an example, let's create a class Pair, that will be holding a pair of values of a generic type.

template <class T>
class Pair {
 private:
  T first, second;
 public:
  Pair (T a, T b):
   first(a), second(b) {
  }
};
The code above declares a class template Pair, with two private variables of a generic type, and one constructor to initialize the variables.
===================================================================
Class Templates
A specific syntax is required in case you define your member functions outside of your class - for example in a separate source file.
You need to specify the generic type in angle brackets after the class name.
For example, to have a member function bigger() defined outside of the class, the following syntax is used:

template <class T>
class Pair {
 private:
  T first, second;
 public:
  Pair (T a, T b):
   first(a), second(b){
  }
  T bigger();
};

template <class T>
T Pair<T>::bigger() {
  // some code
}
A specific syntax is required in case you define your member functions outside of your class.
===================================================================
Class Templates
The bigger function returns the greater value of the two member variables.

template <class T>
class Pair {
 private:
  T first, second;
 public:
  Pair (T a, T b):
   first(a), second(b){
  }
  T bigger();
};

template <class T>
T Pair<T>::bigger() {
  return (first>second ? first : second);
}
The ternary operator compares the two variables, returning the greater one.
===================================================================
Class Templates
To create objects of the template class for different types, specify the data type in angle brackets, as we did when defining the function outside of the class.
Here, we create a Pair object for integers.

#include <iostream>
using namespace std;

template <class T>
class Pair {
    private:
        T first, second;
    public:
        Pair (T a, T b):
        first(a), second(b) { }
        T bigger();
};

template <class T>
T Pair<T>::bigger() {
    return (first>second ? first : second);
}

int main()
{
    Pair <int> obj(11, 22);
    cout << obj.bigger();

    return 0;
}
OUTPUT
22

We can use the same class to create an object that stores any other type.

#include <iostream>
using namespace std;

template <class T>
class Pair {
    private:
        T first, second;
    public:
        Pair (T a, T b):
        first(a), second(b) { }
        T bigger();
};

template <class T>
T Pair<T>::bigger() {
    return (first>second ? first : second);
}

int main()
{
    Pair <double> obj(23.43, 5.68);
    cout << obj.bigger();

    return 0;
}
OUTPUT
22
===================================================================
++=====================++
++=====================++ Template Specialization
Template Specialization
In case of regular class templates, the way the class handles different data types is the same; the same code runs for all data types.
Template specialization allows for the definition of a different implementation of a template when a specific type is passed as a template argument.

For example, we might need to handle the character data type in a different manner than we do numeric data types.
To demonstrate how this works, we can first create a regular template.

template <class T>
class MyClass {
 public:
  MyClass (T x) {
   cout <<x<<" -  not a char"<<endl;
  }
};
As a regular class template, MyClass treats all of the various data types in the same way.
===================================================================
Template Specialization
To specify different behavior for the data type char, we would create a template specialization.

template <class T>
class MyClass {
 public:
  MyClass (T x) {
   cout <<x<<" -  not a char"<<endl;
  }
};

template < >
class MyClass<char> {
 public:
  MyClass (char x) {
   cout <<x<<" is a char!"<<endl;
  }
};
First of all, notice that we precede the class name with template<>, including an empty parameter list. This is because all types are known and no template arguments are required for this specialization, but still, it is the specialization of a class template, and thus it requires to be noted as such.

But more important than this prefix, is the <char> specialization parameter after the class template name. This specialization parameter itself identifies the type for which the template class is being specialized (char).

In the example above, the first class is the generic template, while the second is the specialization.
If necessary, your specialization can indicate a completely different behavior from the behavior of the generic template.
===================================================================
Template Specialization
The next step is to declare objects of different types and check the result:

#include <iostream>
using namespace std;

template <class T>
class MyClass {
    public:
        MyClass (T x) {
            cout <<x<<" -  not a char"<<endl;
        }
};

template < >
class MyClass<char> {
    public:
        MyClass (char x) {
            cout <<x<<" is a char!"<<endl;
        }
};

int main () {
    MyClass<int> ob1(42);
    MyClass<double> ob2(5.47);
    MyClass<char> ob3('s');
}
OUTPUT
42 -  not a char
5.47 -  not a char
s is a char!

As you can see, the generic template worked for int and double. However, our template specialization was invoked for the char data type.

Keep in mind that there is no member "inheritance" from the generic template to the specialization, so all members of the template class specializations must be defined on their own.
===================================================================
++=====================++
++=====================++ Exceptions
Exceptions
Problems that occur during program execution are called exceptions.
In C++ exceptions are responses to anomalies that arise while the program is running, such as an attempt to divide by zero.

Tap Continue to learn about C++ mechanisms for handling exceptions.
===================================================================
Throwing Exceptions
C++ exception handling is built upon three keywords: try, catch, and throw.
throw is used to throw an exception when a problem shows up.

For example:
int motherAge = 29;
int sonAge = 36;
if (sonAge > motherAge) {
  throw "Wrong age values";
}
The code looks at sonAge and motherAge, and throws an exception if sonAge is found to be the greater of the two.

In the throw statement, the operand determines a type for the exception. This can be any expression. The type of the expression's result will determine the type of the exception thrown.
===================================================================
Catching Exceptions
A try block identifies a block of code that will activate specific exceptions. It's followed by one or more catch blocks. The catch keyword represents a block of code that executes when a particular exception is thrown.
Code that could generate an exception is surrounded with the try/catch block.
You can specify what type of exception you want to catch by the exception declaration that appears in parentheses following the keyword catch.

For example:

#include <iostream>
using namespace std;

int main()
{
    try {
        int motherAge = 29;
        int sonAge = 36;
        if (sonAge > motherAge) {
            throw 99;
        }
    }
    catch (int x) {
        cout<<"Wrong age values - Error "<<x;
    }

    return 0;
}
OUTPUT
Wrong age values - Error 99

The try block throws the exception, and the catch block then handles it.
The error code 99, which is an integer, appears in the throw statement, so it results in an exception of type int.

Multiple catch statements may be listed to handle various exceptions in case multiple exceptions are thrown by the try block.
===================================================================
++=====================++
++=====================++ More on Exceptions
Exception Handling
Exception handling is particularly useful when dealing with user input.
For example, for a program that requests user input of two numbers, and then outputs their division, be sure that you handle division by zero, in case your user enters 0 as the second number.

#include <iostream>
using namespace std;

int main() {
    int num1;
    cout <<"Enter the first number:"<<endl;
    cin >> num1;
    
    int num2;
    cout <<"Enter the second number:"<<endl;
    cin >> num2;
    
    cout <<"Result:"<<num1 / num2;
}

This program works perfectly if the user enters any number besides 0.

In case of 0 the program crashes, so we need to handle that input.
===================================================================
Exception Handling
In the event that the second number is equal to 0, we need to throw an exception.

#include <iostream>
using namespace std;

int main() {
    int num1;
    cout <<"Enter the first number:";
    cin >> num1;
    
    int num2;
    cout <<"Enter the second number:";
    cin >> num2;
    
    if(num2 == 0) {
        throw 0;
    }
    
    cout <<"Result:"<<num1 / num2;  
}
This code throws an exception with the code 0 of type integer.

Next stop: Using the try/catch block to handle the exception!
===================================================================
Exception Handling
Now we need to handle the thrown exception using a try/catch block.

#include <iostream>
using namespace std;

int main() {
    try {
        int num1;
        cout <<"Enter the first number:";
        cin >> num1;
        
        int num2;
        cout <<"Enter the second number:";
        cin >> num2;
        
        if(num2 == 0) {
            throw 0;
        }
        
        cout <<"Result:"<<num1 / num2; 
    }
    catch(int x) {
        cout <<"Division by zero!";
    }
}

This results in the output of "Division by zero!" as an alternative to a program crash, when 0 is entered as the second number.

In our case, we catch exceptions of type integer only. It's possible to specify that your catch block handles any type of exception thrown in a try block. To accomplish this, add an ellipsis (...) between the parentheses of catch:

try {
  // code
} catch(...) {
  // code to handle exceptions
}
===================================================================
++=====================++
++=====================++ Working with Files
Working with Files
Another useful C++ feature is the ability to read and write to files. That requires the standard C++ library called fstream.
Three new data types are defined in fstream:
ofstream: Output file stream that creates and writes information to files.
ifstream: Input file stream that reads information from files.
fstream: General file stream, with both ofstream and ifstream capabilities that allow it to create, read, and write information to files.

To perform file processing in C++, header files <iostream> and <fstream> must be included in the C++ source file.

#include <iostream>
#include <fstream>
These classes are derived directly or indirectly from the classes istream and ostream. We have already used objects whose types were these classes: cin is an object of class istream and cout is an object of class ostream.
===================================================================
Opening a File
A file must be opened before you can read from it or write to it.
Either the ofstream or fstream object may be used to open a file for writing.
Let's open a file called "test.txt" and write some content to it:

#include <iostream>
#include <fstream>
using namespace std;

int main() {
  ofstream MyFile;
  MyFile.open("test.txt");

  MyFile << "Some text. \n";
}
The above code creates an ofstream object called MyFile, and uses the open() function to open the "test.txt" file on the file system. As you can see, the same stream output operator is used to write into the file.

If the specified file does not exist, the open function will create it automatically.
===================================================================
Closing a File
When you've finished working with a file, close it using the member function close().

#include <iostream>
#include <fstream>
using namespace std;

int main() {
  ofstream MyFile;
  MyFile.open("test.txt");

  MyFile << "Some text! \n";
  MyFile.close();
}
Running this code will cause a "test.txt" file to be created in the directory of your project with "Some text!" written in it.

You also have the option of specifying a path for your file in the open function, since it can be in a location other than that of your project.
===================================================================
++=====================++
++=====================++ More on Files
Working with Files
You can also provide the path to your file using the ofstream objects constructor, instead of calling the open function.

#include <fstream>
using namespace std;

int main() {
  ofstream MyFile("test.txt");

  MyFile << "This is awesome! \n";
  MyFile.close();
}
As with the open function, you can provide a full path to your file located in a different directory.
===================================================================
Working with Files
Under certain circumstances, such as when you don't have file permissions, the open function can fail.
The is_open() member function checks whether the file is open and ready to be accessed.

#include <iostream>
#include <fstream>
using namespace std;

int main() {
  ofstream MyFile("test.txt");

  if (MyFile.is_open()) {
   MyFile << "This is awesome! \n";
  }
  else {
   cout << "Something went wrong";
  }
  MyFile.close();
}
The is_open() member function checks whether the file is open and ready to be accessed.
===================================================================
File Opening Modes
An optional second parameter of the open function defines the mode in which the file is opened. This list shows the supported modes.

img-component
All these flags can be combined using the bitwise operator OR (|).
For example, to open a file in write mode and truncate it, in case it already exists, use the following syntax:

ofstream outfile;
outfile.open("file.dat", ios::out | ios::trunc );

Reading from a File
You can read information from a file using an ifstream or fstream object.

#include <iostream>
#include <fstream>
using namespace std;

int main () {
    ofstream MyFile1("test.txt");
    
    MyFile1 << "This is awesome! \n";
    MyFile1.close();

    string line;
    ifstream MyFile("test.txt");
    while ( getline (MyFile, line) ) {
        cout << line << '\n';
    }
    MyFile.close();
}
OUTPUT
This is awesome! 

The getline function reads characters from an input stream and places them into a string.

The example above reads a text file and prints the contents to the screen.
Our while loop uses the getline function to read the file line by line.
===================================================================


######################################################################################
######################################################################################
##	endroughxfer-urldump #1#
##	<EOF><EOF> Introduction to C++ (Original) Volume 3
######################################################################################
######################################################################################

===================================================================
++=====================++
++=====================++ Getting started with C++
Welcome to C++!
C++ is one of the most popular programming languages.

It is used to build games, operating systems, browsers, and much more!

The biggest advantage of C++ is its scalability and control over how it uses resources.

In this course you will learn how to create real programs in C++, perform various operations, and much more!
===================================================================
Coding
Humans use computer programs to communicate with machines. Without computer programs, we wouldn't have smartphones, websites, or even exploration in outer space.

img-component
Learning some coding can help you innovate and create different solutions to problems, giving you a competitive edge in this technology-driven world. 

Everyone can learn to code with Sololearn.
===================================================================
Output
Most computer programs are designed to produce outputs. Here are some examples:

- "You've got a new message" notifications

- "Game Over" displayed on the screen when playing video games

- Your account balance when checking your online banking app.

The simplest output consists of displaying a message on the screen.
===================================================================
Output
Coders use outputs all the time to check that the computer is following the given instructions and fix problems with code.

The following line of code displays "Welcome to C++" on the screen as an output:

cout << "Welcome to C++";
===================================================================
Lesson Takeaways
Awesome! You completed your first lesson . Remember the following important points:

 You can write code that generates outputs with the cout command

 The cout instruction needs to be followed by <<

What's next?
In the next lesson, you will create code with different types of data.
===================================================================
++=====================++
++=====================++ Statements
Statements
A line of code is called a statement. A statement performs a specific task.

The output command is an example of a statement:

#include <iostream>
using namespace std;

int main() {
    cout << "Coding is an art";
}
OUTPUT
Coding is an art
===================================================================
Semicolons
Each statement in C++ needs to end with a semicolon ;.

The code below contains an error. Fix it by adding a semicolon ; at the end of the statement, then run the code.

#include <iostream>
using namespace std;

int main() {
    cout << "Coding is your new superpower"
}

Errors in code are also known as bugs. Debugging is the process of finding and fixing bugs in code.
===================================================================
Outputting a Text
When printing text outputs, you need to enclose the text in double quotes.

#include <iostream>
using namespace std;

int main() {
    cout << "Level Completed!";
}
Your code will result in an error if you forget the quotes around the text.
===================================================================
Text vs Numbers
Computers treat text and numbers differently. You don't need quotes when outputting numbers.
#include <iostream>
using namespace std;

int main() {
    cout << 42;
}
OUTPUT
42
===================================================================
Translate course
Lesson Takeaways
Great work ! You completed the lesson. You learned that:

 Each statement in C++ needs to end with a semicolon ;

 Text needs to be enclosed in quotes

 C++ is a case-sensitive language.

What's next?
In the next lesson, you will learn about the structure of programs in C++ and will work with more complex programs.
===================================================================
++=====================++
++=====================++ Program Structure
C++ Program
Let's look at the code of the whole program and learn about all the code statements and what they do.

Here is the code to output text:

#include <iostream>
using namespace std;

int main() {
  cout << "C++ is awesome";
}
OUTPUT
C++ is awesome

We are already familiar with the cout command and the statement used to create output, so let's learn what the other parts of the code are.
===================================================================
C++ Program
The first line of the code adds the <iostream> header to the program:

#include <iostream>
C++
A header is a file that contains functions and commands. 

The <iostream> header in C++ contains the cout command, that we used for outputting text. This is why we need to include it in our program, to enable us to use the cout command.

The #include command is used to add a header file to the program. Note the # symbol, it's necessary!
===================================================================
C++ Program
The next statement of the code is:

#include <iostream>
using namespace std;
C++
This tells the program to use the std namespace.

We need to do this as the cout command is part of the std namespace.

A namespace is used to organize code into logical groups and give them names.

So, the std namespace is part of the <iostream> header, containing the cout command.
===================================================================
C++ Program
Let's take a look at our whole program:

#include <iostream>
using namespace std;

int main() {
  cout << "C++ is awesome";
}

After the header, you see the following code:

int main() { 
C++
Each C++ program has a entry point, or starting point, which is a function called main.

We will cover each keyword of the definition in later lessons, when learning about functions. For now, remember that the main function needs to be declared identical to the code above.
=================================================================== FIX THIS
C++ Program
Curly brackets { } indicate the beginning and end of a function, which can also be called the function's body. The code inside the brackets indicates what the function does when executed.

int main() {
  cout << "C++ is awesome";
}
C++
When we run the code, the cout command will be executed.
===================================================================
C++ Program
The main function can contain multiple lines of code.

For example, let's try to output two different text values:
#include <iostream>
using namespace std;

int main() {
  cout << "This is the first line";
  cout << "This is the second line";
}
OUTPUT
This is the first lineThis is the second line

When you run this code, you'll notice that the output is on the same line. This is happening because the cout command does not add a new line at the end of the output.
===================================================================
C++ Program
To add a new line, you can use the endl command, like this:

#include <iostream>
using namespace std;

int main() {
  cout << "This is the first line" << endl;
  cout << "This is the second line";
}
OUTPUT
This is the first line
This is the second line

This adds a new line after the first text. You can use as many endl commands as you need.

Note, that you can use the << symbols to separate different outputs in a single cout statement. For example: cout <<> "One" << endl << "Two" << endl;
===================================================================
Lesson Takeaways
Great job! Now you know how to create valid C++ programs.

Remember the following important points:

The #include statement is used to add a header file to the program.
The using command is used to tell the program which namespace to use.
To use the cout command, you need to include the &lt;iostream&gt; header and use the std namespace.
The starting point of C++ programs is the function called main, which includes the code that you want to run.
The endl command is used to add a new line to the output.
===================================================================
++=====================++
++=====================++ Variables
Variables
Every program works with values.

A variable lets you store a value by assigning it to a name. The name can be used to refer to the value later in the program. 

For example, in game development, you would use a variable to store how many points the player has scored.
===================================================================
Variables
Every variable has a type, which defines the type of the value it holds. 

A variable can hold a text value, a number, a decimal, etc.

We are already familiar with text values - they are created using quotes:

"this is some text"
C++
A text value is called a String. 
===================================================================
Variables
Let's create a variable of type string:

string message;
C++
This creates a variable called message of type string.

Now, our variable message can hold string values.

In programming terms, the process of creating a variable is called declaration.
===================================================================
Variables
After declaring our variable, we can assign it a value using the assignment = operator:

string message;
message = "Welcome";
C++
Now, message holds the value "Welcome". 

Note, that the string value should be in quotes.
===================================================================
Variables
Now, after declaring and assigning a value, we can output the value of our variable:

#include <iostream>
using namespace std;

int main() {
  string message;
  message = "Welcome";
  cout << message;
}
OUTPUT
Welcome
===================================================================
Variables
We can combine the declaration and assignment into one statement, like this:

#include <iostream>
using namespace std;

int main() {
  string message = "Welcome";
  cout << message;
}
OUTPUT
Welcome

This is handy when we already know the value for our variable and makes the code shorter and more readable.
===================================================================
Variables
A variable can change its value during the program multiple times. 

For example, the message can change based on the language:
#include <iostream>
using namespace std;

int main() {
  string message = "Welcome";
  message = "Bienvenue";
  cout << message;
}
OUTPUT
Bienvenue
===================================================================
Lesson Takeaways
Awesome! Here are some key takeaways:

A variable has a name and a type of the value it holds. 
To declare a variable use the type followed by the name of the variable.
You can assign a value to the declared variable using the = operator.
A variable can change its value during the program, by being assigned to a new value.
We will learn about more variable types in the next lesson! 
===================================================================
++=====================++
++=====================++ Data Types
Types
C++ supports many different types for your variables, based on their value.

The int type is used to store whole numbers (called integers in programming):

#include <iostream>
using namespace std;

int main() {
  int points = 128;
  cout << points;
}
OUTPUT
128
===================================================================
Decimals
To store decimals (or floating point numbers), C++ provides the float and double data types.

For example: 

#include <iostream>
using namespace std;

int main() {
  double temp = 84.2;
  cout << temp;
}
OUTPUT
84.2

The term "floating point" refers to the fact that a varying number of digits can appear before and after the decimal point. You could say that the decimal has the ability to " float".
===================================================================
Decimals
The float type is also used to store decimals. 

To specify that the value is a float, we need to use the letter f after it:

#include <iostream>
using namespace std;

int main() {
  float length = 5.31f;
  cout << length;
}
OUTPUT
5.31

This tells C++ to use the value as a float, instead of double.
===================================================================
float vs double
By default, decimal values are of type double.

float uses less storage in the memory, but is not as precise as the double type.

This means that calculations that use floats are faster than the ones that use double, however, the results are less accurate in terms of the decimal digits.

The best practice is to use double, if you do not have any specific requirements to use float.
===================================================================
Char
The char type is used to store a single character.

It is similar to declaring a string, but uses single quotes for the value:

#include <iostream>
using namespace std;

int main() {
  char x = 'H';
  cout << x;
}
OUTPUT
H
===================================================================
Boolean
The bool type can only hold values: either true or false.

It is used when working with conditions.

For example: 

#include <iostream>
using namespace std;

int main() {
  bool online = false;
  cout << online;
}
OUTPUT
0

The online variable can show if the user is online or not.

When you run the code, you'll notice that the output is 0, instead of false. This is because the boolean value true corresponds to 1, while the value false corresponds to 0.
===================================================================
Lesson Takeaways
Great job! Here are some key takeaways about data types:

int is used to hold whole numbers (integers)
double stores decimals.
float is similar to double, but has less precision and requires less memory. You need to prefix the value with the letter 'f' to create floats.
char holds a single character.
bool can have one of the following values: true or false. 
We will learn how to use variables and make calculations in the next lesson. 
===================================================================
++=====================++
++=====================++ Doing Math
Doing Math
C++ supports a number of arithmetic operators that can be used to perform calculations.

Let's declare two variables and output their sum:
#include <iostream>
using namespace std;

int main() {
  int a = 8;
  int b = 24;
  cout << a+b;
}
OUTPUT
32
===================================================================
Doing Math
The result of a calculation can be assigned to another variable.

For example, let's use subtraction to demonstrate:

#include <iostream>
using namespace std;

int main() {
  int price = 20;
  int discount = 5;
  int total = price - discount;
  cout << total;
}
OUTPUT
15
===================================================================
Multiplication
Multiplication is done using the * operator.

For example:

#include <iostream>
using namespace std;

int main() {
  int points = 28;
  int level = 3;
  int result = points * level;
  cout << result;
}
OUTPUT
84
===================================================================
Division
Division is done using the / operator.

Let's calculate how many days there are in 500 hours:

#include <iostream>
using namespace std;

int main() {
  int hours = 500;
  int days = hours / 24;
  cout << days;
}
OUTPUT
20

The result will be a whole number, as we are dividing two integers.
===================================================================
Division
In case we need a more precise result, which includes decimal points, we can use doubles:

#include <iostream>
using namespace std;

int main() {
  double hours = 500;
  double days = hours / 24;
  cout << days;
}
OUTPUT
20.8333
===================================================================
Remainder
The % remainder operator (also called the modulo) is used to find the remainder of a division.

Let's find how many days will be left over if we divide 500 days into weeks:

#include <iostream>
using namespace std;

int main() {
  int days = 500;
  int result = days % 7;
  cout << result;
}
OUTPUT
3
===================================================================
Lesson Takeaways
Doing math is easy and fun! Here are some key takeaways:

You can use basic math operators to perform calculations with values and variables.

+ is addition
- is subtraction
/ is division
Dividing integers results in an integer.
% finds the remainder of a division.
We'll learn more about variables in the next lesson!
===================================================================
++=====================++
++=====================++ More on Variables
Variables
You can declare variables of the same type on one line, separated by commas.

#include <iostream>
using namespace std;

int main() {
  int x=8, y=2;
  cout << x+y;
}
OUTPUT
10

This makes the code shorter and also easier to read.
===================================================================
auto
Another handy keyword is auto.

The auto keyword allows you to set the type of the variable based on its value.


For example:
#include <iostream>
using namespace std;

int main() {
  auto x = 4;
  auto y = 3.37; 
  auto z = "hello"; 
  cout << x << " " << y << " " << z;
}
OUTPUT
4 3.37 hello

When using the auto keyword, the variable must be assigned a value during declaration, else you will get an error.
===================================================================
Naming Variables
C++ is case-sensitive.

For example, the name myvariable is not the same as MYVARIABLE and not the same as MyVariable. 

These are three different variables.

Choose variable names that suggest the usage, for example: firstName, lastName.
===================================================================
Naming Variables
Here are the rules for naming variables:

All variable names must begin with a letter of the alphabet or an underscore( _ ). 
After the initial letter, variable names can contain additional letters, as well as numbers.
Blank spaces or special characters are not allowed in variable names.
There are two popular naming conventions: 

Pascal case: The first letter in the identifier and the first letter of each subsequent concatenated word are capitalized. For example: BackColor

Camel case: The first letter of an identifier is lowercase and the first letter of each subsequent concatenated word is capitalized. For example: backColor
===================================================================
Lesson Takeaways
Great progress!

Here are some key points:

You can declare multiple variables of the same type by separating them with commas.
You can use the auto keyword to automatically set the type of the variable based on the value it's assigned to.
Remember, that C++ is case sensitive.
When naming your variables, remember that they need to start with a letter or underscore and cannot contain special symbols.
You are almost done with the Module! Great job!
===================================================================
++=====================++
++=====================++ Comments
Comments
One more thing before we complete the first module.

Comments are annotations in the code that explain what the code is doing.

Code is for computers, while comments are for humans who read and work with the code.
===================================================================
Comments
A single-line comment starts with two forward slashes and continues until it reaches the end of the line. 

For example:

#include <iostream>
using namespace std;

int main() {
  // storing the height of the user
  double height = 74.8; // this is just a demo value 
  cout << height;
}
OUTPUT
74.8

Adding comments as you write code is a good practice, because they provide clarification and understanding when you need to refer back to it, as well as for others who might need to read it.
===================================================================
Comments
You can also comment out lines of code, in case they are work-in-progress or you don't want to delete them yet:

#include <iostream>
using namespace std;

int main() {
  double height = 74.8;
  //int weight = 40;

  cout << height;
  //cout << weight;
}
OUTPUT
74.8

The commented lines of code will get ignored when you run the program.
===================================================================
Multi-Line Comments
If you need to comment out multiple lines, or write a multi-line comment, you can use the /* */ symbols, like this:

#include <iostream>
using namespace std;

int main() {
  /*  This is just a
  demo program
  that outputs a name */

  string name  = "James";
  cout << name;
}
OUTPUT
James

Anything between the /* and */ symbols becomes a comment.

You can also use multi-line comments to comment out multiple lines of code.
===================================================================
Lesson Takeaways
Now you know how to add comments to your code!

Here are some key takeaways:

Comments are explanatory statements that explain what the code is doing.

They can contain notes, todos as well as code that is work-in-progress.

// starts a single line comment.
/* */ is used for multi-line comments.
===================================================================
++=====================++
++=====================++ Conditionals and Loops:: Taking Input
Taking Input
Your programs may take user input. For example, these can be commands in a game, or values for an application to process and generate the output.

Let's learn how to take input in C++!
===================================================================
Taking Input
To take input, use the cin >> command, which is similar to cout in terms of syntax.

Here is an example:

#include <iostream>
using namespace std;

int main() {
    int age;
    cin >> age;
    
    cout << "Age: " << age;
}
We first declare the variable that will hold our input value.

Then we use it in the cin command.

Note that the brackets are different for cin and cout: cin >> and cout <<
===================================================================
Taking Input
It's important to use the correct type for the variable when taking input.

For example, let's take a string value as input:

#include <iostream>
using namespace std;

int main() {
    string name;
    cout << "Please enter your name: "<< endl;
    cin >> name;
    cout << "You entered:" << name;
}
===================================================================
Multiple Inputs
You can take multiple inputs throughout your program. 

For example, let's take two integers as input and output their sum:

#include <iostream>
using namespace std;

int main() {
    int a, b;
    cin >> a;
    cin >> b;
    cout << a + b;
}
Run the code to see how it works. The program will prompt for input and wait till the user provides the required inputs.

Note that when you run it in our Playground, you need to provide all the inputs in the popup, separated by new lines.
===================================================================
Multiple Inputs
Similar to cout, you can take multiple inputs on a single line, like this:

#include <iostream>
using namespace std;

int main() {
    int a, b;
    cin >> a >> b;
    cout << a + b;
}
===================================================================
Lesson Takeaways
That's how you take input from the user in C++!

First, declare a variable that will store the input. Then, use it in the cin &gt;&gt; command.

The cin &gt;&gt; command is similar to cout &lt;&lt;. It prompts the user for input and stores the entered value in the given variable.

It is important to use the correct type for the variable that will store the input.

In the next lesson, we will learn how to make decisions and check for conditions.
===================================================================
++=====================++
++=====================++ Conditionals
Decision Making
Conditional statements are used to perform different actions based on different conditions. 

For example, a banking application can set different rates based on the client types, a ticketing application can apply discounts based on the age of the buyers, etc. 

Let's learn how to create such programs.
===================================================================
Decision Making
The if statement allows you to run a specified code if a given condition is true.

Here is the syntax:

if(condition) {
  //code to run
}
C++
Note that the code of the if statement is enclosed in curly brackets { }.
===================================================================
if Statement
The following comparison operators may be used to form the condition:

< less than

> greater than

!= not equal to

== equal to

<= less than or equal to

>= greater than or equal to

For example: 

#include <iostream>
using namespace std;

int main() {
    int points = 89;
    if(points >= 70) {
        cout << "Success!";
    }
}

The message will be output only if the condition is satisfied.
===================================================================
if Statement
Remember that you need to use two equal signs (<b>==</b>) to test for equality, since a single equal sign is the assignment operator.

For example, let's check the day value for equality:

#include <iostream>
using namespace std;

int main() {
    int day = 7;
    if(day == 7) {
        cout << "Sunday";
    }
}
OUTPUT
Sunday
===================================================================
else Statement
You can use the else statement after an if statement, if you want to run a code in case the condition is false.

For example:

#include <iostream>
using namespace std;

int main() {
    int grade = 52;
    if(grade >= 75) {
        cout << "Passed!";
    }
    else {
        cout << "Failed";
    }
}
OUTPUT
Failed

The grade value is less than 75, so the code in the else statement will run.

In all previous examples only one statement was used inside the if/else statement, but you may include as many statements as you want.
===================================================================
Nested if Statements
You can use one if-else statement inside another if or else statement.

For example:

#include <iostream>
using namespace std;

int main() {
    int age = 24;
    if(age >= 65) {
        cout << "Senior";
    }
    else {
        if(age >= 18) {
            cout << "Adult";
        }
        else {
            cout << "Child";
        }
    }
}
OUTPUT
Adult

You can nest as many if-else statements as you want, however the code will become harder to read and understand.
===================================================================
else if Statement
Nested if-else statements become hard to read and maintain. This is why C++ provides the else if statement.

Here is our previous example, written using else if statements:

#include <iostream>
using namespace std;

int main() {
    int age = 24;
    if(age >= 65) {
        cout << "Senior";
    }
    else if(age >= 18) {
            cout << "Adult";
    }
    else {
        cout << "Child";
    }
}
You can include as many else if statements as you need.
===================================================================
Lesson Takeaways
Decision making is easy, right?

You can check for a condition using the if statement.

In case the condition is false, the code in an else statement can be executed.

Here is a generic structure of&nbsp;if-else statements:

if(condition) {
  //some code
} 
else if(condition) {
//some other code
} 
else {
  //some other code
}
C++
We will learn about another decision making statement in the next lesson.
===================================================================
++=====================++
++=====================++ The switch Statement
Conditionals
As we have seen in the previous lesson, we can check for multiple conditions using if-else-if statements.

For example, consider the following program, that checks the choice value and outputs the corresponding menu item:

#include <iostream>
using namespace std;

int main() {
    int choice = 2;
    if(choice == 1) {
        cout << "Coffee";
    }
    else if(choice == 2) {
            cout << "Tea";
    }
    else if(choice == 3) {
        cout << "Water";
    }
    else {
        cout << "Invalid Choice";
    }
}
OUTPUT
Tea

When we have a lot of conditions to check, this becomes hard to read and understand. Let's learn how to make it shorter!
===================================================================
switch
The switch statement can be used to check for equality against a list of values, instead of multiple else if statements.

Here is the previous example using a switch: 

#include <iostream>
using namespace std;

int main() {
    int choice = 2;
    switch(choice) {
        case 1:
           cout << "Coffee";
           break;
        case 2:
           cout << "Tea";
           break;
        case 3:
           cout << "Water";
           break;
        default:
          cout << "Invalid Choice";
    }
}
OUTPUT
Tea

Let's understand how it works.
===================================================================
switch
Here is the code again:

#include <iostream>
using namespace std;

int main() {
    int choice = 2;
    switch(choice) {
        case 1:
           cout << "Coffee";
           break;
        case 2:
           cout << "Tea";
           break;
        case 3:
           cout << "Water";
           break;
        default:
          cout << "Invalid Choice";
    }
}
OUTPUT
Tea

Each case has a value to compare with. When the switch variable's value is equal to a case value, the code inside it is executed, until a break statement is reached.
===================================================================
switch
The break statement is used to terminate the switch, when the case it matched.

If you forget to add the break after each case, the program will continue to execute the code in the next case statements, even if their value does not match the variable's value.

Run this example, to see what happens:

#include <iostream>
using namespace std;

int main() {
    int choice = 2;
    switch(choice) {
        case 1:
           cout << "Coffee";
        case 2:
           cout << "Tea";
        case 3:
           cout << "Water";
    }
}
OUTPUT
TeaWater

This type of behavior is called fall-through.
===================================================================
default
You might notice that there is a default case at the end of the switch statement.

It is used to run code, when none of the cases match:

#include <iostream>
using namespace std;

int main() {
    int choice = 8;
    switch(choice) {
        case 1:
           cout << "Coffee";
           break;
        case 2:
           cout << "Tea";
           break;
        case 3:
           cout << "Water";
           break;
        default:
          cout << "Invalid Choice";
    }
}
OUTPUT
Invalid Choice

No break is needed in the default case, as it is always the last statement in the switch.
===================================================================
Lesson Takeaways
The switch statement is a handy way to check for multiple values.

Remember, that each case is followed by a value and a colon.
Each case needs a break statement, or the code of the other cases will continue to get executed. 
The default case can be used to run code if none of the cases match. 
In the next lesson, we will learn how to combine multiple conditions into one. 
===================================================================
++=====================++
++=====================++ Multiple Conditions
Combining Conditions
In some scenarios we need to combine multiple conditions. Let's say we want to check that the temp value is between 36 and 38.

This can be done using the && operator:

#include <iostream>
using namespace std;

int main() {
    double temp = 37.5;
    if(temp >= 36 && temp <= 38) {
        cout << "OK";
    }
}
OUTPUT
OK

The && operator is also referred to as the logical AND operator.
===================================================================
OR
The logical OR operator, written as || combines conditions and checks if any one of them is true.


For example:

#include <iostream>
using namespace std;

int main() {
    int level = 2;
    int points = 321;
    
    if(level > 5 || points > 200) {
        cout << "Welcome";
    }
}
OUTPUT
Welcome

The code above will output "Welcome" if the level value is greater than 5, or points is greater than 200.
===================================================================
NOT
The logical NOT operator ! reverses the condition: in case the condition is true, the not operator will make it false, and vice-e-versa.

For example:

#include <iostream>
using namespace std;

int main() {
    int height = 175;
    
    if(!(height < 150)) {
        cout << "Welcome";
    }
}

!(height < 150) means "if height is NOT less than 150".
===================================================================
Multiple Conditions
You can chain multiple conditions using parentheses and the logical operators.


For example:

#include <iostream>
using namespace std;

int main() {
    string city = "LA";
    int price = 78000;

    if((city == "NY" || city == "LA") && price < 100000) {
        cout << "Yes";
    }
}
OUTPUT
Yes

You can chain as many conditions as you need.
===================================================================
Lesson Takeaways
Logical operators allow you to combine multiple conditions.

The AND operator && combines two conditions and checks if both of them are true.
The OR operator || check if any of the conditions are true.
The NOT operator ! reverses the condition.
You can combine and chain conditions using parentheses and logical operators.
 

The next lesson will be fun! We will cover loops, which allow you to repeat a block of code.
===================================================================
++=====================++
++=====================++ while Loops
Loops
A loop allows you to repeat a block of code multiple times.

For example, a game can use a loop to take input from the user controls, or a warehouse management system can loop through all items in the warehouse and perform calculations.
===================================================================
while Loop
The while loop takes a condition and repeats its statements while the condition is true.

For example: 

#include <iostream>
using namespace std;

int main() {
    int num = 5;
    while(num > 0) {
        cout << num << endl;
        num = num - 1;
    }
}
OUTPUT
5
4
3
2
1

The while loop checks for the condition num &gt; 0. If it evaluates to true, it executes the statements within its body. Then it checks for the statement again and repeats.

The given code will output the numbers 5 to 1 and then stop, as num will reach 0.
===================================================================
while Loop
Let's have a look at the code again:

#include <iostream>
using namespace std;

int main() {
    int num = 5;
    while(num > 0) {
        cout << num << endl;
        num = num - 1;
    }
}
OUTPUT
5
4
3
2
1

The statement num = num - 1 decreases the value of num by 1 each time the loop runs. 

This is important, as without it the loop would run forever.
===================================================================
Increment & Decrement
As it's common to increment and decrement a variable's value by 1 in loops, C++ provides special increment and decrement operators.

For example, num=num-1 can be shortened to num--:

#include <iostream>
using namespace std;

int main() {
    int num = 5;
    while(num > 0) {
        cout << num << endl;
        num--;
    }
}
OUTPUT
5
4
3
2
1
===================================================================
Increment
Similarly, num++ will increase the value of num by 1:

#include <iostream>
using namespace std;

int main() {
    int num = 1;
    while(num <= 10) {
        cout << num << endl;
        num++;
    }
}
OUTPUT
1
2
3
4
5
6
7
8
9
10
===================================================================
Shorthand Operators
Sometimes you might need to increase or decrease the value of a variable by a different value than 1. 

For these cases, C++ provides shorthand operators, too!

For example, x=x+2 can be shortened to x+=2:

#include <iostream>
using namespace std;

int main() {
    int num = 0;
    while(num <= 10) {
        cout << num << endl;
        num+=2;
    }
}
0
2
4
6
8
10

This will output only the even numbers from 0 to 10.

Similarly, there are shorthand operators for other mathematical operations, such as -= for subtraction, *= for multiplication, etc.
===================================================================
do while
Another variation of the while loop is do-while.

Here is an example:

#include <iostream>
using namespace std;

int main() {
    int num = 0;
    do {
        cout << num << endl;
        num+=2;
    } while(num <= 10);
}
OUTPUT
0
2
4
6
8
10

The difference with a while loop is that the condition is checked after the code, meaning the code in the do is executed at least once, even if the condition is false.

Also, note the semicolon after the while condition.
Try changing the condition in the code above to something false and see the result.
===================================================================
Lesson Takeaways
Great progress! Here is a summary about the while loop:

The code in the while loop runs as long as the condition is true.
The ++ and -- operators are used to increase and decrease the value of a variable by one.
C++ provides shorthand operators to perform mathematical operations on a variable, for example num=num * 5 can be written as num * = 5.
- The do-while loop is similar to a while loop, but it is guaranteed to run at least once. 
We will learn about another loop type in the next lesson and perform calculations with it! 
===================================================================
++=====================++
++=====================++ for Loops
for Loops
The for loop has the following form:

#include <iostream>
using namespace std;

int main() {
    for(int i=1;i<=5;i++) {
        cout << i << endl;
    }
}
OUTPUT
1
2
3
4
5

This will output the numbers 1 to 5.
===================================================================
for Loops
Let's look at the code again and understand how it works:

#include <iostream>
using namespace std;

int main() {
    for(int i=1;i<=5;i++) {
        cout << i << endl;
    }
}

The for loop has 3 components in the parentheses:

The first part runs once when we enter the loop and initializes the variable.
The second part is the condition of the loop.
The third part runs every time the loop runs.
Note the semicolons between the components.
===================================================================
for Loops
You can have any type of condition and any type of increment statements in the for loop.

For example:

#include <iostream>
using namespace std;

int main() {
    for(int i=3;i<=20;i+=2) {
        cout << i << endl;
    }
}
OUTPUT
3
5
7
9
11
13
15
17
19

The for loop is best when we know the number of times we need to run the loop.
===================================================================
for Loops
Remember the break; statement that was used in switch to stop it when a case was matched?

It can also be used to stop a loop. 


For example:

#include <iostream>
using namespace std;

int main() {
    for(int i=0;i<10;i++) {
        if(i==5) {
            break;
        }
        cout << i << endl;
    }
}
OUTPUT
0
1
2
3
4

The loop will stop when i reaches the value 5.
Run the code to see the result.
===================================================================
continue
The continue statement skips the current loop iteration and continues with the next one.

For example:

#include <iostream>
using namespace std;

int main() {
    for(int i=0;i<10;i++) {
        if(i==5) {
            continue;
        }
        cout << i << endl;
    }
}
OUTPUT
0
1
2
3
4
6
7
8
9

This will skip the number 5. Run the code to see the result.
===================================================================
Lesson Takeaways 
Great progress! Here is a summary:

The for loop has the following syntax:
for(init; condition; increment) {
   //code
}
C++
 The break statement can be used to stop a loop.
 The continue statement can be used to skip the current iteration of the loop and jump to the next one. 
===================================================================
++=====================++
++=====================++ Arrays
Arrays
Imagine working on a shopping app. Your program will need to store and work with multiple products and their prices. 

Instead of creating separate variables for each price, we can use an array to store all values!

An array stores multiple values in a single variable.
===================================================================
Arrays
An array needs to be declared like a variable, with the type of the items it will hold.

For example:

double prices[5];
C++
The name of the array is prices. It is created to hold 5 double values.
===================================================================
Arrays
After declaring the array, we can access the items using their position, also called the index.

Let's set the item with the index 3 to the value 29.99:

prices[3] = 29.99;
C++
The index is specified in square brackets, next to the array name.
===================================================================
Arrays
The item with index 3 is actually the 4th item of the array. 

That's because array indexes start from 0, meaning that the first element's index is 0 rather than 1. 

Let's set the first items value:

prices[0] = 9.5;
C++
The last item of the prices array will have the index 7, as it can hold 8 items.
===================================================================
Arrays
Similarly, we can access the value of an item using its index:

#include <iostream>
using namespace std;

int main() {
    double prices[8];
    prices[3] = 29.99;
    
    cout << prices[3];
}
OUTPUT
29.99

This will output the value of the 4th item.
===================================================================
Arrays
If you already know what values to store in the array, instead of assigning them one by one, you can use the following syntax:

#include <iostream>
using namespace std;

int main() {
    double prices[] = {5.99, 3.2, 9.99, 29.99};

    cout << prices[2];
}
OUTPUT
9.99

Place the values in a comma-separated list, enclosed in curly braces. 

The code above automatically creates an array containing 4 items, and stores the provided values.

When creating an array using this syntax, you can omit specifying the size in the square brackets, as it will be automatically set based on the number of values provided.
===================================================================
Lesson Takeaways
Awesome! Here are some key points about arrays:

Arrays allow to store multiple values in a single variable.

When creating an array, we need to provide the type of the items and the size of the array, like this:

int numbers[15];
C++
Array items are accessed using their indexes, placed in square brackets. The first item has the index 0.

You can also create an array with values using the following syntax, initializing its values:

int numbers[] = {1, 2, 3, 4, 5};
C++
In the next lesson we will learn how to loop over the values of an array and make calculations. 
===================================================================
++=====================++
++=====================++ Looping Over Arrays
Arrays
We can use a loop to iterate over the items of an array.

For example, let's simply output all the items using a for loop:

#include <iostream>
using namespace std;

int main() {
    double prices[] = {5.99, 3.2, 9.99, 29.99};

    for(int x=0;x<4;x++) {
        cout << prices[x] << endl;
    }
}
OUTPUT
5.99
3.2
9.99
29.99

We used the x variable of the loop as the index for our array. During each iteration of the loop it is incremented and used to access the corresponding item of the array.
===================================================================
Arrays
We can also use loops to perform calculations with arrays.

For example, let's calculate the sum of all values of the prices array:

#include <iostream>
using namespace std;

int main() {
    double prices[] = {5.99, 3.2, 9.99, 29.99};

    double total=0;
    for(int x=0;x<4;x++) {
        total += prices[x];
    }
    cout << total;
}
OUTPUT
49.17

In the code above, we declared a variable total to store the result and assigned it 0.

Then, in the for loop, we added the value of each item of the array to it.
===================================================================
Arrays
To make iterating over arrays easier and shorter, C++ provides another type of the for loop, called the for-each loop.

Here is an example:

#include <iostream>
using namespace std;

int main() {
    double prices[] = {5.99, 3.2, 9.99, 29.99};

    for(double x: prices) {
        cout << x << endl;
    }
}
OUTPUT
5.99
3.2
9.99
29.99

The loop creates a variable, which is automatically assigned to each value of the array during the loop.

We called it x in our example, but you can name it anything you want.

Notice the colon after the variable - it reads as "for each x in prices".
===================================================================
Arrays
Remember the auto keyword? It was used to automatically set the type of a variable based on the value it is assigned to.

We can also use the auto keyword in a for-each loop:

#include <iostream>
using namespace std;

int main() {
    double prices[] = {5.99, 3.2, 9.99, 29.99};

    for(auto x: prices) {
        cout << x << endl;
    }
}
OUTPUT
5.99
3.2
9.99
29.99

Now, the code will work for any type of arrays.
===================================================================
Lesson Takeaways
Now you know how to loop over arrays.

You can use a for loop to loop over an array.

For example, for an array called arr of 5 items:

for(int x=0;x<5; x++) {
   //current item is arr[x]
}
C++
Another way to loop over arrays is the for-each loop:

for(auto x: arr) {
  //current item is x
}

C++
The auto keyword automatically takes the type of the item's value.

We will learn about multidimensional arrays in the next lesson!
===================================================================
++=====================++
++=====================++ Multidimensional Arrays
Multidimensional Arrays
An array can have multiple dimensions (or indices) to represent a grid.

For example, imagine a movie theater program that is storing the seats, which have a row and column number.

Or a game board/map, where each square has 2 coordinates.

The arrays in the examples would have 2 dimensions.
===================================================================
Multidimensional Arrays
To create multidimensional arrays, place each array within its own set of square brackets:

int seats[2][3] = {{1, 2, 3}, {4, 5, 6}};
C++
The array has two dimensions: 2 rows and 3 columns.
===================================================================
Multidimensional Arrays
The elements are accessed by using the row index and column index of the array.

For example, let's output the 3rd item of the 2nd array:

#include <iostream>
using namespace std;

int main() {
    int seats[2][3] = {{1, 2, 3}, {4, 5, 6}};

    cout << seats[1][2];
}
OUTPUT
6

The first index accesses the 2nd array, while the second index accesses the 3rd item in it.
===================================================================
Multidimensional Arrays
Indices for two-dimensional arrays are also called row and column indices.

We can format the code in the following way to make it easier to read:

#include <iostream>
using namespace std;

int main() {
    int seats[2][3] = {
        {1, 2, 3}, 
        {4, 5, 6}
    };

    cout << seats[1][2];
}
OUTPUT
6

Each row is an item, which is an array. So, to access a value, we provide the row index, then the column index.
===================================================================
Multidimensional Arrays
We can loop over a two-dimensional array using nested for loops:

#include <iostream>
using namespace std;

int main() {
    int seats[2][3] = {
        {1, 2, 3}, 
        {4, 5, 6}
    };

    for(int i=0;i<2;i++) {
        for(int j=0;j<3;j++) {
            cout << seats[i][j] << endl;
        }
    }
}
OUTPUT
1
2
3
4
5
6

The first loop iterates over the rows, the second one over their items.
===================================================================
Lesson Takeaways
Arrays with multiple dimensions are simply arrays that contain other arrays.

The number of square brackets match the dimension of the array, for example [][] denotes a 2-dimensional array.

To access the items of the array, specify the row index in the first square brackets, followed by the column index in the second.
===================================================================
++=====================++
++=====================++ Pointers
Arrays
In the previous lessons we have seen arrays with a fixed size.

Their size needed to be defined when they were created using a constant number.

What if we needed an array that has a size that is a variable? 

For example, imagine a program that takes an image as input and processes it using an array. The image size is only known when the program runs, so we do not know in advance what the size of the array will be.

In these situations we need to dynamically allocate memory. Let's learn how to do that!
===================================================================
Pointers
In order to learn about dynamic memory, we first need to learn about pointers.

All variables that you create are stored in the memory. 

A pointer is a variable that stores the memory address of another variable as its value.

It is defined using the asterisk sign and is defined just like a variable:

int *p;
C++
Now, p is a pointer that will point to an integer value in the memory.

Let's learn how to assign it a value!
===================================================================
Pointers
The address of a variable can be accessed using the & operator.

For example:

#include <iostream>
using namespace std;

int main() {
    int num = 42;

    int *p = &num;

    cout << p;
}
OUTPUT
0x7ffed8ddacc4

The code above creates a pointer called p and assigns it the memory address of the variable num.

Run the code to see the value of p. It is a long hexadecimal number that represents a memory address.
===================================================================
Pointers
The asterisk * is also used to access the value stored at a memory address. It is called the dereference operator.

Let's output the value stored at the address to which the pointer p points:

#include <iostream>
using namespace std;

int main() {
    int num = 42;

    int *p = &num;

    cout << *p;
}
OUTPUT
42

This will output the value of the variable, to which the pointer points to.

Remember the following:

The & operator is used to access the memory location of a variable.
The * operator is used to access the value of a memory address that is stored in a pointer.
The same * sign is also used to declare a pointer, and it is different from the dereference operator.
===================================================================
Pointers
Because the pointer points to the memory address of a variable, we can use it to change the value of that variable:

For example:

#include <iostream>
using namespace std;

int main() {
    int num = 42;

    int *p = &num;

    *p = 8;

    cout << num;
}
OUTPUT
8

Run the code to see the result.

We have changed the value of a variable using the pointer. 

*p is basically an alias for num, meaning that they represent the same thing. When you change the value of *p, num is also changed, and vice-e-versa, changing num will also change the value of *p.
===================================================================
Arrays & Pointers
The name of an array is actually a pointer to its first element.

Each element can be accessed by incrementing the pointer.

Here is an example:

#include <iostream>
using namespace std;

int main() {
    int arr[] = {2, 4, 6, 8};

    int *p = arr;

    cout << *p << endl;
    cout << *(p+1) << endl;
    cout << *(p+2) << endl;
}
OUTPUT
2
4
6

Note, that we used *p = arr and not &arr. This is because the array name is already a pointer and is the same as &arr[0].

Also, note that we used the dereference operator like this: *(p+1), so that it accessed the incremented address. The parentheses are important!
===================================================================
Arrays & Pointers
We can use pointers to arrays to loop over them.

Here is an example:

#include <iostream>
using namespace std;

int main() {
    int arr[] = {2, 4, 6, 8};

    int *p = arr;

    for(int i=0;i<4;i++) {
        cout << *p << endl;
        p++;
    }
}
OUTPUT
2
4
6
8

During each iteration of the loop we simply increment the pointer by 1, making it point to the next element of the array.
===================================================================
Lesson Takeaways
Pointers might seem confusing at first, but don't worry, you'll get the hang of it! Here are the key takeaways:

A pointer is a variable that stores the memory address of another variable.
It is declared using a * and the type of the value it points to, for example: int *p;
The memory address of a variable can be accessed using the & operator, and assigned to a pointer, for example: int *p = &num;
The value of a memory address can be accessed using the * operator, for example *p is the value stored at the address that p points to.
A pointer can also be assigned to an array and be used to access the elements of the array, by simply incrementing the pointer.
We learned about pointers, because they are used for dynamic memory allocation, which we will cover in the next lesson!
===================================================================
++=====================++
++=====================++ Dynamic Memory
Dynamic Memory
Now that we know about pointers, let's learn how to create dynamic arrays (arrays which have a variable size). 

These are handy when we need to allocate new memory based on user input.

For example, let's say we have a size variable that takes a value dynamically, based on user input.

For simplicity of our example, we will just assign it a value:

int size = 8;
C++
Now, we want to create an array of that size dynamically.
===================================================================
Dynamic Memory
The new operator is used to allocate memory. It then can be assigned to a pointer.

For example:

int size = 8;

int * p = new int[size];
C++
Now, p hold the address of our newly allocated memory, which can be used to store 8 item, because size = 8;
===================================================================
Dynamic Memory
Now, we can use our pointer to assign values and access them:

#include <iostream>
using namespace std;

int main() {
    int size = 8;

    int *p = new int[size];

    p[0] = 128;
    p[1] = 888;
    p[2] = 9;

    cout << *(p+1);
}
OUTPUT
888
===================================================================
Dynamic Memory
We can also use size in a for loop, as the condition.

Let's assign the number 1 to size to the array elements, then output them:

#include <iostream>
using namespace std;

int main() {
    int size = 8;

    int *p = new int[size];

    for(int i=0;i<size;i++) {
        p[i] = i;
    }

    for(int i=0;i<size;i++) {
       cout << p[i] << endl;
    }
}
OUTPUT
0
1
2
3
4
5
6
7

You can change the value of size, and see how the same code works for any given value.
===================================================================
Dynamic Memory
In most cases, memory allocated dynamically is only needed during specific periods of time within a program; once it is no longer needed, it can be freed so that the memory becomes available again for other requests of dynamic memory.

This is the purpose of the delete operator:

delete[] p;
C++
This frees up the memory taken by the array p.
===================================================================
Lesson Takeaways
Dynamic memory allocation is useful in many situations, such as when your program depends on input. As an example, when your program needs to read an image file, it doesn't know in advance the size of the image file and the memory necessary to store the image.

Memory is allocated using the <b>new</b> keyword: int* p = new int[size];
After the allocated memory is no longer needed, we can free it up using delete: delete[] p;
===================================================================
++=====================++
++=====================++ Functions:: Functions
Functions
A function is a block of code designed to perform a particular task.

For example, your program can have functions like login(), logout(), convert(), withdraw(), etc.

The purpose of a function is to create it once and call it multiple times when needed to perform particular tasks.
===================================================================
Functions
You can define your own functions to perform your desired tasks. 

Here is an example:

void hello() {
  cout << "Hello!" << endl;
  cout << "I am a sample function";
}
C++
The code above declares a function called "hello", which outputs 2 lines of text.

Note that the name of the function is followed by parentheses ().

The statements of the function are inside curly braces {}.
===================================================================
Functions
Let's understand how the function is defined:

void hello() {
  cout << "Hello!" << endl;
  cout << "I am a sample function";
}
C++
void means that this function does not have a return value. You will learn more about return values later in this module.

hello is the name of the function.
===================================================================
Functions
Now that we have our function defined, we can use it in our program by "calling" it.

To call a function, type its name followed by a set of parentheses. 

For example, let's call our hello function in main:

#include <iostream>
using namespace std;

void hello() {
    cout << "Hello!" << endl;
    cout << "I am a sample function";
}

int main() {
    hello();
}
OUTPUT
Hello!
I am a sample function
===================================================================
Calling a Function
You can call a function as many times as necessary. 

For example: 

#include <iostream>
using namespace std;

void hello() {
    cout << "Hello!" << endl;
    cout << "I am a sample function" << endl;
}

int main() {
    hello();
    hello();
    hello();
}
OUTPUT
Hello!
I am a sample function
Hello!
I am a sample function
Hello!
I am a sample function

Also, note that it is important to declare the function prior to calling it.

If we put the declaration of our function after main, we would get an error.
===================================================================
Lesson Takeaways
Awesome! Remember the following points:

 Functions are reusable; we define them once and can call them multiple times.
 To call a function, use its name, followed by parentheses. 
 The void keyword means that the function does not return a value. 
We will learn about return values in the next lessons, so stay tuned!
===================================================================
++=====================++
++=====================++ Function Parameters
Function Parameters
Functions can have parameters, which they can use in their code.

The parameters are defined in the parentheses, and can be used like variables in the function.

For example, let's add a string name parameter to our hello function:

void hello(string name) {
  cout << "Hello, " << name << endl;
}
C++
The function above takes a string called name as its parameter, which is used in the function's output.
===================================================================
Function Parameters
Now, when calling the function, we need to pass it a value for the name parameter inside the parentheses:

#include <iostream>
using namespace std;

void hello(string name) {
    cout << "Hello, " << name << endl;
}

int main() {
    hello("James");
    hello("Amy");
}
OUTPUT
Hello, James
Hello, Amy

This way, we can call our function with different parameters and generate different results based on them.

The values passed as parameters when calling the function are called arguments.
===================================================================
Multiple Parameters
Functions can take multiple parameters. For that, we simply need to separate them using commas, for example:

void sum(int x, int y) {
  cout << x+y << endl;
}
C++
Now, our sum() function takes two integer parameters.

Note, that we need to define the data type and name for each parameter.
===================================================================
Multiple Parameters
Now, when calling the function, we need to provide all the parameters:

#include <iostream>
using namespace std;

void sum(int x, int y) {
    cout << x+y << endl;
}

int main() {
    sum(21, 56);
}
OUTPUT
77

Note that the arguments need to match the parameters and must be passed in the same order, separated by commas.
===================================================================
Function Parameters
Function parameters allow you to use the same function for different values, making it reusable.

For example, we can take user input and pass it as a function argument:

#include <iostream>
using namespace std;

void square(int x) {
    cout << x*x << endl;
}

int main() {
    int a;
    cin >> a;
    square(a);
}
===================================================================
Lesson Takeaways
Function parameters are really helpful and allow you to use the same function for different values!

Here is a summary:

 You can define parameters in the parentheses, by providing the data type and a name. 
 Multiple parameters need to be separated by commas.
 The parameters are available in the function as variables of the given names.
 When calling a function, you need to provide its parameters in the same order, as defined, separated by commas. 
You will learn how to return values in the next lesson. 
===================================================================
++=====================++
++=====================++ Returning From Functions
Return Values
The functions we have seen so far output their result.

In some cases we do not need to output the result, but need to assign it to a variable to work with it in our program.

In these cases, we need our function to return the result value, instead of outputting it. 
===================================================================
The Return Type
Let's have a look at a function from our previous examples:

#include <iostream>
using namespace std;

void sum(int x, int y) {
    cout << x+y << endl;
}

int main() {
    sum(21, 56);
}
OUTPUT
77

It takes two parameters and outputs their sum.

The void keyword in the definition specifies that the function does not return any value.
===================================================================
The Return Type
Let's change the function and specify the return type to be an <b>int</b>:

int sum(int x, int y) {
    
}
C++
This means that now our sum function will return an integer value.
===================================================================
Returning a Value
Now, we can return our result using the <b>return</b> keyword:

int sum(int x, int y) {
    return (x+y);
}
C++
The return keyword stops the function from executing. If there are any statements after return, they won't run.
===================================================================
Returning a Value
After we have created our function, that returns a value, we can call it in our code and assign the result to a variable:

#include <iostream>
using namespace std;

int sum(int x, int y) {
    return (x+y);
}

int main() {
    int result;
    result = sum(21, 56);
    cout << result;
}
OUTPUT
77

Returning is useful when you don't need to output the result of the function, but need to use it in your code.

For example, a bank account's withdraw() function could return the remaining balance of the account.
===================================================================
Lesson Takeaways
Now you know how to return values from functions!

Here is a quick summary:

Use the return keyword to return a value from your function.
The function needs to have its return type specified before its name.
The <b>void</b> type specifies that the function does not return any value.
The returned value can be assigned to a variable when calling the function.
We will learn about function overloading in the next lesson! It will be fun!
===================================================================
++=====================++
++=====================++ Overloading Functions
Overloading Functions
Let's have a look at one of our example functions:

#include <iostream>
using namespace std;

void sum(int x, int y) {
    cout << x+y << endl;
}

int main() {
    sum(42, 31);
}
OUTPUT
73

The function takes two integers as its parameters and outputs their sum.

What if we want the function to also work for other data types, such as doubles? 

Let's learn how to make that work.
===================================================================
Overloading Functions
C++ allows you to define a function with the same name but different parameter data types.

Here is our sum function, using double parameters:

void sum(double x, double y) {
  cout << x+y << endl;
}
C++
We used the same function name, and changed the parameter data types.

This is called function overloading.
===================================================================
Overloading Functions
Now, when we call the function, the correct version will be called based on the type of the argument.

Here is an example:

#include <iostream>
using namespace std;

void sum(int x, int y) {
    cout << x+y << endl;
}
void sum(double x, double y) {
    cout << x+y << endl;
}

int main() {
    sum(42, 31);
    sum(3.14, 5.66);
}
OUTPUT
73
8.8

The function that corresponds to the given parameters will be called.
===================================================================
Overloading Functions
You cannot overload function declarations that differ only by return type.

The following declaration results in an error:

#include <iostream>
using namespace std;

int demo(int x) {
    return x;
}
double demo(int x) {
    return x/2;
}
int main() {
    demo(8);
}
===================================================================
Default Arguments
Another handy thing when working with functions are default arguments.

When defining a function, you can specify a default value for each of the last parameters.

If the corresponding argument is missing when you call a function, it uses the provided default value.

For example: 

#include <iostream>
using namespace std;

int area(int x, int y=1) {
    return x*y;
}

int main() {
    cout << area(8, 5);
}
OUTPUT
40

As you can see, we can simply assign a value to the parameter in the parentheses.

Now we can call the function with or without that parameter: 

#include <iostream>
using namespace std;

int area(int x, int y=1) {
    return x*y;
}

int main() {
    cout << area(8, 5) << endl;
    cout << area(6) << endl;
}
OUTPUT
40

The default value will be used for the parameter, when no value is provided.
===================================================================
Lesson Takeaways
You did it! This was the last lesson of the course!

Overloading functions allows you to use the same name of the function with different parameter data types.
Default arguments allow to specify a default value for the last parameters of the function by assigning them values right in the definition.
===================================================================